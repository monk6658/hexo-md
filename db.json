{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/img/1.jpg","path":"img/1.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-tree-master/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/hexo-theme-tree-master/source/Tree.png","path":"Tree.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-tree-master/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/hexo-theme-tree-master/source/css/main.css","path":"css/main.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-tree-master/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-tree-master/source/lib/jquery-3.4.1.min.js","path":"lib/jquery-3.4.1.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-tree-master/source/lib/jquery.pjax.js","path":"lib/jquery.pjax.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-tree-master/source/lib/font-awesome/font-awesome.min.css","path":"lib/font-awesome/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-tree-master/source/lib/highlight/highlight.pack.js","path":"lib/highlight/highlight.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-tree-master/source/lib/highlight/darcula.css","path":"lib/highlight/darcula.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-tree-master/source/lib/valine/Valine-1.3.10-min.js","path":"lib/valine/Valine-1.3.10-min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-tree-master/source/lib/valine/av-3.0.4-min.js","path":"lib/valine/av-3.0.4-min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-tree-master/source/lib/busuanzi/2.3/busuanzi.pure.mini.js","path":"lib/busuanzi/2.3/busuanzi.pure.mini.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/img/1.jpg","hash":"af43d741cabeb3bc39b4ed687d4b26fcd32aced9","modified":1603334267937},{"_id":"source/_posts/java学习/悲观锁与乐观锁.md","hash":"cd768d34a1da67633605af89ada164da507cca37","modified":1603335796518},{"_id":"source/_posts/并发/悲观锁与乐观锁.md","hash":"98de30bee00eb1d9ee89d3a7cb92b84e75895d80","modified":1603352800132},{"_id":"source/_posts/并发/悲观锁与乐观锁/1.jpg","hash":"af43d741cabeb3bc39b4ed687d4b26fcd32aced9","modified":1603334267937},{"_id":"themes/hexo-theme-tree-master/.idea/sonarlint/issuestore/6/1/61fcc5dc86156eced51c3f77543b4ce794270a75","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1603273609270},{"_id":"themes/hexo-theme-tree-master/.idea/sonarlint/issuestore/a/d/ad7b02212a1965c07c8c4dd19448dd19caa5bfcd","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1603273609290},{"_id":"themes/hexo-theme-tree-master/.idea/sonarlint/issuestore/8/1/810bd34b9dde89d5ef3d26dfe556a8721f389d97","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1603273609276},{"_id":"themes/hexo-theme-tree-master/.idea/sonarlint/issuestore/c/d/cd089ae45ce870c45e434019e8f1ed4f066cd425","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1603273609280},{"_id":"themes/hexo-theme-tree-master/.idea/sonarlint/issuestore/e/e/ee4a58438362a0a884ed503ec9e3c485ddd767b4","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1603273609286},{"_id":"themes/hexo-theme-tree-master/_config.yml","hash":"b31e5938c20556d8152bc81a8c303b1c7abb3292","modified":1603265792292},{"_id":"themes/hexo-theme-tree-master/.idea/checkstyle-idea.xml","hash":"d3fb9f06395bf11afcfa6ff94f4f68410e98c318","modified":1603266117636},{"_id":"themes/hexo-theme-tree-master/.idea/hexo-theme-tree-master.iml","hash":"402e38def734b476c4c697c9a36892567ab6af8b","modified":1603266117533},{"_id":"themes/hexo-theme-tree-master/.idea/modules.xml","hash":"745aa760d10290bbb82469b0cb9ede14fb9f782f","modified":1603266117668},{"_id":"themes/hexo-theme-tree-master/.idea/misc.xml","hash":"0d81a7654b3ab7b1fa88a882ac9120820be781d1","modified":1603266117593},{"_id":"themes/hexo-theme-tree-master/layout/index.ejs","hash":"101bd5d563884579882c8caaeafbc3139134bab4","modified":1604281191687},{"_id":"themes/hexo-theme-tree-master/layout/layout.ejs","hash":"b1cbe3e0c52a8fa644a5adb97b31b5ecfdec2162","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/layout/post.ejs","hash":"b1a2a9f5d58c0670758e59b464101469a5cbb96c","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/source/404.html","hash":"cfa1b96d02d143d77c0ba519dab1c23de0cae6ee","modified":1597668858000},{"_id":"source/_posts/数据库操作/oracle/oracle 误删数据、表的恢复.md","hash":"03f667162ea4bce162d994fc90250952d2e63657","modified":1603264900170},{"_id":"themes/hexo-theme-tree-master/README.md","hash":"bb4595e8fe8c2ecf71b0449db8a77519307bf75b","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/.idea/workspace.xml","hash":"019ebeab8352be4886482e74942a30d683dfb3ab","modified":1604371799607},{"_id":"themes/hexo-theme-tree-master/layout/_partial/footer.ejs","hash":"06db3c1053c4246b1ec9393d5243f0ba0677f00e","modified":1603266382730},{"_id":"themes/hexo-theme-tree-master/layout/_partial/head.ejs","hash":"5d16d1de945009b44ede462acb65aa9d3ee83551","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/layout/_partial/header.ejs","hash":"563a3085c8d85f11606f16c61afc8a978d44ef27","modified":1603848566822},{"_id":"themes/hexo-theme-tree-master/layout/_partial/sidebar.ejs","hash":"92b16592de84b9d836cda23f5065a188fbca1191","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/layout/_partial/totop.ejs","hash":"a94c4b350b76d21bb530095981049a2647cc6273","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/source/css/main.css","hash":"a374eb273c29e0c96cdbb11e3e204051c6a3dfcc","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/source/js/main.js","hash":"32d1a54470d1b6b3afe4086bacd6f97340b1c460","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/source/lib/jquery.pjax.js","hash":"13485a1e2dc9c8df28267549de1b8af8f39061d9","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/.idea/inspectionProfiles/Project_Default.xml","hash":"498c60a454dd7c623548ac61a842b479f4cae4ca","modified":1603266117496},{"_id":"themes/hexo-theme-tree-master/.idea/sonarlint/issuestore/index.pb","hash":"2d85691d56a8d7c11208348ba9166ccc8e31c413","modified":1603849870067},{"_id":"themes/hexo-theme-tree-master/source/lib/highlight/highlight.pack.js","hash":"84a7e42dfa8c44a422a8328277d660d9428fcea6","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/source/lib/highlight/darcula.css","hash":"7740224d07375ddc321147dffabbfa83e39f0d8b","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/source/favicon.ico","hash":"268be0a863caae7c5a732fb8a911a81434f31117","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/source/lib/busuanzi/2.3/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/source/lib/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/source/lib/font-awesome/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/source/Tree.png","hash":"e5a30d5edf5aa2dc39fb4db7b4761b516826cf5b","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/source/lib/valine/Valine-1.3.10-min.js","hash":"e3a340d0c39eee2ae651284fda9d351e752fcbd0","modified":1597668858000},{"_id":"themes/hexo-theme-tree-master/source/lib/valine/av-3.0.4-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1597668858000},{"_id":"source/_posts/java学习/工具包学习/Comparable与Comparator.md","hash":"7706ca789aa16f52cab2e04fb8c6eea9e26bd92f","modified":1603846746709},{"_id":"source/_posts/java学习/排序/Comparable与Comparator.md","hash":"67bc5173ed5d8d01a1744b7c08e2e5789562f371","modified":1603792139502},{"_id":"source/_posts/并发/悲观锁与乐观锁/2.jpg","hash":"ff8b670c49ffa31a77e86d7e9352ea12a81f932d","modified":1603337163487},{"_id":"source/_posts/并发/悲观锁与乐观锁/3.png","hash":"b8fd91642354dffc1e98f5eb9ea2bd6e4d27b8fa","modified":1603338905854},{"_id":"public/search.xml","hash":"2178f2ebdf9d7efbf7aad27d67305ecfcbb958fe","modified":1616635136877},{"_id":"public/sitemap.xml","hash":"2b88df01cdd5f0c3e3e284a5eb12a90d0a633968","modified":1616635136877},{"_id":"public/atom.xml","hash":"dfee4f4d79c69f9cbbfdc30c187c709923187e26","modified":1616635136877},{"_id":"public/content.json","hash":"d9439d603d15a568cc5bf10b882d6e8db1c16702","modified":1616635136877},{"_id":"public/2020/10/27/java学习/工具包学习/Comparable与Comparator/index.html","hash":"314233abce85124563530bb042c04e82ecf5118b","modified":1616635136877},{"_id":"public/2020/10/27/java学习/排序/Comparable与Comparator/index.html","hash":"1ab2f7708ef93d28fb32780b3db8afaf4772a703","modified":1603846763183},{"_id":"public/2020/10/21/并发/悲观锁与乐观锁/index.html","hash":"4c3d8337a18b0972197728145f85696bdeff36c1","modified":1616635136877},{"_id":"public/2020/10/21/数据库操作/oracle/oracle 误删数据、表的恢复/index.html","hash":"f65c7b2b4f5f8f2cdd9b7c1ede4532a005838f30","modified":1616635136877},{"_id":"public/archives/index.html","hash":"06293f9ad1a8ec2ed8336c1b17e27f0b094c3027","modified":1616635136877},{"_id":"public/archives/2020/index.html","hash":"0750be37e967d9075b94c36ce7a310e125f8b280","modified":1616635136877},{"_id":"public/archives/2020/10/index.html","hash":"40a5e9cbe2e3459fdbcbaa9860c713df4af81c33","modified":1616635136877},{"_id":"public/categories/并发/index.html","hash":"33b7298af802f51e74fbff514b0f5c55371101c5","modified":1616635136877},{"_id":"public/categories/oracle/index.html","hash":"8c1988e2de4526781df1bc8993f4cef2c54faf26","modified":1616635136877},{"_id":"public/categories/JAVA/index.html","hash":"a7939c9a76a5fe887b6c1b9db232b8c56521cfc5","modified":1616635136877},{"_id":"public/index.html","hash":"06293f9ad1a8ec2ed8336c1b17e27f0b094c3027","modified":1616635136877},{"_id":"public/tags/锁机制/index.html","hash":"33b7298af802f51e74fbff514b0f5c55371101c5","modified":1616635136877},{"_id":"public/tags/并发/index.html","hash":"33b7298af802f51e74fbff514b0f5c55371101c5","modified":1616635136877},{"_id":"public/tags/运维/index.html","hash":"df4d0598f1ed3812156a6fc9cdfdc205947863d6","modified":1616635136877},{"_id":"public/tags/tag2/index.html","hash":"df4d0598f1ed3812156a6fc9cdfdc205947863d6","modified":1616635136877},{"_id":"public/tags/tag3/index.html","hash":"df4d0598f1ed3812156a6fc9cdfdc205947863d6","modified":1616635136877},{"_id":"public/tags/Comparable/index.html","hash":"a7939c9a76a5fe887b6c1b9db232b8c56521cfc5","modified":1616635136877},{"_id":"public/tags/Comparator/index.html","hash":"a7939c9a76a5fe887b6c1b9db232b8c56521cfc5","modified":1616635136877},{"_id":"public/tags/排序/index.html","hash":"a7939c9a76a5fe887b6c1b9db232b8c56521cfc5","modified":1616635136877},{"_id":"public/img/1.jpg","hash":"af43d741cabeb3bc39b4ed687d4b26fcd32aced9","modified":1603846763183},{"_id":"public/2020/10/21/并发/悲观锁与乐观锁/1.jpg","hash":"af43d741cabeb3bc39b4ed687d4b26fcd32aced9","modified":1603846763183},{"_id":"public/2020/10/21/并发/悲观锁与乐观锁/2.jpg","hash":"ff8b670c49ffa31a77e86d7e9352ea12a81f932d","modified":1603846763183},{"_id":"public/2020/10/21/并发/悲观锁与乐观锁/3.png","hash":"b8fd91642354dffc1e98f5eb9ea2bd6e4d27b8fa","modified":1603846763183},{"_id":"public/favicon.ico","hash":"268be0a863caae7c5a732fb8a911a81434f31117","modified":1603846763183},{"_id":"public/404.html","hash":"cfa1b96d02d143d77c0ba519dab1c23de0cae6ee","modified":1603846763183},{"_id":"public/Tree.png","hash":"e5a30d5edf5aa2dc39fb4db7b4761b516826cf5b","modified":1603846763183},{"_id":"public/css/main.css","hash":"a374eb273c29e0c96cdbb11e3e204051c6a3dfcc","modified":1603846763183},{"_id":"public/lib/highlight/darcula.css","hash":"7740224d07375ddc321147dffabbfa83e39f0d8b","modified":1603846763183},{"_id":"public/lib/busuanzi/2.3/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1603846763183},{"_id":"public/js/main.js","hash":"32d1a54470d1b6b3afe4086bacd6f97340b1c460","modified":1603846763183},{"_id":"public/lib/jquery.pjax.js","hash":"13485a1e2dc9c8df28267549de1b8af8f39061d9","modified":1603846763183},{"_id":"public/lib/font-awesome/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1603846763183},{"_id":"public/lib/highlight/highlight.pack.js","hash":"84a7e42dfa8c44a422a8328277d660d9428fcea6","modified":1603846763183},{"_id":"public/lib/valine/Valine-1.3.10-min.js","hash":"e3a340d0c39eee2ae651284fda9d351e752fcbd0","modified":1603846763183},{"_id":"public/lib/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1603846763183},{"_id":"public/lib/valine/av-3.0.4-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1603846763183},{"_id":"source/_posts/工具安装使用/hexo搭建静态博客/hexo搭建静态博客.md","hash":"7706ca789aa16f52cab2e04fb8c6eea9e26bd92f","modified":1603846746709},{"_id":"public/2020/10/27/工具安装使用/hexo搭建静态博客/hexo搭建静态博客/index.html","hash":"1b475fdece5d70cca1967b7f9de99ae6f1430fe4","modified":1603848277817},{"_id":"source/_posts/工具安装使用/hexo/hexo搭建静态博客.md","hash":"fd2b8679931a6cd98b5aa6f7aec1707814692408","modified":1603852518168},{"_id":"themes/hexo-theme-tree-master/.idea/sonarlint/issuestore/f/f/ffbe371271d61902bfc1e3df5e271b00972f5e3e","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1603849870057},{"_id":"themes/hexo-theme-tree-master/.idea/sonarlint/issuestore/3/7/37dc2368c0eeb0deca5c17ec2a96a7f69018a097","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1603849870061},{"_id":"themes/hexo-theme-tree-master/.idea/sonarlint/issuestore/1/c/1c0d0e557c7e2f5e2e5f7a35b073632859e9c485","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1603849870066},{"_id":"themes/hexo-theme-tree-master/.idea/vcs.xml","hash":"c75f6a9f73d6a593959bbeeb5c8d00a5d919408c","modified":1603848529980},{"_id":"source/_posts/并发/Java并发基础常见面试题总结.md","hash":"6b21cb48d4be80db2beb372f3c594cbc55b77985","modified":1606097954453},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/1266638-20180711104523327-1846448145.png","hash":"58d69f763006d5d0b849d2218dcbb3de33eaca25","modified":1604453307010},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/aa18972bd40735fa901e88768e0966b60d2408f4.jpeg","hash":"dbe756a54c16d40e0e12ad5766c84be9e7a8eac7","modified":1604453081444},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/image-20201104094518290.png","hash":"0cd61c362b6d15708a12782788a4be46acce4403","modified":1604454318298},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/进程.png","hash":"7177eef6438ff01a1f4b7b804cb64012df3a74d9","modified":1604370020549},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/JVM运行时数据区域.png","hash":"ad04409d1de7cdbb01b3fc6a8b7368ef80f5d80b","modified":1604369676808},{"_id":"source/_posts/数据库操作/oracle/oracle基础语法.md","hash":"44ecf6ab7c4d112b54e8ff335812993ac915f3be","modified":1608255999628},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/2019-4死锁1.png","hash":"f63036ff0143e102534f0d1ce048060550b1dd59","modified":1606092994209},{"_id":"public/2020/12/17/数据库操作/oracle/oracle基础语法/index.html","hash":"bfb844c0e7eb624fc79039bd1a34d1c34d33f876","modified":1616635136877},{"_id":"public/2020/10/28/工具安装使用/hexo/hexo搭建静态博客/index.html","hash":"06cb0f03749f3fad77940210c17b64a44eb74071","modified":1616635136877},{"_id":"public/archives/2020/11/index.html","hash":"432687a94d8e1dbc9f7a77e4dec2a2b20bc98a08","modified":1616635136877},{"_id":"public/archives/2020/12/index.html","hash":"d995dbea7ee479acc4e7689b3fbb96728295b825","modified":1616635136877},{"_id":"public/categories/工具/index.html","hash":"a99ec37fba8265dc5f1ba4f50e3231e5142dfae0","modified":1616635136877},{"_id":"public/2020/11/03/并发/Java并发基础常见面试题总结/index.html","hash":"0cc38fa93100b9d33f0003258208a97a78e0ee11","modified":1616635136877},{"_id":"public/tags/hexo/index.html","hash":"bcdd660d7a7b6d4de79177e680d04766ea104768","modified":1616635136877},{"_id":"public/tags/博客/index.html","hash":"bcdd660d7a7b6d4de79177e680d04766ea104768","modified":1616635136877},{"_id":"public/tags/死锁/index.html","hash":"432687a94d8e1dbc9f7a77e4dec2a2b20bc98a08","modified":1616635136877},{"_id":"public/tags/sql/index.html","hash":"d995dbea7ee479acc4e7689b3fbb96728295b825","modified":1616635136877},{"_id":"public/tags/oracle/index.html","hash":"d995dbea7ee479acc4e7689b3fbb96728295b825","modified":1616635136877},{"_id":"public/tags/函数/index.html","hash":"d995dbea7ee479acc4e7689b3fbb96728295b825","modified":1616635136877},{"_id":"public/2020/11/03/并发/Java并发基础常见面试题总结/aa18972bd40735fa901e88768e0966b60d2408f4.jpeg","hash":"dbe756a54c16d40e0e12ad5766c84be9e7a8eac7","modified":1614842817729},{"_id":"public/2020/11/03/并发/Java并发基础常见面试题总结/2019-4死锁1.png","hash":"f63036ff0143e102534f0d1ce048060550b1dd59","modified":1614842817729},{"_id":"public/2020/11/03/并发/Java并发基础常见面试题总结/1266638-20180711104523327-1846448145.png","hash":"58d69f763006d5d0b849d2218dcbb3de33eaca25","modified":1614842817729},{"_id":"public/2020/11/03/并发/Java并发基础常见面试题总结/进程.png","hash":"7177eef6438ff01a1f4b7b804cb64012df3a74d9","modified":1614842817729},{"_id":"public/2020/11/03/并发/Java并发基础常见面试题总结/image-20201104094518290.png","hash":"0cd61c362b6d15708a12782788a4be46acce4403","modified":1614842817729},{"_id":"public/2020/11/03/并发/Java并发基础常见面试题总结/JVM运行时数据区域.png","hash":"ad04409d1de7cdbb01b3fc6a8b7368ef80f5d80b","modified":1614842817729},{"_id":"source/_posts/工具安装使用/证书/证书转换.md","hash":"0ddfa7b9d089606277e89737c0aacf5b0c526f60","modified":1614845217269},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程.md","hash":"ddcbf98ca8ba8356365a6df7dd4fe5157b5799c0","modified":1616635085968},{"_id":"source/_posts/java学习/位运算/位运算.md","hash":"8a0776d5a5381f2c928fd098bed131de3489d43b","modified":1615175720394},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203152515345.png","hash":"09e330644c71af9e78329785aaf54a396d661a41","modified":1612337115349},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203152440553.png","hash":"e8f95e2d1dcab08ac7a4fc0e73e31e9dff26c717","modified":1612337080577},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203153111406.png","hash":"125f84d4ad3b6fca1e75479452badbf6f897da56","modified":1612337471409},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203153129592.png","hash":"244032c6dd4eaef751952bb68689d83a48670bb4","modified":1612337489611},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203155002102.png","hash":"57e0191c1d8496bb74432eaab811cf47adcd9dee","modified":1612338602121},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203162313099.png","hash":"ebe93141ad2771656f32cdb97eebaefb7f5f4fb7","modified":1612340593135},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203162451622.png","hash":"4a762cf85e3cc28a232092af08626e371fa80379","modified":1612340691642},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203162712582.png","hash":"60cde1b555bcae1077ab9740d08efe4905b790af","modified":1612340832605},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203163036267.png","hash":"33ef70255b94a9f7b676c91aedc8d88dd7e8b604","modified":1612341036290},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203162538492.png","hash":"4a762cf85e3cc28a232092af08626e371fa80379","modified":1612340738512},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203162535500.png","hash":"4a762cf85e3cc28a232092af08626e371fa80379","modified":1612340735519},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203162645487.png","hash":"6b7c1786db83304463f95cabed86e95a734b2d22","modified":1612340805518},{"_id":"public/2021/03/08/java学习/位运算/位运算/index.html","hash":"e430f91e770ea185ea3aa4cd0c17203ee712a68a","modified":1616635136877},{"_id":"public/2021/03/25/工具安装使用/聚合支付拉起流程/流程/index.html","hash":"e2bb9a858eda26804ba71214cdb4922a674f54d9","modified":1616635136877},{"_id":"public/2020/10/28/工具安装使用/证书/证书转换/index.html","hash":"848d7c6590b5bad1899789b52d5ccace257cd584","modified":1616635136877},{"_id":"public/categories/JAVA、位运算/index.html","hash":"3021a4fb927320987c7adcdcd54037d56cd41a28","modified":1616635136877},{"_id":"public/archives/2021/index.html","hash":"874f980fc31ce295bb056334df66c4ccc6baff93","modified":1616635136877},{"_id":"public/archives/2021/03/index.html","hash":"874f980fc31ce295bb056334df66c4ccc6baff93","modified":1616635136877},{"_id":"public/tags/pfx/index.html","hash":"ef50412a0588df9dda75ec354719d3a9ab01ae11","modified":1616635136877},{"_id":"public/tags/cer/index.html","hash":"ef50412a0588df9dda75ec354719d3a9ab01ae11","modified":1616635136877},{"_id":"public/tags/按位与/index.html","hash":"3021a4fb927320987c7adcdcd54037d56cd41a28","modified":1616635136877},{"_id":"public/tags/位运算/index.html","hash":"3021a4fb927320987c7adcdcd54037d56cd41a28","modified":1616635136877},{"_id":"public/2021/03/25/工具安装使用/聚合支付拉起流程/流程/image-20210203152515345.png","hash":"09e330644c71af9e78329785aaf54a396d661a41","modified":1616635136877},{"_id":"public/2021/03/25/工具安装使用/聚合支付拉起流程/流程/image-20210203153111406.png","hash":"125f84d4ad3b6fca1e75479452badbf6f897da56","modified":1616635136877},{"_id":"public/2021/03/25/工具安装使用/聚合支付拉起流程/流程/image-20210203162712582.png","hash":"60cde1b555bcae1077ab9740d08efe4905b790af","modified":1616635136877},{"_id":"public/2021/03/25/工具安装使用/聚合支付拉起流程/流程/image-20210203152440553.png","hash":"e8f95e2d1dcab08ac7a4fc0e73e31e9dff26c717","modified":1616635136877},{"_id":"public/2021/03/25/工具安装使用/聚合支付拉起流程/流程/image-20210203153129592.png","hash":"244032c6dd4eaef751952bb68689d83a48670bb4","modified":1616635136877},{"_id":"public/2021/03/25/工具安装使用/聚合支付拉起流程/流程/image-20210203162313099.png","hash":"ebe93141ad2771656f32cdb97eebaefb7f5f4fb7","modified":1616635136877},{"_id":"public/2021/03/25/工具安装使用/聚合支付拉起流程/流程/image-20210203162451622.png","hash":"4a762cf85e3cc28a232092af08626e371fa80379","modified":1616635136877},{"_id":"public/2021/03/25/工具安装使用/聚合支付拉起流程/流程/image-20210203162535500.png","hash":"4a762cf85e3cc28a232092af08626e371fa80379","modified":1616635136877},{"_id":"public/2021/03/25/工具安装使用/聚合支付拉起流程/流程/image-20210203162538492.png","hash":"4a762cf85e3cc28a232092af08626e371fa80379","modified":1616635136877},{"_id":"public/2021/03/25/工具安装使用/聚合支付拉起流程/流程/image-20210203162645487.png","hash":"6b7c1786db83304463f95cabed86e95a734b2d22","modified":1616635136877},{"_id":"public/2021/03/25/工具安装使用/聚合支付拉起流程/流程/image-20210203163036267.png","hash":"33ef70255b94a9f7b676c91aedc8d88dd7e8b604","modified":1616635136877},{"_id":"public/2021/03/25/工具安装使用/聚合支付拉起流程/流程/image-20210203155002102.png","hash":"57e0191c1d8496bb74432eaab811cf47adcd9dee","modified":1616635136877}],"Category":[{"name":"并发","_id":"ckgk92amw0002agtkho3b1why"},{"name":"oracle","_id":"ckgk92an00007agtk9d97af1j"},{"name":"JAVA","_id":"ckgsoyer30001i8tkh1ms43k1"},{"name":"工具","_id":"ckgspxgm10005c0tkh11ggy47"},{"name":"JAVA、位运算","_id":"ckmo6tkfo0001t4tkhr8qh9kd"}],"Data":[],"Page":[],"Post":[{"title":"悲观锁与乐观锁","date":"2020-10-21T06:16:33.000Z","description":"乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。","typora-copy-images-to":"upload","_content":"\n## 悲观锁\n\n[TOC]\n\n### 1. 悲观锁定义\n\n在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。\n\n**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。**\n\n悲观锁，具有强烈的独占和排他特性。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。\n\n### 2. 种类\n\n1. <font color = \"red\"> 共享锁【shared locks】又称为读锁，简称S锁。</font>多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。\n2. <font color = \"red\"> 排他锁【exclusive locks】又称为写锁，简称X锁。</font>排他锁就是不能与其他锁（共享锁、排他锁）并存，获取排他锁的事务是可以对数据行读取和修改。\n\n### 3. 说明\n\n悲观并发控制实际上是“先取锁再访问”的保守策略。\n\n- **处理加锁的机制会让数据库产生额外的开销，增加产生死锁的机会**\n- ***降低并行性***（一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。）\n\n### 4. 实现方式\n\n1. 修改之前，先加上排它锁(exclusive locks)\n\n2. 加锁失败，说明该记录正在修改，线程陷入等待或者抛出异常\n\n3. 加锁成功，修改，事务结束之后解锁\n\n   ![](悲观锁与乐观锁/1.jpg)\n\n[^ ]:注：mysql设置非立马提交（set autocommit=0）MySQL InnoDB 默认行级锁。行级锁都是基于索引的，如果一条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住。\n\n\n\n## 乐观锁\n\n### 1. 乐观锁定义\n\n**乐观锁一般会使用版本号机制或CAS算法实现。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**，像数据库提供的类似于write_condition机制**，其实都是提供的乐观锁。在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式**CAS**实现的。\n\n### 2. 两种实现方式\n\n#### 2.1 **CAS 实现**(compare and swap[比较与交换])\n\nJava 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。\n\n![img](悲观锁与乐观锁/2.jpg)\n\n#### 2.2 版本号机制\n\n##### 2.2.1 ABA 问题\n\n![](悲观锁与乐观锁/3.png)\n\n如图流程可以看出，当线程一读取变量v=1，这时线程二读取的变量v=1，并且线程二对变量v=1 进行了修改操作。使v=2，之后又使v=1。这时，线程一进行了CAS操作，发现变量v=1,这时线程一也成功了，但是过程是存在ABA问题的。\n\n##### 2.2.2 版本号\n\n乐观锁每次操作时都带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。除了 version 以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。\n\n### 3. **CAS与synchronized的使用情景**\n\n> **简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）**\n\n1. 对于资源竞争较少（线程冲突较轻）的情况，使用`synchronized`同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。\n2. 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。\n\n补充： Java并发编程这个领域中`synchronized`关键字一直都是元老级的角色，很久之前很多人都会称它为 **“重量级锁”** 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 **偏向锁** 和 **轻量级锁** 以及其它**各种优化**之后变得在某些情况下并不是那么重了。`synchronized`的底层实现主要依靠 **Lock-Free** 的队列，基本思路是 **自旋后阻塞**，**竞争切换后继续竞争锁**，**稍微牺牲了公平性，但获得了高吞吐量**。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。\n\n### 4. 两者比较\n\n|          | 乐观锁                                                       | 悲观锁                                                       |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 适用场景 | **适用于写比较少的情况下（多读场景）**                       | **多写的场景下用悲观锁就比较合适**                           |\n| 实现     | 1. CAS<br /> 2. 版本号机制                                   | 1. 传统的关系型数据库的行锁，表锁等，读锁，写锁等<br />2. [synchronized](https://www.jianshu.com/p/c8f997e7f75c) 关键字 |\n| 缺点     | 1. ABA问题<br />2. 循环时间长开销大（自旋CAS（也就是不成功就一直循环执行直到成功））<br />3. 只能保证一个共享变量的原子操作 | 1.效率低<br />2.容易产生死锁                                 |\n\n\\- [什么是乐观锁，什么是悲观锁](https://www.jianshu.com/p/d2ac26ca6525)\n\n\\- [何谓悲观锁与乐观锁](https://snailclimb.gitee.io/javaguide/#/docs/essential-content-for-interview/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E4%B9%8B%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81?id=_1-%e7%89%88%e6%9c%ac%e5%8f%b7%e6%9c%ba%e5%88%b6)","source":"_posts/并发/悲观锁与乐观锁.md","raw":"---\ntitle: 悲观锁与乐观锁 #文章页面上的显示名称，一般是中文\ndate: 2020-10-21 14:16:33 #文章生成时间，一般不改，当然也可以任意修改\ncategories: 并发 #分类\ntags: [锁机制,并发] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: 乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。\ntypora-copy-images-to: upload\n---\n\n## 悲观锁\n\n[TOC]\n\n### 1. 悲观锁定义\n\n在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。\n\n**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。**\n\n悲观锁，具有强烈的独占和排他特性。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。\n\n### 2. 种类\n\n1. <font color = \"red\"> 共享锁【shared locks】又称为读锁，简称S锁。</font>多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。\n2. <font color = \"red\"> 排他锁【exclusive locks】又称为写锁，简称X锁。</font>排他锁就是不能与其他锁（共享锁、排他锁）并存，获取排他锁的事务是可以对数据行读取和修改。\n\n### 3. 说明\n\n悲观并发控制实际上是“先取锁再访问”的保守策略。\n\n- **处理加锁的机制会让数据库产生额外的开销，增加产生死锁的机会**\n- ***降低并行性***（一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。）\n\n### 4. 实现方式\n\n1. 修改之前，先加上排它锁(exclusive locks)\n\n2. 加锁失败，说明该记录正在修改，线程陷入等待或者抛出异常\n\n3. 加锁成功，修改，事务结束之后解锁\n\n   ![](悲观锁与乐观锁/1.jpg)\n\n[^ ]:注：mysql设置非立马提交（set autocommit=0）MySQL InnoDB 默认行级锁。行级锁都是基于索引的，如果一条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住。\n\n\n\n## 乐观锁\n\n### 1. 乐观锁定义\n\n**乐观锁一般会使用版本号机制或CAS算法实现。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**，像数据库提供的类似于write_condition机制**，其实都是提供的乐观锁。在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式**CAS**实现的。\n\n### 2. 两种实现方式\n\n#### 2.1 **CAS 实现**(compare and swap[比较与交换])\n\nJava 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。\n\n![img](悲观锁与乐观锁/2.jpg)\n\n#### 2.2 版本号机制\n\n##### 2.2.1 ABA 问题\n\n![](悲观锁与乐观锁/3.png)\n\n如图流程可以看出，当线程一读取变量v=1，这时线程二读取的变量v=1，并且线程二对变量v=1 进行了修改操作。使v=2，之后又使v=1。这时，线程一进行了CAS操作，发现变量v=1,这时线程一也成功了，但是过程是存在ABA问题的。\n\n##### 2.2.2 版本号\n\n乐观锁每次操作时都带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。除了 version 以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。\n\n### 3. **CAS与synchronized的使用情景**\n\n> **简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）**\n\n1. 对于资源竞争较少（线程冲突较轻）的情况，使用`synchronized`同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。\n2. 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。\n\n补充： Java并发编程这个领域中`synchronized`关键字一直都是元老级的角色，很久之前很多人都会称它为 **“重量级锁”** 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 **偏向锁** 和 **轻量级锁** 以及其它**各种优化**之后变得在某些情况下并不是那么重了。`synchronized`的底层实现主要依靠 **Lock-Free** 的队列，基本思路是 **自旋后阻塞**，**竞争切换后继续竞争锁**，**稍微牺牲了公平性，但获得了高吞吐量**。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。\n\n### 4. 两者比较\n\n|          | 乐观锁                                                       | 悲观锁                                                       |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 适用场景 | **适用于写比较少的情况下（多读场景）**                       | **多写的场景下用悲观锁就比较合适**                           |\n| 实现     | 1. CAS<br /> 2. 版本号机制                                   | 1. 传统的关系型数据库的行锁，表锁等，读锁，写锁等<br />2. [synchronized](https://www.jianshu.com/p/c8f997e7f75c) 关键字 |\n| 缺点     | 1. ABA问题<br />2. 循环时间长开销大（自旋CAS（也就是不成功就一直循环执行直到成功））<br />3. 只能保证一个共享变量的原子操作 | 1.效率低<br />2.容易产生死锁                                 |\n\n\\- [什么是乐观锁，什么是悲观锁](https://www.jianshu.com/p/d2ac26ca6525)\n\n\\- [何谓悲观锁与乐观锁](https://snailclimb.gitee.io/javaguide/#/docs/essential-content-for-interview/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E4%B9%8B%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81?id=_1-%e7%89%88%e6%9c%ac%e5%8f%b7%e6%9c%ba%e5%88%b6)","slug":"并发/悲观锁与乐观锁","published":1,"updated":"2020-10-22T07:46:40.132Z","_id":"ckgk92amv0001agtkacmb2l9r","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h2><p>[TOC]</p>\n<h3 id=\"1-悲观锁定义\"><a href=\"#1-悲观锁定义\" class=\"headerlink\" title=\"1. 悲观锁定义\"></a>1. 悲观锁定义</h3><p>在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。</p>\n<p><strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</strong></p>\n<p>悲观锁，具有强烈的独占和排他特性。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>\n<h3 id=\"2-种类\"><a href=\"#2-种类\" class=\"headerlink\" title=\"2. 种类\"></a>2. 种类</h3><ol>\n<li><font color=\"red\"> 共享锁【shared locks】又称为读锁，简称S锁。</font>多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li>\n<li><font color=\"red\"> 排他锁【exclusive locks】又称为写锁，简称X锁。</font>排他锁就是不能与其他锁（共享锁、排他锁）并存，获取排他锁的事务是可以对数据行读取和修改。</li>\n</ol>\n<h3 id=\"3-说明\"><a href=\"#3-说明\" class=\"headerlink\" title=\"3. 说明\"></a>3. 说明</h3><p>悲观并发控制实际上是“先取锁再访问”的保守策略。</p>\n<ul>\n<li><strong>处理加锁的机制会让数据库产生额外的开销，增加产生死锁的机会</strong></li>\n<li><strong><em>降低并行性</em></strong>（一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。）</li>\n</ul>\n<h3 id=\"4-实现方式\"><a href=\"#4-实现方式\" class=\"headerlink\" title=\"4. 实现方式\"></a>4. 实现方式</h3><ol>\n<li><p>修改之前，先加上排它锁(exclusive locks)</p>\n</li>\n<li><p>加锁失败，说明该记录正在修改，线程陷入等待或者抛出异常</p>\n</li>\n<li><p>加锁成功，修改，事务结束之后解锁</p>\n<p><img src=\"/2020/10/21/%E5%B9%B6%E5%8F%91/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/1.jpg\"></p>\n</li>\n</ol>\n<p>[^ ]:注：mysql设置非立马提交（set autocommit=0）MySQL InnoDB 默认行级锁。行级锁都是基于索引的，如果一条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住。</p>\n<h2 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h2><h3 id=\"1-乐观锁定义\"><a href=\"#1-乐观锁定义\" class=\"headerlink\" title=\"1. 乐观锁定义\"></a>1. 乐观锁定义</h3><p><strong>乐观锁一般会使用版本号机制或CAS算法实现。</strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量<strong>，像数据库提供的类似于write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p>\n<h3 id=\"2-两种实现方式\"><a href=\"#2-两种实现方式\" class=\"headerlink\" title=\"2. 两种实现方式\"></a>2. 两种实现方式</h3><h4 id=\"2-1-CAS-实现-compare-and-swap-比较与交换\"><a href=\"#2-1-CAS-实现-compare-and-swap-比较与交换\" class=\"headerlink\" title=\"2.1 CAS 实现(compare and swap[比较与交换])\"></a>2.1 <strong>CAS 实现</strong>(compare and swap[比较与交换])</h4><p>Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>\n<p><img src=\"/2020/10/21/%E5%B9%B6%E5%8F%91/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/2.jpg\" alt=\"img\"></p>\n<h4 id=\"2-2-版本号机制\"><a href=\"#2-2-版本号机制\" class=\"headerlink\" title=\"2.2 版本号机制\"></a>2.2 版本号机制</h4><h5 id=\"2-2-1-ABA-问题\"><a href=\"#2-2-1-ABA-问题\" class=\"headerlink\" title=\"2.2.1 ABA 问题\"></a>2.2.1 ABA 问题</h5><p><img src=\"/2020/10/21/%E5%B9%B6%E5%8F%91/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/3.png\"></p>\n<p>如图流程可以看出，当线程一读取变量v=1，这时线程二读取的变量v=1，并且线程二对变量v=1 进行了修改操作。使v=2，之后又使v=1。这时，线程一进行了CAS操作，发现变量v=1,这时线程一也成功了，但是过程是存在ABA问题的。</p>\n<h5 id=\"2-2-2-版本号\"><a href=\"#2-2-2-版本号\" class=\"headerlink\" title=\"2.2.2 版本号\"></a>2.2.2 版本号</h5><p>乐观锁每次操作时都带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。除了 version 以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。</p>\n<h3 id=\"3-CAS与synchronized的使用情景\"><a href=\"#3-CAS与synchronized的使用情景\" class=\"headerlink\" title=\"3. CAS与synchronized的使用情景\"></a>3. <strong>CAS与synchronized的使用情景</strong></h3><blockquote>\n<p><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></p>\n</blockquote>\n<ol>\n<li>对于资源竞争较少（线程冲突较轻）的情况，使用<code>synchronized</code>同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>\n<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>\n</ol>\n<p>补充： Java并发编程这个领域中<code>synchronized</code>关键字一直都是元老级的角色，很久之前很多人都会称它为 <strong>“重量级锁”</strong> 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它<strong>各种优化</strong>之后变得在某些情况下并不是那么重了。<code>synchronized</code>的底层实现主要依靠 <strong>Lock-Free</strong> 的队列，基本思路是 <strong>自旋后阻塞</strong>，<strong>竞争切换后继续竞争锁</strong>，<strong>稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>\n<h3 id=\"4-两者比较\"><a href=\"#4-两者比较\" class=\"headerlink\" title=\"4. 两者比较\"></a>4. 两者比较</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>乐观锁</th>\n<th>悲观锁</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>适用场景</td>\n<td><strong>适用于写比较少的情况下（多读场景）</strong></td>\n<td><strong>多写的场景下用悲观锁就比较合适</strong></td>\n</tr>\n<tr>\n<td>实现</td>\n<td>1. CAS<br> 2. 版本号机制</td>\n<td>1. 传统的关系型数据库的行锁，表锁等，读锁，写锁等<br>2. <a href=\"https://www.jianshu.com/p/c8f997e7f75c\">synchronized</a> 关键字</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>1. ABA问题<br>2. 循环时间长开销大（自旋CAS（也就是不成功就一直循环执行直到成功））<br>3. 只能保证一个共享变量的原子操作</td>\n<td>1.效率低<br>2.容易产生死锁</td>\n</tr>\n</tbody></table>\n<p>- <a href=\"https://www.jianshu.com/p/d2ac26ca6525\">什么是乐观锁，什么是悲观锁</a></p>\n<p>- <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/essential-content-for-interview/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E4%B9%8B%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81?id=_1-%e7%89%88%e6%9c%ac%e5%8f%b7%e6%9c%ba%e5%88%b6\">何谓悲观锁与乐观锁</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h2><p>[TOC]</p>\n<h3 id=\"1-悲观锁定义\"><a href=\"#1-悲观锁定义\" class=\"headerlink\" title=\"1. 悲观锁定义\"></a>1. 悲观锁定义</h3><p>在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。</p>\n<p><strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</strong></p>\n<p>悲观锁，具有强烈的独占和排他特性。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>\n<h3 id=\"2-种类\"><a href=\"#2-种类\" class=\"headerlink\" title=\"2. 种类\"></a>2. 种类</h3><ol>\n<li><font color=\"red\"> 共享锁【shared locks】又称为读锁，简称S锁。</font>多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li>\n<li><font color=\"red\"> 排他锁【exclusive locks】又称为写锁，简称X锁。</font>排他锁就是不能与其他锁（共享锁、排他锁）并存，获取排他锁的事务是可以对数据行读取和修改。</li>\n</ol>\n<h3 id=\"3-说明\"><a href=\"#3-说明\" class=\"headerlink\" title=\"3. 说明\"></a>3. 说明</h3><p>悲观并发控制实际上是“先取锁再访问”的保守策略。</p>\n<ul>\n<li><strong>处理加锁的机制会让数据库产生额外的开销，增加产生死锁的机会</strong></li>\n<li><strong><em>降低并行性</em></strong>（一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。）</li>\n</ul>\n<h3 id=\"4-实现方式\"><a href=\"#4-实现方式\" class=\"headerlink\" title=\"4. 实现方式\"></a>4. 实现方式</h3><ol>\n<li><p>修改之前，先加上排它锁(exclusive locks)</p>\n</li>\n<li><p>加锁失败，说明该记录正在修改，线程陷入等待或者抛出异常</p>\n</li>\n<li><p>加锁成功，修改，事务结束之后解锁</p>\n<p><img src=\"/2020/10/21/%E5%B9%B6%E5%8F%91/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/1.jpg\"></p>\n</li>\n</ol>\n<p>[^ ]:注：mysql设置非立马提交（set autocommit=0）MySQL InnoDB 默认行级锁。行级锁都是基于索引的，如果一条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住。</p>\n<h2 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h2><h3 id=\"1-乐观锁定义\"><a href=\"#1-乐观锁定义\" class=\"headerlink\" title=\"1. 乐观锁定义\"></a>1. 乐观锁定义</h3><p><strong>乐观锁一般会使用版本号机制或CAS算法实现。</strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量<strong>，像数据库提供的类似于write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p>\n<h3 id=\"2-两种实现方式\"><a href=\"#2-两种实现方式\" class=\"headerlink\" title=\"2. 两种实现方式\"></a>2. 两种实现方式</h3><h4 id=\"2-1-CAS-实现-compare-and-swap-比较与交换\"><a href=\"#2-1-CAS-实现-compare-and-swap-比较与交换\" class=\"headerlink\" title=\"2.1 CAS 实现(compare and swap[比较与交换])\"></a>2.1 <strong>CAS 实现</strong>(compare and swap[比较与交换])</h4><p>Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>\n<p><img src=\"/2020/10/21/%E5%B9%B6%E5%8F%91/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/2.jpg\" alt=\"img\"></p>\n<h4 id=\"2-2-版本号机制\"><a href=\"#2-2-版本号机制\" class=\"headerlink\" title=\"2.2 版本号机制\"></a>2.2 版本号机制</h4><h5 id=\"2-2-1-ABA-问题\"><a href=\"#2-2-1-ABA-问题\" class=\"headerlink\" title=\"2.2.1 ABA 问题\"></a>2.2.1 ABA 问题</h5><p><img src=\"/2020/10/21/%E5%B9%B6%E5%8F%91/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/3.png\"></p>\n<p>如图流程可以看出，当线程一读取变量v=1，这时线程二读取的变量v=1，并且线程二对变量v=1 进行了修改操作。使v=2，之后又使v=1。这时，线程一进行了CAS操作，发现变量v=1,这时线程一也成功了，但是过程是存在ABA问题的。</p>\n<h5 id=\"2-2-2-版本号\"><a href=\"#2-2-2-版本号\" class=\"headerlink\" title=\"2.2.2 版本号\"></a>2.2.2 版本号</h5><p>乐观锁每次操作时都带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。除了 version 以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。</p>\n<h3 id=\"3-CAS与synchronized的使用情景\"><a href=\"#3-CAS与synchronized的使用情景\" class=\"headerlink\" title=\"3. CAS与synchronized的使用情景\"></a>3. <strong>CAS与synchronized的使用情景</strong></h3><blockquote>\n<p><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></p>\n</blockquote>\n<ol>\n<li>对于资源竞争较少（线程冲突较轻）的情况，使用<code>synchronized</code>同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>\n<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>\n</ol>\n<p>补充： Java并发编程这个领域中<code>synchronized</code>关键字一直都是元老级的角色，很久之前很多人都会称它为 <strong>“重量级锁”</strong> 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它<strong>各种优化</strong>之后变得在某些情况下并不是那么重了。<code>synchronized</code>的底层实现主要依靠 <strong>Lock-Free</strong> 的队列，基本思路是 <strong>自旋后阻塞</strong>，<strong>竞争切换后继续竞争锁</strong>，<strong>稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>\n<h3 id=\"4-两者比较\"><a href=\"#4-两者比较\" class=\"headerlink\" title=\"4. 两者比较\"></a>4. 两者比较</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>乐观锁</th>\n<th>悲观锁</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>适用场景</td>\n<td><strong>适用于写比较少的情况下（多读场景）</strong></td>\n<td><strong>多写的场景下用悲观锁就比较合适</strong></td>\n</tr>\n<tr>\n<td>实现</td>\n<td>1. CAS<br> 2. 版本号机制</td>\n<td>1. 传统的关系型数据库的行锁，表锁等，读锁，写锁等<br>2. <a href=\"https://www.jianshu.com/p/c8f997e7f75c\">synchronized</a> 关键字</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>1. ABA问题<br>2. 循环时间长开销大（自旋CAS（也就是不成功就一直循环执行直到成功））<br>3. 只能保证一个共享变量的原子操作</td>\n<td>1.效率低<br>2.容易产生死锁</td>\n</tr>\n</tbody></table>\n<p>- <a href=\"https://www.jianshu.com/p/d2ac26ca6525\">什么是乐观锁，什么是悲观锁</a></p>\n<p>- <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/essential-content-for-interview/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E4%B9%8B%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81?id=_1-%e7%89%88%e6%9c%ac%e5%8f%b7%e6%9c%ba%e5%88%b6\">何谓悲观锁与乐观锁</a></p>\n"},{"title":"oracle 误删数据、表的恢复","date":"2020-10-21T06:16:33.000Z","description":"附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面","_content":"\n<font size=\"4\" color=\"#dd0000\">注意：鉴于oracle的特殊性，表名基本为大写（注意大小写问题）。</font>\n\n## 一、delete 误删数据问题\n\n### 1、根据v$sqlarea进行恢复，把表恢复到删除时间点\n1. 查询sql执行时间\n\n```\nselect SQL_TEXT,LAST_ACTIVE_TIME from v$sqlarea \nwhere LAST_ACTIVE_TIME > to_date('2020-07-09 9:30:27','yyyy-mm-dd hh24:mi:ss')\nand SQL_TEXT like '%表名%';\n```\n\n2. 根据时间进行恢复\n\n```oracle\nINSERT INTO 表名\nselect * from 表名 AS OF TIMESTAMP to_timestamp('2020-07-09 9:32:27','yyyy-mm-dd hh24:mi:ss');\n```\n### 2、根据闪回把表恢复到某个时间点\n\n```oracle\n-- 直接闪回某张表到某个时间点\nflashback table 表名 to timestamp to_date('2020-07-09 09:49:20','yyyy-mm-dd hh24:mi:ss');\n-- 出现异常则先授权，开启行移动功能 \nalter table 表名 enable row movement;\n```\n### 3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）\n```oracle\n-- 查询某个时间点的scn\nselect timestamp_to_scn(to_timestamp('2020-07-09 09:49:20','yyyy-mm-dd hh24:mi:ss')) from dual;\n\n-- 通过闪回把某张表恢复到某个时间点的scn\nflashback table 表名 to scn 161664467;\n```\n## 二、drop 误删表的恢复方法\n### 1、通过回收站恢复\n```oracle\n-- 查询被删除的表\nselect * from recyclebin where original_name like '%表名%'  order by droptime desc;\n-- 恢复被删除的表(如果该表重新被创建，需要恢复到新的表)（如果该表存在多次删除历史，只会恢复最后版本）\nflashback table '需要恢复的表名' to before drop [rename to 新表名]；\n\n-- 通过唯一标识(如果该表重新被创建，需要恢复到新的表)（根据recyclebin 的object_name 作为唯一标识恢复指定时间版本）\nflashback table \"BIN$BuhrIJqTR7qMITOgqKK8qg==$0\" to before drop rename to 新表名;\n```","source":"_posts/数据库操作/oracle/oracle 误删数据、表的恢复.md","raw":"---\ntitle: oracle 误删数据、表的恢复 #文章页面上的显示名称，一般是中文\ndate: 2020-10-21 14:16:33 #文章生成时间，一般不改，当然也可以任意修改\ncategories: oracle #分类\ntags: [运维,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面\n---\n\n<font size=\"4\" color=\"#dd0000\">注意：鉴于oracle的特殊性，表名基本为大写（注意大小写问题）。</font>\n\n## 一、delete 误删数据问题\n\n### 1、根据v$sqlarea进行恢复，把表恢复到删除时间点\n1. 查询sql执行时间\n\n```\nselect SQL_TEXT,LAST_ACTIVE_TIME from v$sqlarea \nwhere LAST_ACTIVE_TIME > to_date('2020-07-09 9:30:27','yyyy-mm-dd hh24:mi:ss')\nand SQL_TEXT like '%表名%';\n```\n\n2. 根据时间进行恢复\n\n```oracle\nINSERT INTO 表名\nselect * from 表名 AS OF TIMESTAMP to_timestamp('2020-07-09 9:32:27','yyyy-mm-dd hh24:mi:ss');\n```\n### 2、根据闪回把表恢复到某个时间点\n\n```oracle\n-- 直接闪回某张表到某个时间点\nflashback table 表名 to timestamp to_date('2020-07-09 09:49:20','yyyy-mm-dd hh24:mi:ss');\n-- 出现异常则先授权，开启行移动功能 \nalter table 表名 enable row movement;\n```\n### 3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）\n```oracle\n-- 查询某个时间点的scn\nselect timestamp_to_scn(to_timestamp('2020-07-09 09:49:20','yyyy-mm-dd hh24:mi:ss')) from dual;\n\n-- 通过闪回把某张表恢复到某个时间点的scn\nflashback table 表名 to scn 161664467;\n```\n## 二、drop 误删表的恢复方法\n### 1、通过回收站恢复\n```oracle\n-- 查询被删除的表\nselect * from recyclebin where original_name like '%表名%'  order by droptime desc;\n-- 恢复被删除的表(如果该表重新被创建，需要恢复到新的表)（如果该表存在多次删除历史，只会恢复最后版本）\nflashback table '需要恢复的表名' to before drop [rename to 新表名]；\n\n-- 通过唯一标识(如果该表重新被创建，需要恢复到新的表)（根据recyclebin 的object_name 作为唯一标识恢复指定时间版本）\nflashback table \"BIN$BuhrIJqTR7qMITOgqKK8qg==$0\" to before drop rename to 新表名;\n```","slug":"数据库操作/oracle/oracle 误删数据、表的恢复","published":1,"updated":"2020-10-21T07:21:40.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgk92amy0004agtk5vescng3","content":"<p><font size=\"4\" color=\"#dd0000\">注意：鉴于oracle的特殊性，表名基本为大写（注意大小写问题）。</font></p>\n<h2 id=\"一、delete-误删数据问题\"><a href=\"#一、delete-误删数据问题\" class=\"headerlink\" title=\"一、delete 误删数据问题\"></a>一、delete 误删数据问题</h2><h3 id=\"1、根据v-sqlarea进行恢复，把表恢复到删除时间点\"><a href=\"#1、根据v-sqlarea进行恢复，把表恢复到删除时间点\" class=\"headerlink\" title=\"1、根据v$sqlarea进行恢复，把表恢复到删除时间点\"></a>1、根据v$sqlarea进行恢复，把表恢复到删除时间点</h3><ol>\n<li>查询sql执行时间</li>\n</ol>\n<pre><code>select SQL_TEXT,LAST_ACTIVE_TIME from v$sqlarea \nwhere LAST_ACTIVE_TIME &gt; to_date(&#39;2020-07-09 9:30:27&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;)\nand SQL_TEXT like &#39;%表名%&#39;;</code></pre>\n<ol start=\"2\">\n<li>根据时间进行恢复</li>\n</ol>\n<pre><code class=\"oracle\">INSERT INTO 表名\nselect * from 表名 AS OF TIMESTAMP to_timestamp(&#39;2020-07-09 9:32:27&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;);</code></pre>\n<h3 id=\"2、根据闪回把表恢复到某个时间点\"><a href=\"#2、根据闪回把表恢复到某个时间点\" class=\"headerlink\" title=\"2、根据闪回把表恢复到某个时间点\"></a>2、根据闪回把表恢复到某个时间点</h3><pre><code class=\"oracle\">-- 直接闪回某张表到某个时间点\nflashback table 表名 to timestamp to_date(&#39;2020-07-09 09:49:20&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;);\n-- 出现异常则先授权，开启行移动功能 \nalter table 表名 enable row movement;</code></pre>\n<h3 id=\"3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）\"><a href=\"#3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）\" class=\"headerlink\" title=\"3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）\"></a>3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）</h3><pre><code class=\"oracle\">-- 查询某个时间点的scn\nselect timestamp_to_scn(to_timestamp(&#39;2020-07-09 09:49:20&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;)) from dual;\n\n-- 通过闪回把某张表恢复到某个时间点的scn\nflashback table 表名 to scn 161664467;</code></pre>\n<h2 id=\"二、drop-误删表的恢复方法\"><a href=\"#二、drop-误删表的恢复方法\" class=\"headerlink\" title=\"二、drop 误删表的恢复方法\"></a>二、drop 误删表的恢复方法</h2><h3 id=\"1、通过回收站恢复\"><a href=\"#1、通过回收站恢复\" class=\"headerlink\" title=\"1、通过回收站恢复\"></a>1、通过回收站恢复</h3><pre><code class=\"oracle\">-- 查询被删除的表\nselect * from recyclebin where original_name like &#39;%表名%&#39;  order by droptime desc;\n-- 恢复被删除的表(如果该表重新被创建，需要恢复到新的表)（如果该表存在多次删除历史，只会恢复最后版本）\nflashback table &#39;需要恢复的表名&#39; to before drop [rename to 新表名]；\n\n-- 通过唯一标识(如果该表重新被创建，需要恢复到新的表)（根据recyclebin 的object_name 作为唯一标识恢复指定时间版本）\nflashback table &quot;BIN$BuhrIJqTR7qMITOgqKK8qg==$0&quot; to before drop rename to 新表名;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><font size=\"4\" color=\"#dd0000\">注意：鉴于oracle的特殊性，表名基本为大写（注意大小写问题）。</font></p>\n<h2 id=\"一、delete-误删数据问题\"><a href=\"#一、delete-误删数据问题\" class=\"headerlink\" title=\"一、delete 误删数据问题\"></a>一、delete 误删数据问题</h2><h3 id=\"1、根据v-sqlarea进行恢复，把表恢复到删除时间点\"><a href=\"#1、根据v-sqlarea进行恢复，把表恢复到删除时间点\" class=\"headerlink\" title=\"1、根据v$sqlarea进行恢复，把表恢复到删除时间点\"></a>1、根据v$sqlarea进行恢复，把表恢复到删除时间点</h3><ol>\n<li>查询sql执行时间</li>\n</ol>\n<pre><code>select SQL_TEXT,LAST_ACTIVE_TIME from v$sqlarea \nwhere LAST_ACTIVE_TIME &gt; to_date(&#39;2020-07-09 9:30:27&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;)\nand SQL_TEXT like &#39;%表名%&#39;;</code></pre>\n<ol start=\"2\">\n<li>根据时间进行恢复</li>\n</ol>\n<pre><code class=\"oracle\">INSERT INTO 表名\nselect * from 表名 AS OF TIMESTAMP to_timestamp(&#39;2020-07-09 9:32:27&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;);</code></pre>\n<h3 id=\"2、根据闪回把表恢复到某个时间点\"><a href=\"#2、根据闪回把表恢复到某个时间点\" class=\"headerlink\" title=\"2、根据闪回把表恢复到某个时间点\"></a>2、根据闪回把表恢复到某个时间点</h3><pre><code class=\"oracle\">-- 直接闪回某张表到某个时间点\nflashback table 表名 to timestamp to_date(&#39;2020-07-09 09:49:20&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;);\n-- 出现异常则先授权，开启行移动功能 \nalter table 表名 enable row movement;</code></pre>\n<h3 id=\"3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）\"><a href=\"#3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）\" class=\"headerlink\" title=\"3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）\"></a>3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）</h3><pre><code class=\"oracle\">-- 查询某个时间点的scn\nselect timestamp_to_scn(to_timestamp(&#39;2020-07-09 09:49:20&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;)) from dual;\n\n-- 通过闪回把某张表恢复到某个时间点的scn\nflashback table 表名 to scn 161664467;</code></pre>\n<h2 id=\"二、drop-误删表的恢复方法\"><a href=\"#二、drop-误删表的恢复方法\" class=\"headerlink\" title=\"二、drop 误删表的恢复方法\"></a>二、drop 误删表的恢复方法</h2><h3 id=\"1、通过回收站恢复\"><a href=\"#1、通过回收站恢复\" class=\"headerlink\" title=\"1、通过回收站恢复\"></a>1、通过回收站恢复</h3><pre><code class=\"oracle\">-- 查询被删除的表\nselect * from recyclebin where original_name like &#39;%表名%&#39;  order by droptime desc;\n-- 恢复被删除的表(如果该表重新被创建，需要恢复到新的表)（如果该表存在多次删除历史，只会恢复最后版本）\nflashback table &#39;需要恢复的表名&#39; to before drop [rename to 新表名]；\n\n-- 通过唯一标识(如果该表重新被创建，需要恢复到新的表)（根据recyclebin 的object_name 作为唯一标识恢复指定时间版本）\nflashback table &quot;BIN$BuhrIJqTR7qMITOgqKK8qg==$0&quot; to before drop rename to 新表名;</code></pre>\n"},{"title":"Comparable与Comparator","date":"2020-10-27T06:16:33.000Z","description":"详细讲解comparable及comparator的使用及用法。","_content":"\n## Comparable\n\n[TOC]\n\n```\nimport java.util.Objects;\n\n/**\n * 实现Comparator接口的类可以方便的排序， 覆写compareTo接口\n * @author zxl\n * @date 2020/10/27 18:00\n */\npublic class Student implements Comparable<Student>{\n\n    /*** 名字 */\n    private String name;\n\n    /*** 年龄 */\n    private int age;\n\n    /*** 分数 */\n    private float score;\n\n    /**\n     * 排序规则：以分数降序排序，若分数一致，则根据年龄升序排序\n     * @param o 比较参数\n     * @return 比较结果 -1大于   0等于   1小于\n     */\n    @Override\n    public int compareTo(Student o) {\n        /*\n         * this.age - o.age 升序\n         * o.score - this.score 降序\n         */\n        return Objects.equals(o.score,this.score) ? this.age - o.age : (int) (o.score - this.score);\n    }\n\n    public Student(String name, int age, float score) {\n        this.name = name;\n        this.age = age;\n        this.score = score;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", score=\" + score +\n                '}';\n    }\n}\n\n\npublic class Comparable01 {\n\n    public static void main(String args[]){\n        Student stu[] = {\n                new Student(\"张三\",20,90.0f),\n                new Student(\"李四\",22,90.0f),\n                new Student(\"王五\",20,99.0f),\n                new Student(\"赵六\",20,70.0f),\n                new Student(\"孙七\",22,100.0f)} ;\n        java.util.Arrays.sort(stu) ;    // 进行排序操作\n        for(int i=0;i<stu.length;i++){    // 循环输出数组中的内容\n            System.out.println(stu[i]) ;\n        }\n    }\n\n}\n\n```\n\n\n\n## Comparator\n\n```\npublic class Student {\n    /*** 名字 */\n    private String name;\n\n    /*** 年龄 */\n    private int age;\n\n    /*** 分数 */\n    private float score;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public float getScore() {\n        return score;\n    }\n\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    public Student(String name, int age, float score) {\n        this.name = name;\n        this.age = age;\n        this.score = score;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", score=\" + score +\n                '}';\n    }\n\n}\n\npublic class ComparatorTest {\n\n    public static void main(String[] args) {\n        Student stu[] = {\n                new Student(\"张三\",20,90.0f),\n                new Student(\"李四\",22,90.0f),\n                new Student(\"王五\",20,99.0f),\n                new Student(\"赵六\",20,70.0f),\n                new Student(\"孙七\",22,100.0f)} ;\n\n        // 排序方法一\n        java.util.Arrays.sort(stu, new Comparator<Student>() {\n            @Override\n            public int compare(Student o1, Student o2) {\n                /*\n                 * o1.param - o2.param 升序\n                 * o2.param - o1.param 降序\n                 */\n                return Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore());\n            }\n        }) ;\n\n        // 排序方法二 lambda方法\n        java.util.Arrays.sort(stu, (o1, o2) -> Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore())) ;\n\n\n        for(int i=0;i<stu.length;i++){    // 循环输出数组中的内容\n            System.out.println(stu[i]) ;\n        }\n    }\n\n    /**\n     * 排序方法三：该方法需新建一个java类使用，\n     * java.util.Arrays.sort(stu, new MyComparator());\n     */\n    class MyComparator implements Comparator<Student>{\n        @Override\n        public int compare(Student o1, Student o2) {\n            return Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore());\n        }\n    }\n\n}\n```\n\n## 两者比较\n\n<table>\n\t<tr>\n\t\t<th>属性</th>\n\t    <th>Comparable</th>\n\t    <th>Comparator</th>\n\t</tr >\n\t<tr>\n\t\t<td>适用场景</td>\n\t\t<td>集合内部定义实现</td>\n\t\t<td>集合外部实现排序</td>\n\t</tr>\n    <tr>\n\t\t<td>区别</td>\n\t\t<td>1. java.lang 包<br/>\n        \t2. 方法：int compareTo(Object o)\n        </td>\n\t\t<td>1. java.util 包<br/>\n        \t2. 方法：int compare(T o1, To2)\n        </td>\n\t</tr>\n    <tr>\n\t\t<td>原理</td>\n\t\t<td colspan=\"2\">基于红黑二叉树原理实现的</td>\n\t</tr>\n</table>\n\n| 返回值 | 含义 |\n| ------ | ---- |\n| -1     | 大于 |\n| 0      | 等于 |\n| 1      | 小于 |\n\n## 参考\n\n\\- [java中compareable和comparator的区别，比较器实现的原理！](https://blog.csdn.net/wilson27/article/details/90339765)","source":"_posts/java学习/工具包学习/Comparable与Comparator.md","raw":"---\ntitle: Comparable与Comparator #文章页面上的显示名称，一般是中文\ndate: 2020-10-27 14:16:33 #文章生成时间，一般不改，当然也可以任意修改\ncategories: JAVA #分类\ntags: [Comparable,Comparator,排序] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: 详细讲解comparable及comparator的使用及用法。\n---\n\n## Comparable\n\n[TOC]\n\n```\nimport java.util.Objects;\n\n/**\n * 实现Comparator接口的类可以方便的排序， 覆写compareTo接口\n * @author zxl\n * @date 2020/10/27 18:00\n */\npublic class Student implements Comparable<Student>{\n\n    /*** 名字 */\n    private String name;\n\n    /*** 年龄 */\n    private int age;\n\n    /*** 分数 */\n    private float score;\n\n    /**\n     * 排序规则：以分数降序排序，若分数一致，则根据年龄升序排序\n     * @param o 比较参数\n     * @return 比较结果 -1大于   0等于   1小于\n     */\n    @Override\n    public int compareTo(Student o) {\n        /*\n         * this.age - o.age 升序\n         * o.score - this.score 降序\n         */\n        return Objects.equals(o.score,this.score) ? this.age - o.age : (int) (o.score - this.score);\n    }\n\n    public Student(String name, int age, float score) {\n        this.name = name;\n        this.age = age;\n        this.score = score;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", score=\" + score +\n                '}';\n    }\n}\n\n\npublic class Comparable01 {\n\n    public static void main(String args[]){\n        Student stu[] = {\n                new Student(\"张三\",20,90.0f),\n                new Student(\"李四\",22,90.0f),\n                new Student(\"王五\",20,99.0f),\n                new Student(\"赵六\",20,70.0f),\n                new Student(\"孙七\",22,100.0f)} ;\n        java.util.Arrays.sort(stu) ;    // 进行排序操作\n        for(int i=0;i<stu.length;i++){    // 循环输出数组中的内容\n            System.out.println(stu[i]) ;\n        }\n    }\n\n}\n\n```\n\n\n\n## Comparator\n\n```\npublic class Student {\n    /*** 名字 */\n    private String name;\n\n    /*** 年龄 */\n    private int age;\n\n    /*** 分数 */\n    private float score;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public float getScore() {\n        return score;\n    }\n\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    public Student(String name, int age, float score) {\n        this.name = name;\n        this.age = age;\n        this.score = score;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", score=\" + score +\n                '}';\n    }\n\n}\n\npublic class ComparatorTest {\n\n    public static void main(String[] args) {\n        Student stu[] = {\n                new Student(\"张三\",20,90.0f),\n                new Student(\"李四\",22,90.0f),\n                new Student(\"王五\",20,99.0f),\n                new Student(\"赵六\",20,70.0f),\n                new Student(\"孙七\",22,100.0f)} ;\n\n        // 排序方法一\n        java.util.Arrays.sort(stu, new Comparator<Student>() {\n            @Override\n            public int compare(Student o1, Student o2) {\n                /*\n                 * o1.param - o2.param 升序\n                 * o2.param - o1.param 降序\n                 */\n                return Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore());\n            }\n        }) ;\n\n        // 排序方法二 lambda方法\n        java.util.Arrays.sort(stu, (o1, o2) -> Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore())) ;\n\n\n        for(int i=0;i<stu.length;i++){    // 循环输出数组中的内容\n            System.out.println(stu[i]) ;\n        }\n    }\n\n    /**\n     * 排序方法三：该方法需新建一个java类使用，\n     * java.util.Arrays.sort(stu, new MyComparator());\n     */\n    class MyComparator implements Comparator<Student>{\n        @Override\n        public int compare(Student o1, Student o2) {\n            return Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore());\n        }\n    }\n\n}\n```\n\n## 两者比较\n\n<table>\n\t<tr>\n\t\t<th>属性</th>\n\t    <th>Comparable</th>\n\t    <th>Comparator</th>\n\t</tr >\n\t<tr>\n\t\t<td>适用场景</td>\n\t\t<td>集合内部定义实现</td>\n\t\t<td>集合外部实现排序</td>\n\t</tr>\n    <tr>\n\t\t<td>区别</td>\n\t\t<td>1. java.lang 包<br/>\n        \t2. 方法：int compareTo(Object o)\n        </td>\n\t\t<td>1. java.util 包<br/>\n        \t2. 方法：int compare(T o1, To2)\n        </td>\n\t</tr>\n    <tr>\n\t\t<td>原理</td>\n\t\t<td colspan=\"2\">基于红黑二叉树原理实现的</td>\n\t</tr>\n</table>\n\n| 返回值 | 含义 |\n| ------ | ---- |\n| -1     | 大于 |\n| 0      | 等于 |\n| 1      | 小于 |\n\n## 参考\n\n\\- [java中compareable和comparator的区别，比较器实现的原理！](https://blog.csdn.net/wilson27/article/details/90339765)","slug":"java学习/工具包学习/Comparable与Comparator","published":1,"updated":"2020-10-28T00:59:06.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgsoyer10000i8tk8v1j60s9","content":"<h2 id=\"Comparable\"><a href=\"#Comparable\" class=\"headerlink\" title=\"Comparable\"></a>Comparable</h2><p>[TOC]</p>\n<pre><code>import java.util.Objects;\n\n/**\n * 实现Comparator接口的类可以方便的排序， 覆写compareTo接口\n * @author zxl\n * @date 2020/10/27 18:00\n */\npublic class Student implements Comparable&lt;Student&gt;&#123;\n\n    /*** 名字 */\n    private String name;\n\n    /*** 年龄 */\n    private int age;\n\n    /*** 分数 */\n    private float score;\n\n    /**\n     * 排序规则：以分数降序排序，若分数一致，则根据年龄升序排序\n     * @param o 比较参数\n     * @return 比较结果 -1大于   0等于   1小于\n     */\n    @Override\n    public int compareTo(Student o) &#123;\n        /*\n         * this.age - o.age 升序\n         * o.score - this.score 降序\n         */\n        return Objects.equals(o.score,this.score) ? this.age - o.age : (int) (o.score - this.score);\n    &#125;\n\n    public Student(String name, int age, float score) &#123;\n        this.name = name;\n        this.age = age;\n        this.score = score;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &quot;, score=&quot; + score +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\n\npublic class Comparable01 &#123;\n\n    public static void main(String args[])&#123;\n        Student stu[] = &#123;\n                new Student(&quot;张三&quot;,20,90.0f),\n                new Student(&quot;李四&quot;,22,90.0f),\n                new Student(&quot;王五&quot;,20,99.0f),\n                new Student(&quot;赵六&quot;,20,70.0f),\n                new Student(&quot;孙七&quot;,22,100.0f)&#125; ;\n        java.util.Arrays.sort(stu) ;    // 进行排序操作\n        for(int i=0;i&lt;stu.length;i++)&#123;    // 循环输出数组中的内容\n            System.out.println(stu[i]) ;\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<h2 id=\"Comparator\"><a href=\"#Comparator\" class=\"headerlink\" title=\"Comparator\"></a>Comparator</h2><pre><code>public class Student &#123;\n    /*** 名字 */\n    private String name;\n\n    /*** 年龄 */\n    private int age;\n\n    /*** 分数 */\n    private float score;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public float getScore() &#123;\n        return score;\n    &#125;\n\n    public void setScore(float score) &#123;\n        this.score = score;\n    &#125;\n\n    public Student(String name, int age, float score) &#123;\n        this.name = name;\n        this.age = age;\n        this.score = score;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &quot;, score=&quot; + score +\n                &#39;&#125;&#39;;\n    &#125;\n\n&#125;\n\npublic class ComparatorTest &#123;\n\n    public static void main(String[] args) &#123;\n        Student stu[] = &#123;\n                new Student(&quot;张三&quot;,20,90.0f),\n                new Student(&quot;李四&quot;,22,90.0f),\n                new Student(&quot;王五&quot;,20,99.0f),\n                new Student(&quot;赵六&quot;,20,70.0f),\n                new Student(&quot;孙七&quot;,22,100.0f)&#125; ;\n\n        // 排序方法一\n        java.util.Arrays.sort(stu, new Comparator&lt;Student&gt;() &#123;\n            @Override\n            public int compare(Student o1, Student o2) &#123;\n                /*\n                 * o1.param - o2.param 升序\n                 * o2.param - o1.param 降序\n                 */\n                return Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore());\n            &#125;\n        &#125;) ;\n\n        // 排序方法二 lambda方法\n        java.util.Arrays.sort(stu, (o1, o2) -&gt; Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore())) ;\n\n\n        for(int i=0;i&lt;stu.length;i++)&#123;    // 循环输出数组中的内容\n            System.out.println(stu[i]) ;\n        &#125;\n    &#125;\n\n    /**\n     * 排序方法三：该方法需新建一个java类使用，\n     * java.util.Arrays.sort(stu, new MyComparator());\n     */\n    class MyComparator implements Comparator&lt;Student&gt;&#123;\n        @Override\n        public int compare(Student o1, Student o2) &#123;\n            return Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore());\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n<h2 id=\"两者比较\"><a href=\"#两者比较\" class=\"headerlink\" title=\"两者比较\"></a>两者比较</h2><table>\n    <tr>\n        <th>属性</th>\n        <th>Comparable</th>\n        <th>Comparator</th>\n    </tr>\n    <tr>\n        <td>适用场景</td>\n        <td>集合内部定义实现</td>\n        <td>集合外部实现排序</td>\n    </tr>\n    <tr>\n        <td>区别</td>\n        <td>1. java.lang 包<br>\n            2. 方法：int compareTo(Object o)\n        </td>\n        <td>1. java.util 包<br>\n            2. 方法：int compare(T o1, To2)\n        </td>\n    </tr>\n    <tr>\n        <td>原理</td>\n        <td colspan=\"2\">基于红黑二叉树原理实现的</td>\n    </tr>\n</table>\n\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-1</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>0</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>1</td>\n<td>小于</td>\n</tr>\n</tbody></table>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>- <a href=\"https://blog.csdn.net/wilson27/article/details/90339765\">java中compareable和comparator的区别，比较器实现的原理！</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Comparable\"><a href=\"#Comparable\" class=\"headerlink\" title=\"Comparable\"></a>Comparable</h2><p>[TOC]</p>\n<pre><code>import java.util.Objects;\n\n/**\n * 实现Comparator接口的类可以方便的排序， 覆写compareTo接口\n * @author zxl\n * @date 2020/10/27 18:00\n */\npublic class Student implements Comparable&lt;Student&gt;&#123;\n\n    /*** 名字 */\n    private String name;\n\n    /*** 年龄 */\n    private int age;\n\n    /*** 分数 */\n    private float score;\n\n    /**\n     * 排序规则：以分数降序排序，若分数一致，则根据年龄升序排序\n     * @param o 比较参数\n     * @return 比较结果 -1大于   0等于   1小于\n     */\n    @Override\n    public int compareTo(Student o) &#123;\n        /*\n         * this.age - o.age 升序\n         * o.score - this.score 降序\n         */\n        return Objects.equals(o.score,this.score) ? this.age - o.age : (int) (o.score - this.score);\n    &#125;\n\n    public Student(String name, int age, float score) &#123;\n        this.name = name;\n        this.age = age;\n        this.score = score;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &quot;, score=&quot; + score +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\n\npublic class Comparable01 &#123;\n\n    public static void main(String args[])&#123;\n        Student stu[] = &#123;\n                new Student(&quot;张三&quot;,20,90.0f),\n                new Student(&quot;李四&quot;,22,90.0f),\n                new Student(&quot;王五&quot;,20,99.0f),\n                new Student(&quot;赵六&quot;,20,70.0f),\n                new Student(&quot;孙七&quot;,22,100.0f)&#125; ;\n        java.util.Arrays.sort(stu) ;    // 进行排序操作\n        for(int i=0;i&lt;stu.length;i++)&#123;    // 循环输出数组中的内容\n            System.out.println(stu[i]) ;\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<h2 id=\"Comparator\"><a href=\"#Comparator\" class=\"headerlink\" title=\"Comparator\"></a>Comparator</h2><pre><code>public class Student &#123;\n    /*** 名字 */\n    private String name;\n\n    /*** 年龄 */\n    private int age;\n\n    /*** 分数 */\n    private float score;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public float getScore() &#123;\n        return score;\n    &#125;\n\n    public void setScore(float score) &#123;\n        this.score = score;\n    &#125;\n\n    public Student(String name, int age, float score) &#123;\n        this.name = name;\n        this.age = age;\n        this.score = score;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &quot;, score=&quot; + score +\n                &#39;&#125;&#39;;\n    &#125;\n\n&#125;\n\npublic class ComparatorTest &#123;\n\n    public static void main(String[] args) &#123;\n        Student stu[] = &#123;\n                new Student(&quot;张三&quot;,20,90.0f),\n                new Student(&quot;李四&quot;,22,90.0f),\n                new Student(&quot;王五&quot;,20,99.0f),\n                new Student(&quot;赵六&quot;,20,70.0f),\n                new Student(&quot;孙七&quot;,22,100.0f)&#125; ;\n\n        // 排序方法一\n        java.util.Arrays.sort(stu, new Comparator&lt;Student&gt;() &#123;\n            @Override\n            public int compare(Student o1, Student o2) &#123;\n                /*\n                 * o1.param - o2.param 升序\n                 * o2.param - o1.param 降序\n                 */\n                return Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore());\n            &#125;\n        &#125;) ;\n\n        // 排序方法二 lambda方法\n        java.util.Arrays.sort(stu, (o1, o2) -&gt; Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore())) ;\n\n\n        for(int i=0;i&lt;stu.length;i++)&#123;    // 循环输出数组中的内容\n            System.out.println(stu[i]) ;\n        &#125;\n    &#125;\n\n    /**\n     * 排序方法三：该方法需新建一个java类使用，\n     * java.util.Arrays.sort(stu, new MyComparator());\n     */\n    class MyComparator implements Comparator&lt;Student&gt;&#123;\n        @Override\n        public int compare(Student o1, Student o2) &#123;\n            return Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore());\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n<h2 id=\"两者比较\"><a href=\"#两者比较\" class=\"headerlink\" title=\"两者比较\"></a>两者比较</h2><table>\n    <tr>\n        <th>属性</th>\n        <th>Comparable</th>\n        <th>Comparator</th>\n    </tr>\n    <tr>\n        <td>适用场景</td>\n        <td>集合内部定义实现</td>\n        <td>集合外部实现排序</td>\n    </tr>\n    <tr>\n        <td>区别</td>\n        <td>1. java.lang 包<br>\n            2. 方法：int compareTo(Object o)\n        </td>\n        <td>1. java.util 包<br>\n            2. 方法：int compare(T o1, To2)\n        </td>\n    </tr>\n    <tr>\n        <td>原理</td>\n        <td colspan=\"2\">基于红黑二叉树原理实现的</td>\n    </tr>\n</table>\n\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-1</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>0</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>1</td>\n<td>小于</td>\n</tr>\n</tbody></table>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>- <a href=\"https://blog.csdn.net/wilson27/article/details/90339765\">java中compareable和comparator的区别，比较器实现的原理！</a></p>\n"},{"title":"hexo搭建静态博客","date":"2020-10-28T06:16:33.000Z","description":"详细讲解hexo的搭建过程及基础用法。","_content":"\n\n\n\n\n\n\n\\- [j](https://blog.csdn.net/wilson27/article/details/90339765)","source":"_posts/工具安装使用/hexo/hexo搭建静态博客.md","raw":"---\ntitle: hexo搭建静态博客 \ndate: 2020-10-28 14:16:33 \ncategories: 工具 \ntags: [hexo,博客] \ndescription: 详细讲解hexo的搭建过程及基础用法。\n---\n\n\n\n\n\n\n\n\\- [j](https://blog.csdn.net/wilson27/article/details/90339765)","slug":"工具安装使用/hexo/hexo搭建静态博客","published":1,"updated":"2020-10-28T02:35:18.168Z","_id":"ckgspvfc10000c0tkgfz1box0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>- <a href=\"https://blog.csdn.net/wilson27/article/details/90339765\">j</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>- <a href=\"https://blog.csdn.net/wilson27/article/details/90339765\">j</a></p>\n"},{"title":"Java 并发基础常见面试题总结","date":"2020-11-03T06:16:33.000Z","description":"常见并发基础面试题总结","_content":"\n# 并发基础\n\n[TOC]\n\n## 1. 什么是线程和进程？\n\n### 1.1 进程\n\n&emsp;进程是程序的一次执行过程，**是操作系统分配资源的最小单位**，因此进程是动态的。\n\n![进程展示图](Java并发基础常见面试题总结/进程.png)\n\n### 1.2 线程\n\n&emsp;线程是程序执行的最小单位，一个进程在其执行的过程中可以产生多个线程。每个线程有自己的<span style=\"font-size:20px;color:red;weight:bold;\">**程序计数器、虚拟机栈、本地方法栈**</span>，多个线程共享进程的<span style=\"font-size:20px;color:red;weight:bold;\">**堆**、**方法区资源**</span>。\n\n![img](Java并发基础常见面试题总结/JVM运行时数据区域.png)\n\n### 1.3 区别\n\n|            | 进程                         | 线程                                                         |\n| ---------- | ---------------------------- | :----------------------------------------------------------- |\n| 概念       | 是操作系统分配资源的最小单位 | 线程是程序执行的最小单位                                     |\n| 组成       | 由一个或多个线程组成         | 仅是线程下的一条执行线路                                     |\n| 资源       | 进程之间相互独立             | 同一进程下，各个线程之前共享程序的内存空间（代码段、数据集、堆等）及一些进程级的资源。执行开销小，不利于资源管理及保护 |\n| 调度与切换 | 慢                           | 线程上下文切换快                                             |\n\n## 2. 线程详解\n\n### 2.1 程序计数器为什么是私有的\n\n&emsp;程序计数器作用：\n\n1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、异常处理\n2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了\n\n&emsp;所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。\n\n### 2.2 虚拟机栈和本地方法栈\n\n![img](Java并发基础常见面试题总结/aa18972bd40735fa901e88768e0966b60d2408f4.jpeg)\n\n#### 2.2.1 虚拟机栈\n\n##### 2.2.1.1 虚拟机栈讲解\n\n　**虚拟机栈是用于描述java方法执行的内存模型。**\n\n&emsp;每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“局部变量表、操作数栈、动态链接、方法出口”几个部分。我们常说的“堆内存、栈内存”中的**“栈内存”指的便是虚拟机栈**，确切地说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。\n\n&emsp;方法调用时，创建栈帧，并压入虚拟机栈；方法执行完毕，栈帧出栈并被销毁，如下图所示：\n\n![img](Java并发基础常见面试题总结/1266638-20180711104523327-1846448145.png)\n\n##### 2.2.1.2 虚拟机栈特点\n\n&emsp;虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈。\n\n##### 2.2.1.3 虚拟机栈的StackOverflowError\n\n&emsp;**单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）。**\n\n&emsp;JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用，代码见下：\n\n```\npublic class JavaVMStackSOF {\n\n    private void add(int c){\n        add(c++);\n    }\n\n    public static void main(String[] args) {\n        try {\n            new JavaVMStackSOF().add(0);\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n}\n```\n\n&emsp;在不断的循环调用，最终超出虚拟机允许的深度，抛出栈溢出错误。\n\n![image-20201104094518290](Java并发基础常见面试题总结/image-20201104094518290.png)\n\n##### 2.2.1.4 虚拟机栈的OutOfMemoryError\n\n&emsp;**OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。**\n\n&emsp;JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常（建议不要尝试，容易把电脑跑蹦）\n\n```\npublic class JavaVMStackOOM {\n\n    public static void main(String[] args) {\n        while(true){\n            new Thread(() -> {\n                while (true){\n\n                }\n            }).start();\n        }\n    }\n}\n```\n\n#### 2.2.2 本地方法栈\n\n&emsp;和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务（例如Thread.start0()）。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。由于native方法不是用Java实现的，而是由C语言实现的，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。\n\n<p style=\"color:red\">&emsp;为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p>\n\n### 2.3 堆\n\n#### 2.3.1 什么是堆\n\n&emsp;堆是用于存放对象的内存区域。因此，他是垃圾收集器（GC）管理的主要目标。\n\n#### 2.3.2 特点\n\n1. 堆在逻辑上划分为**新生代**和**老年代**。由于JAVA中的对象大部分是朝生夕灭，还有一小部分能够长期的驻留在内存中，为了对这两种对象进行最有效的回收，将堆划分为新生代和老年代，并且执行不同的回收策略。不同的垃圾收集器对这2个逻辑区域的回收机制不尽相同，\n2. 堆占用的内存并不要求物理连续，只需要逻辑连续即可。\n3. 堆一般实现成可扩展内存大小，使用“-Xms”与“-Xmx”控制堆的最小与最大内存，扩展动作交由虚拟机执行。但由于该行为比较消耗性能，因此一般将堆的最大最小内存设为相等。\n4. 堆是所有线程共享的内存区域，因此每个线程都可以拿到堆上的同一个对象。\n5. 堆的生命周期是随着虚拟机的启动而创建。\n\n#### 2.3.3 堆异常\n\n&emsp;当堆无法分配对象内存且无法再扩展时，会抛出OutOfMemoryError异常。\n\n```\npublic class HeapOOM {\n\n    static class OOMObject {\n    }\n\n    public static void main(String[] args) {\n        List<OOMObject> list = new ArrayList<>();\n        //不断创建新对象，使得Heap溢出\n        while (true) {\n            list.add(new OOMObject());\n        }\n    }\n\n}\n```\n\n&emsp;述代码中对象不断的被创建而不进行引用释放，导致GC无法回收堆内存，最终OutOfMemoryError，错误信息：\n\n```\njava.lang.OutOfMemoryError: Java heap space\n```\n\n### 2.4 方法区\n\n#### 2.4.1 方法区定义\n\n&emsp;方法区，也称非堆（Non-Heap），是一个被线程共享的内存区域。其中主要存储加载的类字节码、class/method/field等元数据对象、static-final常量、static变量、jit编译器编译后的代码等数据。\n\n&emsp;如果系统定义太多的类，导致方法区溢出。虚拟机同样会抛出内存溢出的错误。方法区可以理解为永久区。\n\n### 2.5 上下文切换\n\n> 当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。\n\n&emsp;多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。\n\n&emsp;上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。\n\n&emsp;Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。\n\n### 2.6 死锁\n\n#### 2.6.1 死锁的定义\n\n&emsp;多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。\n\n![线程死锁示意图 ](Java并发基础常见面试题总结/2019-4死锁1.png)\n\n#### 2.6.2 死锁的条件\n\n1. 互斥条件：该资源任意一个时刻只由一个线程占用。\n2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\n3. 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。\n4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。\n\n#### 2.6.3 如何避免死锁\n\n&emsp;为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。\n\n1. **破坏互斥条件** ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。\n2. **破坏请求与保持条件** ：一次性申请所有的资源。\n3. **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\n4. **破坏循环等待条件** ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\n\n## 3 角料\n\n### 3.1  start() 和run() 方法\n\n&emsp;**调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。**\n\n### 3.2 wait()方法和sleep()方法\n\n|      | **sleep 方法**                                               | **wait 方法**                            |\n| ---- | ------------------------------------------------------------ | ---------------------------------------- |\n| 1    | **没有释放锁**                                               | **释放了锁**                             |\n| 2    | 用于暂停执行                                                 | 用于线程间交互/通信                      |\n| 3    | 被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法 | sleep() 方法执行完成后，线程会自动苏醒。 |\n| 4    | 两者都可以暂停线程的执行。                                   |                                          |\n\n\n\n## 参考链接\n\n\\- [Java 并发基础常见面试题总结](https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=java-%e5%b9%b6%e5%8f%91%e5%9f%ba%e7%a1%80%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98%e6%80%bb%e7%bb%93)\n\n\\- [02-JVM内存模型：虚拟机栈与本地方法栈](https://www.cnblogs.com/manayi/p/9293302.html)\n\n\\- [03-JVM内存模型：堆与方法区](https://www.cnblogs.com/manayi/p/9651500.html)\n\n","source":"_posts/并发/Java并发基础常见面试题总结.md","raw":"---\ntitle: Java 并发基础常见面试题总结 \ndate: 2020-11-03 14:16:33 \ncategories: 并发 #分类\ntags: [锁机制,并发,死锁] \ndescription: 常见并发基础面试题总结\n---\n\n# 并发基础\n\n[TOC]\n\n## 1. 什么是线程和进程？\n\n### 1.1 进程\n\n&emsp;进程是程序的一次执行过程，**是操作系统分配资源的最小单位**，因此进程是动态的。\n\n![进程展示图](Java并发基础常见面试题总结/进程.png)\n\n### 1.2 线程\n\n&emsp;线程是程序执行的最小单位，一个进程在其执行的过程中可以产生多个线程。每个线程有自己的<span style=\"font-size:20px;color:red;weight:bold;\">**程序计数器、虚拟机栈、本地方法栈**</span>，多个线程共享进程的<span style=\"font-size:20px;color:red;weight:bold;\">**堆**、**方法区资源**</span>。\n\n![img](Java并发基础常见面试题总结/JVM运行时数据区域.png)\n\n### 1.3 区别\n\n|            | 进程                         | 线程                                                         |\n| ---------- | ---------------------------- | :----------------------------------------------------------- |\n| 概念       | 是操作系统分配资源的最小单位 | 线程是程序执行的最小单位                                     |\n| 组成       | 由一个或多个线程组成         | 仅是线程下的一条执行线路                                     |\n| 资源       | 进程之间相互独立             | 同一进程下，各个线程之前共享程序的内存空间（代码段、数据集、堆等）及一些进程级的资源。执行开销小，不利于资源管理及保护 |\n| 调度与切换 | 慢                           | 线程上下文切换快                                             |\n\n## 2. 线程详解\n\n### 2.1 程序计数器为什么是私有的\n\n&emsp;程序计数器作用：\n\n1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、异常处理\n2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了\n\n&emsp;所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。\n\n### 2.2 虚拟机栈和本地方法栈\n\n![img](Java并发基础常见面试题总结/aa18972bd40735fa901e88768e0966b60d2408f4.jpeg)\n\n#### 2.2.1 虚拟机栈\n\n##### 2.2.1.1 虚拟机栈讲解\n\n　**虚拟机栈是用于描述java方法执行的内存模型。**\n\n&emsp;每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“局部变量表、操作数栈、动态链接、方法出口”几个部分。我们常说的“堆内存、栈内存”中的**“栈内存”指的便是虚拟机栈**，确切地说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。\n\n&emsp;方法调用时，创建栈帧，并压入虚拟机栈；方法执行完毕，栈帧出栈并被销毁，如下图所示：\n\n![img](Java并发基础常见面试题总结/1266638-20180711104523327-1846448145.png)\n\n##### 2.2.1.2 虚拟机栈特点\n\n&emsp;虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈。\n\n##### 2.2.1.3 虚拟机栈的StackOverflowError\n\n&emsp;**单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）。**\n\n&emsp;JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用，代码见下：\n\n```\npublic class JavaVMStackSOF {\n\n    private void add(int c){\n        add(c++);\n    }\n\n    public static void main(String[] args) {\n        try {\n            new JavaVMStackSOF().add(0);\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n}\n```\n\n&emsp;在不断的循环调用，最终超出虚拟机允许的深度，抛出栈溢出错误。\n\n![image-20201104094518290](Java并发基础常见面试题总结/image-20201104094518290.png)\n\n##### 2.2.1.4 虚拟机栈的OutOfMemoryError\n\n&emsp;**OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。**\n\n&emsp;JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常（建议不要尝试，容易把电脑跑蹦）\n\n```\npublic class JavaVMStackOOM {\n\n    public static void main(String[] args) {\n        while(true){\n            new Thread(() -> {\n                while (true){\n\n                }\n            }).start();\n        }\n    }\n}\n```\n\n#### 2.2.2 本地方法栈\n\n&emsp;和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务（例如Thread.start0()）。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。由于native方法不是用Java实现的，而是由C语言实现的，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。\n\n<p style=\"color:red\">&emsp;为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p>\n\n### 2.3 堆\n\n#### 2.3.1 什么是堆\n\n&emsp;堆是用于存放对象的内存区域。因此，他是垃圾收集器（GC）管理的主要目标。\n\n#### 2.3.2 特点\n\n1. 堆在逻辑上划分为**新生代**和**老年代**。由于JAVA中的对象大部分是朝生夕灭，还有一小部分能够长期的驻留在内存中，为了对这两种对象进行最有效的回收，将堆划分为新生代和老年代，并且执行不同的回收策略。不同的垃圾收集器对这2个逻辑区域的回收机制不尽相同，\n2. 堆占用的内存并不要求物理连续，只需要逻辑连续即可。\n3. 堆一般实现成可扩展内存大小，使用“-Xms”与“-Xmx”控制堆的最小与最大内存，扩展动作交由虚拟机执行。但由于该行为比较消耗性能，因此一般将堆的最大最小内存设为相等。\n4. 堆是所有线程共享的内存区域，因此每个线程都可以拿到堆上的同一个对象。\n5. 堆的生命周期是随着虚拟机的启动而创建。\n\n#### 2.3.3 堆异常\n\n&emsp;当堆无法分配对象内存且无法再扩展时，会抛出OutOfMemoryError异常。\n\n```\npublic class HeapOOM {\n\n    static class OOMObject {\n    }\n\n    public static void main(String[] args) {\n        List<OOMObject> list = new ArrayList<>();\n        //不断创建新对象，使得Heap溢出\n        while (true) {\n            list.add(new OOMObject());\n        }\n    }\n\n}\n```\n\n&emsp;述代码中对象不断的被创建而不进行引用释放，导致GC无法回收堆内存，最终OutOfMemoryError，错误信息：\n\n```\njava.lang.OutOfMemoryError: Java heap space\n```\n\n### 2.4 方法区\n\n#### 2.4.1 方法区定义\n\n&emsp;方法区，也称非堆（Non-Heap），是一个被线程共享的内存区域。其中主要存储加载的类字节码、class/method/field等元数据对象、static-final常量、static变量、jit编译器编译后的代码等数据。\n\n&emsp;如果系统定义太多的类，导致方法区溢出。虚拟机同样会抛出内存溢出的错误。方法区可以理解为永久区。\n\n### 2.5 上下文切换\n\n> 当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。\n\n&emsp;多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。\n\n&emsp;上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。\n\n&emsp;Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。\n\n### 2.6 死锁\n\n#### 2.6.1 死锁的定义\n\n&emsp;多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。\n\n![线程死锁示意图 ](Java并发基础常见面试题总结/2019-4死锁1.png)\n\n#### 2.6.2 死锁的条件\n\n1. 互斥条件：该资源任意一个时刻只由一个线程占用。\n2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\n3. 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。\n4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。\n\n#### 2.6.3 如何避免死锁\n\n&emsp;为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。\n\n1. **破坏互斥条件** ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。\n2. **破坏请求与保持条件** ：一次性申请所有的资源。\n3. **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\n4. **破坏循环等待条件** ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\n\n## 3 角料\n\n### 3.1  start() 和run() 方法\n\n&emsp;**调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。**\n\n### 3.2 wait()方法和sleep()方法\n\n|      | **sleep 方法**                                               | **wait 方法**                            |\n| ---- | ------------------------------------------------------------ | ---------------------------------------- |\n| 1    | **没有释放锁**                                               | **释放了锁**                             |\n| 2    | 用于暂停执行                                                 | 用于线程间交互/通信                      |\n| 3    | 被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法 | sleep() 方法执行完成后，线程会自动苏醒。 |\n| 4    | 两者都可以暂停线程的执行。                                   |                                          |\n\n\n\n## 参考链接\n\n\\- [Java 并发基础常见面试题总结](https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=java-%e5%b9%b6%e5%8f%91%e5%9f%ba%e7%a1%80%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98%e6%80%bb%e7%bb%93)\n\n\\- [02-JVM内存模型：虚拟机栈与本地方法栈](https://www.cnblogs.com/manayi/p/9293302.html)\n\n\\- [03-JVM内存模型：堆与方法区](https://www.cnblogs.com/manayi/p/9651500.html)\n\n","slug":"并发/Java并发基础常见面试题总结","published":1,"updated":"2020-11-23T02:19:14.453Z","_id":"ckh2sbz180000actk8oc87qaf","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"并发基础\"><a href=\"#并发基础\" class=\"headerlink\" title=\"并发基础\"></a>并发基础</h1><p>[TOC]</p>\n<h2 id=\"1-什么是线程和进程？\"><a href=\"#1-什么是线程和进程？\" class=\"headerlink\" title=\"1. 什么是线程和进程？\"></a>1. 什么是线程和进程？</h2><h3 id=\"1-1-进程\"><a href=\"#1-1-进程\" class=\"headerlink\" title=\"1.1 进程\"></a>1.1 进程</h3><p>&emsp;进程是程序的一次执行过程，<strong>是操作系统分配资源的最小单位</strong>，因此进程是动态的。</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/%E8%BF%9B%E7%A8%8B.png\" alt=\"进程展示图\"></p>\n<h3 id=\"1-2-线程\"><a href=\"#1-2-线程\" class=\"headerlink\" title=\"1.2 线程\"></a>1.2 线程</h3><p>&emsp;线程是程序执行的最小单位，一个进程在其执行的过程中可以产生多个线程。每个线程有自己的<span style=\"font-size:20px;color:red;weight:bold;\"><strong>程序计数器、虚拟机栈、本地方法栈</strong></span>，多个线程共享进程的<span style=\"font-size:20px;color:red;weight:bold;\"><strong>堆</strong>、<strong>方法区资源</strong></span>。</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png\" alt=\"img\"></p>\n<h3 id=\"1-3-区别\"><a href=\"#1-3-区别\" class=\"headerlink\" title=\"1.3 区别\"></a>1.3 区别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>进程</th>\n<th align=\"left\">线程</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>概念</td>\n<td>是操作系统分配资源的最小单位</td>\n<td align=\"left\">线程是程序执行的最小单位</td>\n</tr>\n<tr>\n<td>组成</td>\n<td>由一个或多个线程组成</td>\n<td align=\"left\">仅是线程下的一条执行线路</td>\n</tr>\n<tr>\n<td>资源</td>\n<td>进程之间相互独立</td>\n<td align=\"left\">同一进程下，各个线程之前共享程序的内存空间（代码段、数据集、堆等）及一些进程级的资源。执行开销小，不利于资源管理及保护</td>\n</tr>\n<tr>\n<td>调度与切换</td>\n<td>慢</td>\n<td align=\"left\">线程上下文切换快</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-线程详解\"><a href=\"#2-线程详解\" class=\"headerlink\" title=\"2. 线程详解\"></a>2. 线程详解</h2><h3 id=\"2-1-程序计数器为什么是私有的\"><a href=\"#2-1-程序计数器为什么是私有的\" class=\"headerlink\" title=\"2.1 程序计数器为什么是私有的\"></a>2.1 程序计数器为什么是私有的</h3><p>&emsp;程序计数器作用：</p>\n<ol>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、异常处理</li>\n<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了</li>\n</ol>\n<p>&emsp;所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>\n<h3 id=\"2-2-虚拟机栈和本地方法栈\"><a href=\"#2-2-虚拟机栈和本地方法栈\" class=\"headerlink\" title=\"2.2 虚拟机栈和本地方法栈\"></a>2.2 虚拟机栈和本地方法栈</h3><p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/aa18972bd40735fa901e88768e0966b60d2408f4.jpeg\" alt=\"img\"></p>\n<h4 id=\"2-2-1-虚拟机栈\"><a href=\"#2-2-1-虚拟机栈\" class=\"headerlink\" title=\"2.2.1 虚拟机栈\"></a>2.2.1 虚拟机栈</h4><h5 id=\"2-2-1-1-虚拟机栈讲解\"><a href=\"#2-2-1-1-虚拟机栈讲解\" class=\"headerlink\" title=\"2.2.1.1 虚拟机栈讲解\"></a>2.2.1.1 虚拟机栈讲解</h5><p>　<strong>虚拟机栈是用于描述java方法执行的内存模型。</strong></p>\n<p>&emsp;每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“局部变量表、操作数栈、动态链接、方法出口”几个部分。我们常说的“堆内存、栈内存”中的<strong>“栈内存”指的便是虚拟机栈</strong>，确切地说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。</p>\n<p>&emsp;方法调用时，创建栈帧，并压入虚拟机栈；方法执行完毕，栈帧出栈并被销毁，如下图所示：</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/1266638-20180711104523327-1846448145.png\" alt=\"img\"></p>\n<h5 id=\"2-2-1-2-虚拟机栈特点\"><a href=\"#2-2-1-2-虚拟机栈特点\" class=\"headerlink\" title=\"2.2.1.2 虚拟机栈特点\"></a>2.2.1.2 虚拟机栈特点</h5><p>&emsp;虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈。</p>\n<h5 id=\"2-2-1-3-虚拟机栈的StackOverflowError\"><a href=\"#2-2-1-3-虚拟机栈的StackOverflowError\" class=\"headerlink\" title=\"2.2.1.3 虚拟机栈的StackOverflowError\"></a>2.2.1.3 虚拟机栈的StackOverflowError</h5><p>&emsp;<strong>单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）。</strong></p>\n<p>&emsp;JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用，代码见下：</p>\n<pre><code>public class JavaVMStackSOF &#123;\n\n    private void add(int c)&#123;\n        add(c++);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        try &#123;\n            new JavaVMStackSOF().add(0);\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n<p>&emsp;在不断的循环调用，最终超出虚拟机允许的深度，抛出栈溢出错误。</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20201104094518290.png\" alt=\"image-20201104094518290\"></p>\n<h5 id=\"2-2-1-4-虚拟机栈的OutOfMemoryError\"><a href=\"#2-2-1-4-虚拟机栈的OutOfMemoryError\" class=\"headerlink\" title=\"2.2.1.4 虚拟机栈的OutOfMemoryError\"></a>2.2.1.4 虚拟机栈的OutOfMemoryError</h5><p>&emsp;<strong>OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。</strong></p>\n<p>&emsp;JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常（建议不要尝试，容易把电脑跑蹦）</p>\n<pre><code>public class JavaVMStackOOM &#123;\n\n    public static void main(String[] args) &#123;\n        while(true)&#123;\n            new Thread(() -&gt; &#123;\n                while (true)&#123;\n\n                &#125;\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;</code></pre>\n<h4 id=\"2-2-2-本地方法栈\"><a href=\"#2-2-2-本地方法栈\" class=\"headerlink\" title=\"2.2.2 本地方法栈\"></a>2.2.2 本地方法栈</h4><p>&emsp;和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务（例如Thread.start0()）。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。由于native方法不是用Java实现的，而是由C语言实现的，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。</p>\n<p style=\"color:red\">&emsp;为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p>\n\n<h3 id=\"2-3-堆\"><a href=\"#2-3-堆\" class=\"headerlink\" title=\"2.3 堆\"></a>2.3 堆</h3><h4 id=\"2-3-1-什么是堆\"><a href=\"#2-3-1-什么是堆\" class=\"headerlink\" title=\"2.3.1 什么是堆\"></a>2.3.1 什么是堆</h4><p>&emsp;堆是用于存放对象的内存区域。因此，他是垃圾收集器（GC）管理的主要目标。</p>\n<h4 id=\"2-3-2-特点\"><a href=\"#2-3-2-特点\" class=\"headerlink\" title=\"2.3.2 特点\"></a>2.3.2 特点</h4><ol>\n<li>堆在逻辑上划分为<strong>新生代</strong>和<strong>老年代</strong>。由于JAVA中的对象大部分是朝生夕灭，还有一小部分能够长期的驻留在内存中，为了对这两种对象进行最有效的回收，将堆划分为新生代和老年代，并且执行不同的回收策略。不同的垃圾收集器对这2个逻辑区域的回收机制不尽相同，</li>\n<li>堆占用的内存并不要求物理连续，只需要逻辑连续即可。</li>\n<li>堆一般实现成可扩展内存大小，使用“-Xms”与“-Xmx”控制堆的最小与最大内存，扩展动作交由虚拟机执行。但由于该行为比较消耗性能，因此一般将堆的最大最小内存设为相等。</li>\n<li>堆是所有线程共享的内存区域，因此每个线程都可以拿到堆上的同一个对象。</li>\n<li>堆的生命周期是随着虚拟机的启动而创建。</li>\n</ol>\n<h4 id=\"2-3-3-堆异常\"><a href=\"#2-3-3-堆异常\" class=\"headerlink\" title=\"2.3.3 堆异常\"></a>2.3.3 堆异常</h4><p>&emsp;当堆无法分配对象内存且无法再扩展时，会抛出OutOfMemoryError异常。</p>\n<pre><code>public class HeapOOM &#123;\n\n    static class OOMObject &#123;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;();\n        //不断创建新对象，使得Heap溢出\n        while (true) &#123;\n            list.add(new OOMObject());\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n<p>&emsp;述代码中对象不断的被创建而不进行引用释放，导致GC无法回收堆内存，最终OutOfMemoryError，错误信息：</p>\n<pre><code>java.lang.OutOfMemoryError: Java heap space</code></pre>\n<h3 id=\"2-4-方法区\"><a href=\"#2-4-方法区\" class=\"headerlink\" title=\"2.4 方法区\"></a>2.4 方法区</h3><h4 id=\"2-4-1-方法区定义\"><a href=\"#2-4-1-方法区定义\" class=\"headerlink\" title=\"2.4.1 方法区定义\"></a>2.4.1 方法区定义</h4><p>&emsp;方法区，也称非堆（Non-Heap），是一个被线程共享的内存区域。其中主要存储加载的类字节码、class/method/field等元数据对象、static-final常量、static变量、jit编译器编译后的代码等数据。</p>\n<p>&emsp;如果系统定义太多的类，导致方法区溢出。虚拟机同样会抛出内存溢出的错误。方法区可以理解为永久区。</p>\n<h3 id=\"2-5-上下文切换\"><a href=\"#2-5-上下文切换\" class=\"headerlink\" title=\"2.5 上下文切换\"></a>2.5 上下文切换</h3><blockquote>\n<p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>\n</blockquote>\n<p>&emsp;多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>\n<p>&emsp;上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>\n<p>&emsp;Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>\n<h3 id=\"2-6-死锁\"><a href=\"#2-6-死锁\" class=\"headerlink\" title=\"2.6 死锁\"></a>2.6 死锁</h3><h4 id=\"2-6-1-死锁的定义\"><a href=\"#2-6-1-死锁的定义\" class=\"headerlink\" title=\"2.6.1 死锁的定义\"></a>2.6.1 死锁的定义</h4><p>&emsp;多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/2019-4%E6%AD%BB%E9%94%811.png\" alt=\"线程死锁示意图 \"></p>\n<h4 id=\"2-6-2-死锁的条件\"><a href=\"#2-6-2-死锁的条件\" class=\"headerlink\" title=\"2.6.2 死锁的条件\"></a>2.6.2 死锁的条件</h4><ol>\n<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>\n<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>\n</ol>\n<h4 id=\"2-6-3-如何避免死锁\"><a href=\"#2-6-3-如何避免死锁\" class=\"headerlink\" title=\"2.6.3 如何避免死锁\"></a>2.6.3 如何避免死锁</h4><p>&emsp;为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>\n<ol>\n<li><strong>破坏互斥条件</strong> ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li>\n<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>\n<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>\n<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>\n</ol>\n<h2 id=\"3-角料\"><a href=\"#3-角料\" class=\"headerlink\" title=\"3 角料\"></a>3 角料</h2><h3 id=\"3-1-start-和run-方法\"><a href=\"#3-1-start-和run-方法\" class=\"headerlink\" title=\"3.1  start() 和run() 方法\"></a>3.1  start() 和run() 方法</h3><p>&emsp;<strong>调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p>\n<h3 id=\"3-2-wait-方法和sleep-方法\"><a href=\"#3-2-wait-方法和sleep-方法\" class=\"headerlink\" title=\"3.2 wait()方法和sleep()方法\"></a>3.2 wait()方法和sleep()方法</h3><table>\n<thead>\n<tr>\n<th></th>\n<th><strong>sleep 方法</strong></th>\n<th><strong>wait 方法</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td><strong>没有释放锁</strong></td>\n<td><strong>释放了锁</strong></td>\n</tr>\n<tr>\n<td>2</td>\n<td>用于暂停执行</td>\n<td>用于线程间交互/通信</td>\n</tr>\n<tr>\n<td>3</td>\n<td>被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法</td>\n<td>sleep() 方法执行完成后，线程会自动苏醒。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>两者都可以暂停线程的执行。</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p>- <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=java-%e5%b9%b6%e5%8f%91%e5%9f%ba%e7%a1%80%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98%e6%80%bb%e7%bb%93\">Java 并发基础常见面试题总结</a></p>\n<p>- <a href=\"https://www.cnblogs.com/manayi/p/9293302.html\">02-JVM内存模型：虚拟机栈与本地方法栈</a></p>\n<p>- <a href=\"https://www.cnblogs.com/manayi/p/9651500.html\">03-JVM内存模型：堆与方法区</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"并发基础\"><a href=\"#并发基础\" class=\"headerlink\" title=\"并发基础\"></a>并发基础</h1><p>[TOC]</p>\n<h2 id=\"1-什么是线程和进程？\"><a href=\"#1-什么是线程和进程？\" class=\"headerlink\" title=\"1. 什么是线程和进程？\"></a>1. 什么是线程和进程？</h2><h3 id=\"1-1-进程\"><a href=\"#1-1-进程\" class=\"headerlink\" title=\"1.1 进程\"></a>1.1 进程</h3><p>&emsp;进程是程序的一次执行过程，<strong>是操作系统分配资源的最小单位</strong>，因此进程是动态的。</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/%E8%BF%9B%E7%A8%8B.png\" alt=\"进程展示图\"></p>\n<h3 id=\"1-2-线程\"><a href=\"#1-2-线程\" class=\"headerlink\" title=\"1.2 线程\"></a>1.2 线程</h3><p>&emsp;线程是程序执行的最小单位，一个进程在其执行的过程中可以产生多个线程。每个线程有自己的<span style=\"font-size:20px;color:red;weight:bold;\"><strong>程序计数器、虚拟机栈、本地方法栈</strong></span>，多个线程共享进程的<span style=\"font-size:20px;color:red;weight:bold;\"><strong>堆</strong>、<strong>方法区资源</strong></span>。</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png\" alt=\"img\"></p>\n<h3 id=\"1-3-区别\"><a href=\"#1-3-区别\" class=\"headerlink\" title=\"1.3 区别\"></a>1.3 区别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>进程</th>\n<th align=\"left\">线程</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>概念</td>\n<td>是操作系统分配资源的最小单位</td>\n<td align=\"left\">线程是程序执行的最小单位</td>\n</tr>\n<tr>\n<td>组成</td>\n<td>由一个或多个线程组成</td>\n<td align=\"left\">仅是线程下的一条执行线路</td>\n</tr>\n<tr>\n<td>资源</td>\n<td>进程之间相互独立</td>\n<td align=\"left\">同一进程下，各个线程之前共享程序的内存空间（代码段、数据集、堆等）及一些进程级的资源。执行开销小，不利于资源管理及保护</td>\n</tr>\n<tr>\n<td>调度与切换</td>\n<td>慢</td>\n<td align=\"left\">线程上下文切换快</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-线程详解\"><a href=\"#2-线程详解\" class=\"headerlink\" title=\"2. 线程详解\"></a>2. 线程详解</h2><h3 id=\"2-1-程序计数器为什么是私有的\"><a href=\"#2-1-程序计数器为什么是私有的\" class=\"headerlink\" title=\"2.1 程序计数器为什么是私有的\"></a>2.1 程序计数器为什么是私有的</h3><p>&emsp;程序计数器作用：</p>\n<ol>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、异常处理</li>\n<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了</li>\n</ol>\n<p>&emsp;所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>\n<h3 id=\"2-2-虚拟机栈和本地方法栈\"><a href=\"#2-2-虚拟机栈和本地方法栈\" class=\"headerlink\" title=\"2.2 虚拟机栈和本地方法栈\"></a>2.2 虚拟机栈和本地方法栈</h3><p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/aa18972bd40735fa901e88768e0966b60d2408f4.jpeg\" alt=\"img\"></p>\n<h4 id=\"2-2-1-虚拟机栈\"><a href=\"#2-2-1-虚拟机栈\" class=\"headerlink\" title=\"2.2.1 虚拟机栈\"></a>2.2.1 虚拟机栈</h4><h5 id=\"2-2-1-1-虚拟机栈讲解\"><a href=\"#2-2-1-1-虚拟机栈讲解\" class=\"headerlink\" title=\"2.2.1.1 虚拟机栈讲解\"></a>2.2.1.1 虚拟机栈讲解</h5><p>　<strong>虚拟机栈是用于描述java方法执行的内存模型。</strong></p>\n<p>&emsp;每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“局部变量表、操作数栈、动态链接、方法出口”几个部分。我们常说的“堆内存、栈内存”中的<strong>“栈内存”指的便是虚拟机栈</strong>，确切地说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。</p>\n<p>&emsp;方法调用时，创建栈帧，并压入虚拟机栈；方法执行完毕，栈帧出栈并被销毁，如下图所示：</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/1266638-20180711104523327-1846448145.png\" alt=\"img\"></p>\n<h5 id=\"2-2-1-2-虚拟机栈特点\"><a href=\"#2-2-1-2-虚拟机栈特点\" class=\"headerlink\" title=\"2.2.1.2 虚拟机栈特点\"></a>2.2.1.2 虚拟机栈特点</h5><p>&emsp;虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈。</p>\n<h5 id=\"2-2-1-3-虚拟机栈的StackOverflowError\"><a href=\"#2-2-1-3-虚拟机栈的StackOverflowError\" class=\"headerlink\" title=\"2.2.1.3 虚拟机栈的StackOverflowError\"></a>2.2.1.3 虚拟机栈的StackOverflowError</h5><p>&emsp;<strong>单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）。</strong></p>\n<p>&emsp;JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用，代码见下：</p>\n<pre><code>public class JavaVMStackSOF &#123;\n\n    private void add(int c)&#123;\n        add(c++);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        try &#123;\n            new JavaVMStackSOF().add(0);\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n<p>&emsp;在不断的循环调用，最终超出虚拟机允许的深度，抛出栈溢出错误。</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20201104094518290.png\" alt=\"image-20201104094518290\"></p>\n<h5 id=\"2-2-1-4-虚拟机栈的OutOfMemoryError\"><a href=\"#2-2-1-4-虚拟机栈的OutOfMemoryError\" class=\"headerlink\" title=\"2.2.1.4 虚拟机栈的OutOfMemoryError\"></a>2.2.1.4 虚拟机栈的OutOfMemoryError</h5><p>&emsp;<strong>OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。</strong></p>\n<p>&emsp;JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常（建议不要尝试，容易把电脑跑蹦）</p>\n<pre><code>public class JavaVMStackOOM &#123;\n\n    public static void main(String[] args) &#123;\n        while(true)&#123;\n            new Thread(() -&gt; &#123;\n                while (true)&#123;\n\n                &#125;\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;</code></pre>\n<h4 id=\"2-2-2-本地方法栈\"><a href=\"#2-2-2-本地方法栈\" class=\"headerlink\" title=\"2.2.2 本地方法栈\"></a>2.2.2 本地方法栈</h4><p>&emsp;和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务（例如Thread.start0()）。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。由于native方法不是用Java实现的，而是由C语言实现的，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。</p>\n<p style=\"color:red\">&emsp;为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p>\n\n<h3 id=\"2-3-堆\"><a href=\"#2-3-堆\" class=\"headerlink\" title=\"2.3 堆\"></a>2.3 堆</h3><h4 id=\"2-3-1-什么是堆\"><a href=\"#2-3-1-什么是堆\" class=\"headerlink\" title=\"2.3.1 什么是堆\"></a>2.3.1 什么是堆</h4><p>&emsp;堆是用于存放对象的内存区域。因此，他是垃圾收集器（GC）管理的主要目标。</p>\n<h4 id=\"2-3-2-特点\"><a href=\"#2-3-2-特点\" class=\"headerlink\" title=\"2.3.2 特点\"></a>2.3.2 特点</h4><ol>\n<li>堆在逻辑上划分为<strong>新生代</strong>和<strong>老年代</strong>。由于JAVA中的对象大部分是朝生夕灭，还有一小部分能够长期的驻留在内存中，为了对这两种对象进行最有效的回收，将堆划分为新生代和老年代，并且执行不同的回收策略。不同的垃圾收集器对这2个逻辑区域的回收机制不尽相同，</li>\n<li>堆占用的内存并不要求物理连续，只需要逻辑连续即可。</li>\n<li>堆一般实现成可扩展内存大小，使用“-Xms”与“-Xmx”控制堆的最小与最大内存，扩展动作交由虚拟机执行。但由于该行为比较消耗性能，因此一般将堆的最大最小内存设为相等。</li>\n<li>堆是所有线程共享的内存区域，因此每个线程都可以拿到堆上的同一个对象。</li>\n<li>堆的生命周期是随着虚拟机的启动而创建。</li>\n</ol>\n<h4 id=\"2-3-3-堆异常\"><a href=\"#2-3-3-堆异常\" class=\"headerlink\" title=\"2.3.3 堆异常\"></a>2.3.3 堆异常</h4><p>&emsp;当堆无法分配对象内存且无法再扩展时，会抛出OutOfMemoryError异常。</p>\n<pre><code>public class HeapOOM &#123;\n\n    static class OOMObject &#123;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;();\n        //不断创建新对象，使得Heap溢出\n        while (true) &#123;\n            list.add(new OOMObject());\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n<p>&emsp;述代码中对象不断的被创建而不进行引用释放，导致GC无法回收堆内存，最终OutOfMemoryError，错误信息：</p>\n<pre><code>java.lang.OutOfMemoryError: Java heap space</code></pre>\n<h3 id=\"2-4-方法区\"><a href=\"#2-4-方法区\" class=\"headerlink\" title=\"2.4 方法区\"></a>2.4 方法区</h3><h4 id=\"2-4-1-方法区定义\"><a href=\"#2-4-1-方法区定义\" class=\"headerlink\" title=\"2.4.1 方法区定义\"></a>2.4.1 方法区定义</h4><p>&emsp;方法区，也称非堆（Non-Heap），是一个被线程共享的内存区域。其中主要存储加载的类字节码、class/method/field等元数据对象、static-final常量、static变量、jit编译器编译后的代码等数据。</p>\n<p>&emsp;如果系统定义太多的类，导致方法区溢出。虚拟机同样会抛出内存溢出的错误。方法区可以理解为永久区。</p>\n<h3 id=\"2-5-上下文切换\"><a href=\"#2-5-上下文切换\" class=\"headerlink\" title=\"2.5 上下文切换\"></a>2.5 上下文切换</h3><blockquote>\n<p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>\n</blockquote>\n<p>&emsp;多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>\n<p>&emsp;上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>\n<p>&emsp;Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>\n<h3 id=\"2-6-死锁\"><a href=\"#2-6-死锁\" class=\"headerlink\" title=\"2.6 死锁\"></a>2.6 死锁</h3><h4 id=\"2-6-1-死锁的定义\"><a href=\"#2-6-1-死锁的定义\" class=\"headerlink\" title=\"2.6.1 死锁的定义\"></a>2.6.1 死锁的定义</h4><p>&emsp;多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/2019-4%E6%AD%BB%E9%94%811.png\" alt=\"线程死锁示意图 \"></p>\n<h4 id=\"2-6-2-死锁的条件\"><a href=\"#2-6-2-死锁的条件\" class=\"headerlink\" title=\"2.6.2 死锁的条件\"></a>2.6.2 死锁的条件</h4><ol>\n<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>\n<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>\n</ol>\n<h4 id=\"2-6-3-如何避免死锁\"><a href=\"#2-6-3-如何避免死锁\" class=\"headerlink\" title=\"2.6.3 如何避免死锁\"></a>2.6.3 如何避免死锁</h4><p>&emsp;为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>\n<ol>\n<li><strong>破坏互斥条件</strong> ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li>\n<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>\n<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>\n<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>\n</ol>\n<h2 id=\"3-角料\"><a href=\"#3-角料\" class=\"headerlink\" title=\"3 角料\"></a>3 角料</h2><h3 id=\"3-1-start-和run-方法\"><a href=\"#3-1-start-和run-方法\" class=\"headerlink\" title=\"3.1  start() 和run() 方法\"></a>3.1  start() 和run() 方法</h3><p>&emsp;<strong>调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p>\n<h3 id=\"3-2-wait-方法和sleep-方法\"><a href=\"#3-2-wait-方法和sleep-方法\" class=\"headerlink\" title=\"3.2 wait()方法和sleep()方法\"></a>3.2 wait()方法和sleep()方法</h3><table>\n<thead>\n<tr>\n<th></th>\n<th><strong>sleep 方法</strong></th>\n<th><strong>wait 方法</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td><strong>没有释放锁</strong></td>\n<td><strong>释放了锁</strong></td>\n</tr>\n<tr>\n<td>2</td>\n<td>用于暂停执行</td>\n<td>用于线程间交互/通信</td>\n</tr>\n<tr>\n<td>3</td>\n<td>被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法</td>\n<td>sleep() 方法执行完成后，线程会自动苏醒。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>两者都可以暂停线程的执行。</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p>- <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=java-%e5%b9%b6%e5%8f%91%e5%9f%ba%e7%a1%80%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98%e6%80%bb%e7%bb%93\">Java 并发基础常见面试题总结</a></p>\n<p>- <a href=\"https://www.cnblogs.com/manayi/p/9293302.html\">02-JVM内存模型：虚拟机栈与本地方法栈</a></p>\n<p>- <a href=\"https://www.cnblogs.com/manayi/p/9651500.html\">03-JVM内存模型：堆与方法区</a></p>\n"},{"title":"oracle基础语法","date":"2020-12-16T16:00:00.000Z","description":"oracle基础的语法及函数使用","_content":"\n## 1. oracle基础语法\n\n### 1.decode\n\ndecode (条件，值1，返回值1，值2，返回值2...，缺省值)\n\n### 2.trunc\n\n#### （1）截断数字\n\nTRUNC（n1,n2），n1表示被截断的数字，n2表示要截断到那一位。n2可以是负数，表示截断小数点前。注意，TRUNC截断不是四舍五入。\n\n```sql\nselect trunc(123.458,0) from dual; --123\nselect trunc(123.458,1) from dual; --123.4\nselect trunc(123.458,-1) from dual; --120\n```\n\n#### （2）截断日期\n\n```sql\nselect trunc(sysdate, 'mm') from dual; --2013-01-01 返回当月第一天.\n```\n\n| 值       | 含义                     |\n| -------- | ------------------------ |\n| mm       | 当月第一天               |\n| yy、yyyy | 返回当年第一天           |\n| dd       | 当前年月日               |\n| d        | 当前星期的第一天(星期天) |\n| hh       | 当前时间，精确到小时     |\n| mi       | 当前时间，精确到分       |\n\n### 3.add_months\n\nadd_months(times,num)：times是时间格式的日期，num为之后几个月，可为负数\n\n### 4. extract\n\n用法：从一个date或者interval类型中截取到特定的部分\n\n语法：\n\nextract ({ year | month | day | hour | minute | second | 某一时区 }\nfrom { date类型值 | interval类型值} )\n\n```sql\nselect extract (year from sysdate) year from dual\n```\n\n### 5. listagg\n\n用法：多行合并成一行\n\n语法：listagg('字段','分隔符') within group(order by 3)\n\n### 6. pivot\n\n用法：多行转多列\n\n语法：\n\n```sql\npivot (聚合函数(列名) [as 别名1] for 列名 in (列值 as 别名2,...));\n```\n\n注意：如果使用[as 别名1]，字段名为 **别名1_别名2**。","source":"_posts/数据库操作/oracle/oracle基础语法.md","raw":"---\ntitle: oracle基础语法\ndate: 2020-12-17 #文章生成时间，一般不改，当然也可以任意修改\ncategories: oracle #分类\ntags: [sql,oracle,函数] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: oracle基础的语法及函数使用\n---\n\n## 1. oracle基础语法\n\n### 1.decode\n\ndecode (条件，值1，返回值1，值2，返回值2...，缺省值)\n\n### 2.trunc\n\n#### （1）截断数字\n\nTRUNC（n1,n2），n1表示被截断的数字，n2表示要截断到那一位。n2可以是负数，表示截断小数点前。注意，TRUNC截断不是四舍五入。\n\n```sql\nselect trunc(123.458,0) from dual; --123\nselect trunc(123.458,1) from dual; --123.4\nselect trunc(123.458,-1) from dual; --120\n```\n\n#### （2）截断日期\n\n```sql\nselect trunc(sysdate, 'mm') from dual; --2013-01-01 返回当月第一天.\n```\n\n| 值       | 含义                     |\n| -------- | ------------------------ |\n| mm       | 当月第一天               |\n| yy、yyyy | 返回当年第一天           |\n| dd       | 当前年月日               |\n| d        | 当前星期的第一天(星期天) |\n| hh       | 当前时间，精确到小时     |\n| mi       | 当前时间，精确到分       |\n\n### 3.add_months\n\nadd_months(times,num)：times是时间格式的日期，num为之后几个月，可为负数\n\n### 4. extract\n\n用法：从一个date或者interval类型中截取到特定的部分\n\n语法：\n\nextract ({ year | month | day | hour | minute | second | 某一时区 }\nfrom { date类型值 | interval类型值} )\n\n```sql\nselect extract (year from sysdate) year from dual\n```\n\n### 5. listagg\n\n用法：多行合并成一行\n\n语法：listagg('字段','分隔符') within group(order by 3)\n\n### 6. pivot\n\n用法：多行转多列\n\n语法：\n\n```sql\npivot (聚合函数(列名) [as 别名1] for 列名 in (列值 as 别名2,...));\n```\n\n注意：如果使用[as 别名1]，字段名为 **别名1_别名2**。","slug":"数据库操作/oracle/oracle基础语法","published":1,"updated":"2020-12-18T01:46:39.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklujq23m00003gtk8r611y3b","content":"<h2 id=\"1-oracle基础语法\"><a href=\"#1-oracle基础语法\" class=\"headerlink\" title=\"1. oracle基础语法\"></a>1. oracle基础语法</h2><h3 id=\"1-decode\"><a href=\"#1-decode\" class=\"headerlink\" title=\"1.decode\"></a>1.decode</h3><p>decode (条件，值1，返回值1，值2，返回值2…，缺省值)</p>\n<h3 id=\"2-trunc\"><a href=\"#2-trunc\" class=\"headerlink\" title=\"2.trunc\"></a>2.trunc</h3><h4 id=\"（1）截断数字\"><a href=\"#（1）截断数字\" class=\"headerlink\" title=\"（1）截断数字\"></a>（1）截断数字</h4><p>TRUNC（n1,n2），n1表示被截断的数字，n2表示要截断到那一位。n2可以是负数，表示截断小数点前。注意，TRUNC截断不是四舍五入。</p>\n<pre><code class=\"sql\">select trunc(123.458,0) from dual; --123\nselect trunc(123.458,1) from dual; --123.4\nselect trunc(123.458,-1) from dual; --120</code></pre>\n<h4 id=\"（2）截断日期\"><a href=\"#（2）截断日期\" class=\"headerlink\" title=\"（2）截断日期\"></a>（2）截断日期</h4><pre><code class=\"sql\">select trunc(sysdate, &#39;mm&#39;) from dual; --2013-01-01 返回当月第一天.</code></pre>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mm</td>\n<td>当月第一天</td>\n</tr>\n<tr>\n<td>yy、yyyy</td>\n<td>返回当年第一天</td>\n</tr>\n<tr>\n<td>dd</td>\n<td>当前年月日</td>\n</tr>\n<tr>\n<td>d</td>\n<td>当前星期的第一天(星期天)</td>\n</tr>\n<tr>\n<td>hh</td>\n<td>当前时间，精确到小时</td>\n</tr>\n<tr>\n<td>mi</td>\n<td>当前时间，精确到分</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-add-months\"><a href=\"#3-add-months\" class=\"headerlink\" title=\"3.add_months\"></a>3.add_months</h3><p>add_months(times,num)：times是时间格式的日期，num为之后几个月，可为负数</p>\n<h3 id=\"4-extract\"><a href=\"#4-extract\" class=\"headerlink\" title=\"4. extract\"></a>4. extract</h3><p>用法：从一个date或者interval类型中截取到特定的部分</p>\n<p>语法：</p>\n<p>extract ({ year | month | day | hour | minute | second | 某一时区 }<br>from { date类型值 | interval类型值} )</p>\n<pre><code class=\"sql\">select extract (year from sysdate) year from dual</code></pre>\n<h3 id=\"5-listagg\"><a href=\"#5-listagg\" class=\"headerlink\" title=\"5. listagg\"></a>5. listagg</h3><p>用法：多行合并成一行</p>\n<p>语法：listagg(‘字段’,’分隔符’) within group(order by 3)</p>\n<h3 id=\"6-pivot\"><a href=\"#6-pivot\" class=\"headerlink\" title=\"6. pivot\"></a>6. pivot</h3><p>用法：多行转多列</p>\n<p>语法：</p>\n<pre><code class=\"sql\">pivot (聚合函数(列名) [as 别名1] for 列名 in (列值 as 别名2,...));</code></pre>\n<p>注意：如果使用[as 别名1]，字段名为 <strong>别名1_别名2</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-oracle基础语法\"><a href=\"#1-oracle基础语法\" class=\"headerlink\" title=\"1. oracle基础语法\"></a>1. oracle基础语法</h2><h3 id=\"1-decode\"><a href=\"#1-decode\" class=\"headerlink\" title=\"1.decode\"></a>1.decode</h3><p>decode (条件，值1，返回值1，值2，返回值2…，缺省值)</p>\n<h3 id=\"2-trunc\"><a href=\"#2-trunc\" class=\"headerlink\" title=\"2.trunc\"></a>2.trunc</h3><h4 id=\"（1）截断数字\"><a href=\"#（1）截断数字\" class=\"headerlink\" title=\"（1）截断数字\"></a>（1）截断数字</h4><p>TRUNC（n1,n2），n1表示被截断的数字，n2表示要截断到那一位。n2可以是负数，表示截断小数点前。注意，TRUNC截断不是四舍五入。</p>\n<pre><code class=\"sql\">select trunc(123.458,0) from dual; --123\nselect trunc(123.458,1) from dual; --123.4\nselect trunc(123.458,-1) from dual; --120</code></pre>\n<h4 id=\"（2）截断日期\"><a href=\"#（2）截断日期\" class=\"headerlink\" title=\"（2）截断日期\"></a>（2）截断日期</h4><pre><code class=\"sql\">select trunc(sysdate, &#39;mm&#39;) from dual; --2013-01-01 返回当月第一天.</code></pre>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mm</td>\n<td>当月第一天</td>\n</tr>\n<tr>\n<td>yy、yyyy</td>\n<td>返回当年第一天</td>\n</tr>\n<tr>\n<td>dd</td>\n<td>当前年月日</td>\n</tr>\n<tr>\n<td>d</td>\n<td>当前星期的第一天(星期天)</td>\n</tr>\n<tr>\n<td>hh</td>\n<td>当前时间，精确到小时</td>\n</tr>\n<tr>\n<td>mi</td>\n<td>当前时间，精确到分</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-add-months\"><a href=\"#3-add-months\" class=\"headerlink\" title=\"3.add_months\"></a>3.add_months</h3><p>add_months(times,num)：times是时间格式的日期，num为之后几个月，可为负数</p>\n<h3 id=\"4-extract\"><a href=\"#4-extract\" class=\"headerlink\" title=\"4. extract\"></a>4. extract</h3><p>用法：从一个date或者interval类型中截取到特定的部分</p>\n<p>语法：</p>\n<p>extract ({ year | month | day | hour | minute | second | 某一时区 }<br>from { date类型值 | interval类型值} )</p>\n<pre><code class=\"sql\">select extract (year from sysdate) year from dual</code></pre>\n<h3 id=\"5-listagg\"><a href=\"#5-listagg\" class=\"headerlink\" title=\"5. listagg\"></a>5. listagg</h3><p>用法：多行合并成一行</p>\n<p>语法：listagg(‘字段’,’分隔符’) within group(order by 3)</p>\n<h3 id=\"6-pivot\"><a href=\"#6-pivot\" class=\"headerlink\" title=\"6. pivot\"></a>6. pivot</h3><p>用法：多行转多列</p>\n<p>语法：</p>\n<pre><code class=\"sql\">pivot (聚合函数(列名) [as 别名1] for 列名 in (列值 as 别名2,...));</code></pre>\n<p>注意：如果使用[as 别名1]，字段名为 <strong>别名1_别名2</strong>。</p>\n"},{"title":"证书转换","date":"2020-10-28T06:16:33.000Z","description":"详细讲解pfx、cer证书关系间相互转换。","_content":"\n安装好OpenSSL，然后到bin目录下，执行以下命令即可完成转换：\n\nopenssl pkcs12 -nodes -nokeys -in 1.pfx -passin pass:证书密码 -out 1.cer\n\n如无需加密pem中私钥，可以添加选项-nodes；\n\n\\1. 点击1.cer，安装cer证书\n\n2.从pfx提取密钥信息，并转换为key格式（pfx使用pkcs12模式补足）\n\n  （1）提取密钥对\n\n​    openssl pkcs12 -in 1.pfx -nocerts -nodes -out 1.key\n\n​    //如果pfx证书已加密，会提示输入密码。如果cer证书没有安装，则密码没法验证\n\n  （2）从密钥对提取私钥\n\n​    openssl rsa -in  1.key -out 1_pri.key\n\n  （3）从密钥对提取公钥\n\n​    openssl rsa -in 1.key -pubout -out 1_pub.key\n\n  （4）因为RSA算法使用的是pkcs8模式补足，需要对提取的私钥进一步处理\n\n​    openssl pkcs8 -topk8 -inform PEM -in 1_pri.key -outform PEM -nocrypt\n\n​     复制窗口中生成的密钥，保存为1_pri_pkcs8.key\n\n  （5）得到密钥对1_pri_pkcs8.key和1_pub.key\n\n\n\n\n\n\n\n\\- [openssl 安装参考链接](https://blog.csdn.net/qq_39081974/article/details/81059022)\n\n\n\n\n\n","source":"_posts/工具安装使用/证书/证书转换.md","raw":"---\ntitle: 证书转换 \ndate: 2020-10-28 14:16:33 \ncategories: 工具 \ntags: [pfx,cer] \ndescription: 详细讲解pfx、cer证书关系间相互转换。\n---\n\n安装好OpenSSL，然后到bin目录下，执行以下命令即可完成转换：\n\nopenssl pkcs12 -nodes -nokeys -in 1.pfx -passin pass:证书密码 -out 1.cer\n\n如无需加密pem中私钥，可以添加选项-nodes；\n\n\\1. 点击1.cer，安装cer证书\n\n2.从pfx提取密钥信息，并转换为key格式（pfx使用pkcs12模式补足）\n\n  （1）提取密钥对\n\n​    openssl pkcs12 -in 1.pfx -nocerts -nodes -out 1.key\n\n​    //如果pfx证书已加密，会提示输入密码。如果cer证书没有安装，则密码没法验证\n\n  （2）从密钥对提取私钥\n\n​    openssl rsa -in  1.key -out 1_pri.key\n\n  （3）从密钥对提取公钥\n\n​    openssl rsa -in 1.key -pubout -out 1_pub.key\n\n  （4）因为RSA算法使用的是pkcs8模式补足，需要对提取的私钥进一步处理\n\n​    openssl pkcs8 -topk8 -inform PEM -in 1_pri.key -outform PEM -nocrypt\n\n​     复制窗口中生成的密钥，保存为1_pri_pkcs8.key\n\n  （5）得到密钥对1_pri_pkcs8.key和1_pub.key\n\n\n\n\n\n\n\n\\- [openssl 安装参考链接](https://blog.csdn.net/qq_39081974/article/details/81059022)\n\n\n\n\n\n","slug":"工具安装使用/证书/证书转换","published":1,"updated":"2021-03-04T08:06:57.269Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklvnf25f0000estk0n08e9z7","content":"<p>安装好OpenSSL，然后到bin目录下，执行以下命令即可完成转换：</p>\n<p>openssl pkcs12 -nodes -nokeys -in 1.pfx -passin pass:证书密码 -out 1.cer</p>\n<p>如无需加密pem中私钥，可以添加选项-nodes；</p>\n<p>\\1. 点击1.cer，安装cer证书</p>\n<p>2.从pfx提取密钥信息，并转换为key格式（pfx使用pkcs12模式补足）</p>\n<p>  （1）提取密钥对</p>\n<p>​    openssl pkcs12 -in 1.pfx -nocerts -nodes -out 1.key</p>\n<p>​    //如果pfx证书已加密，会提示输入密码。如果cer证书没有安装，则密码没法验证</p>\n<p>  （2）从密钥对提取私钥</p>\n<p>​    openssl rsa -in  1.key -out 1_pri.key</p>\n<p>  （3）从密钥对提取公钥</p>\n<p>​    openssl rsa -in 1.key -pubout -out 1_pub.key</p>\n<p>  （4）因为RSA算法使用的是pkcs8模式补足，需要对提取的私钥进一步处理</p>\n<p>​    openssl pkcs8 -topk8 -inform PEM -in 1_pri.key -outform PEM -nocrypt</p>\n<p>​     复制窗口中生成的密钥，保存为1_pri_pkcs8.key</p>\n<p>  （5）得到密钥对1_pri_pkcs8.key和1_pub.key</p>\n<p>- <a href=\"https://blog.csdn.net/qq_39081974/article/details/81059022\">openssl 安装参考链接</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>安装好OpenSSL，然后到bin目录下，执行以下命令即可完成转换：</p>\n<p>openssl pkcs12 -nodes -nokeys -in 1.pfx -passin pass:证书密码 -out 1.cer</p>\n<p>如无需加密pem中私钥，可以添加选项-nodes；</p>\n<p>\\1. 点击1.cer，安装cer证书</p>\n<p>2.从pfx提取密钥信息，并转换为key格式（pfx使用pkcs12模式补足）</p>\n<p>  （1）提取密钥对</p>\n<p>​    openssl pkcs12 -in 1.pfx -nocerts -nodes -out 1.key</p>\n<p>​    //如果pfx证书已加密，会提示输入密码。如果cer证书没有安装，则密码没法验证</p>\n<p>  （2）从密钥对提取私钥</p>\n<p>​    openssl rsa -in  1.key -out 1_pri.key</p>\n<p>  （3）从密钥对提取公钥</p>\n<p>​    openssl rsa -in 1.key -pubout -out 1_pub.key</p>\n<p>  （4）因为RSA算法使用的是pkcs8模式补足，需要对提取的私钥进一步处理</p>\n<p>​    openssl pkcs8 -topk8 -inform PEM -in 1_pri.key -outform PEM -nocrypt</p>\n<p>​     复制窗口中生成的密钥，保存为1_pri_pkcs8.key</p>\n<p>  （5）得到密钥对1_pri_pkcs8.key和1_pub.key</p>\n<p>- <a href=\"https://blog.csdn.net/qq_39081974/article/details/81059022\">openssl 安装参考链接</a></p>\n"},{"title":"位运算","date":"2021-03-08T06:16:33.000Z","description":"java中位运算的使用及相关应用场景。","_content":"\n##  一、按位与&操作\n\n[TOC]\n\n### 1. 定义\n\n​\t& 与运算 两个位都是 1 时，结果才为 1，否则为 0。\n\n```java\n  1 0 0 1 1\n& 1 1 0 0 1\n------------------------------\n  1 0 0 0 1\n```\n\n### 2. 应用场景\n\n#### 2.1 奇偶性判断\n\n```java\nn&1 == 0 则为偶数\n```\n\n#### 2.2 判断n是否是2的正整数幂\n\n​\t原理：2的正整数幂始终比 前一个数字 多一个0\n\n```java\nn&(n-1) == 0 为2的正整数幂\neg:\n    n  = 16 = 1 0 0 0 0\n & n-1 = 15 = 0 1 1 1 1\n------------------------------ \n              0\n```\n\n#### 2.3 统计n中1的个数\n\n1. 判断奇偶，计数器+1，右移（只能正整数，负数死循环）\n\n   ```java\n   int count1(int n){\n       // 负数取绝对值\n       n = n < 0 ? Math.abs(n) : n;\n       int count = 0;\n       while (n!=0){\n           if((n&1) != 0){\n               count++;\n           }\n           n>>=1;\n       }\n       return count;\n   }\n   ```\n\n2. 根据最大正整数幂\n\n    ```java\n    int count1(int n){\n        // 负数取绝对值\n        n = n < 0 ? Math.abs(n) : n;\n        int count = 0;\n        while (n!=0){\n            n = (n - 1) & n;\n            count++;\n        }\n        return count;\n    }\n    ```\n\n## 二、 按位或运算 |\n\n### 1. 定义\n\n​\t\t| 或运算 两个位都是 0 时，结果才为 0，否则为 1。\n\n```java\n  1 0 0 1 1\n| 1 1 0 0 1\n------------------------------\n  1 1 0 1 1\n```\n\n\n\n## 三、异或运算 ^ \n\n### 1. 定义\n\n​\t\t^ 异或运算，两个位相同则为 0，不同则为 1。\n\n```java\n  1 0 0 1 1\n^ 1 1 0 0 1\n-----------------------------\n  0 1 0 1 0\n```\n\n## 四、取反运算 ~\n\n### 1. 定义\n\n​\t~ 取反运算，0 则变为 1，1 则变为 0。\n\n```java\n~ 1 0 0 1 1\n-----------------------------\n  0 1 1 0 0\n```\n\n## 五、左移运算 << \n\n### 1. 定义\t\n\n​\t<< 左移运算，向左进行移位操作，高位丢弃，低位补 0。\n\n```java\nint a = 8;\na << 3;\n移位前：0000 0000 0000 0000 0000 0000 0000 1000\n移位后：0000 0000 0000 0000 0000 0000 0100 0000\n```\n\n### 2. 应用场景\n\n1. 实现2的幂次方乘法   \n\n```java\nint a = 2;\na << 1; ---> a*2 = 4\na << 3; ---> a*2³ = 16\n```\n\n2. \n\n\n\n\n\n\n## 六、右移运算 >>\n\n### 1. 定义\n\n​\t\\>> 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位。\n\n```\nint a = 8;\na >> 3;\n移位前：0000 0000 0000 0000 0000 0000 0000 1000\n移位后：0000 0000 0000 0000 0000 0000 0000 0001\n\nint a = -8;\na >> 3;\n移位前：1111 1111 1111 1111 1111 1111 1111 1000\n移位前：1111 1111 1111 1111 1111 1111 1111 1111\n```\n\n\n\n\n\n## 参考\n\n\\- [位运算 之（1） 按位与（AND）& 操作](https://www.cnblogs.com/roamman/archive/2010/08/17/1801392.html)","source":"_posts/java学习/位运算/位运算.md","raw":"---\ntitle: 位运算 #文章页面上的显示名称，一般是中文\ndate: 2021-03-08 14:16:33 #文章生成时间，一般不改，当然也可以任意修改\ncategories: JAVA、位运算 #分类\ntags: [按位与,位运算] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: java中位运算的使用及相关应用场景。\n---\n\n##  一、按位与&操作\n\n[TOC]\n\n### 1. 定义\n\n​\t& 与运算 两个位都是 1 时，结果才为 1，否则为 0。\n\n```java\n  1 0 0 1 1\n& 1 1 0 0 1\n------------------------------\n  1 0 0 0 1\n```\n\n### 2. 应用场景\n\n#### 2.1 奇偶性判断\n\n```java\nn&1 == 0 则为偶数\n```\n\n#### 2.2 判断n是否是2的正整数幂\n\n​\t原理：2的正整数幂始终比 前一个数字 多一个0\n\n```java\nn&(n-1) == 0 为2的正整数幂\neg:\n    n  = 16 = 1 0 0 0 0\n & n-1 = 15 = 0 1 1 1 1\n------------------------------ \n              0\n```\n\n#### 2.3 统计n中1的个数\n\n1. 判断奇偶，计数器+1，右移（只能正整数，负数死循环）\n\n   ```java\n   int count1(int n){\n       // 负数取绝对值\n       n = n < 0 ? Math.abs(n) : n;\n       int count = 0;\n       while (n!=0){\n           if((n&1) != 0){\n               count++;\n           }\n           n>>=1;\n       }\n       return count;\n   }\n   ```\n\n2. 根据最大正整数幂\n\n    ```java\n    int count1(int n){\n        // 负数取绝对值\n        n = n < 0 ? Math.abs(n) : n;\n        int count = 0;\n        while (n!=0){\n            n = (n - 1) & n;\n            count++;\n        }\n        return count;\n    }\n    ```\n\n## 二、 按位或运算 |\n\n### 1. 定义\n\n​\t\t| 或运算 两个位都是 0 时，结果才为 0，否则为 1。\n\n```java\n  1 0 0 1 1\n| 1 1 0 0 1\n------------------------------\n  1 1 0 1 1\n```\n\n\n\n## 三、异或运算 ^ \n\n### 1. 定义\n\n​\t\t^ 异或运算，两个位相同则为 0，不同则为 1。\n\n```java\n  1 0 0 1 1\n^ 1 1 0 0 1\n-----------------------------\n  0 1 0 1 0\n```\n\n## 四、取反运算 ~\n\n### 1. 定义\n\n​\t~ 取反运算，0 则变为 1，1 则变为 0。\n\n```java\n~ 1 0 0 1 1\n-----------------------------\n  0 1 1 0 0\n```\n\n## 五、左移运算 << \n\n### 1. 定义\t\n\n​\t<< 左移运算，向左进行移位操作，高位丢弃，低位补 0。\n\n```java\nint a = 8;\na << 3;\n移位前：0000 0000 0000 0000 0000 0000 0000 1000\n移位后：0000 0000 0000 0000 0000 0000 0100 0000\n```\n\n### 2. 应用场景\n\n1. 实现2的幂次方乘法   \n\n```java\nint a = 2;\na << 1; ---> a*2 = 4\na << 3; ---> a*2³ = 16\n```\n\n2. \n\n\n\n\n\n\n## 六、右移运算 >>\n\n### 1. 定义\n\n​\t\\>> 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位。\n\n```\nint a = 8;\na >> 3;\n移位前：0000 0000 0000 0000 0000 0000 0000 1000\n移位后：0000 0000 0000 0000 0000 0000 0000 0001\n\nint a = -8;\na >> 3;\n移位前：1111 1111 1111 1111 1111 1111 1111 1000\n移位前：1111 1111 1111 1111 1111 1111 1111 1111\n```\n\n\n\n\n\n## 参考\n\n\\- [位运算 之（1） 按位与（AND）& 操作](https://www.cnblogs.com/roamman/archive/2010/08/17/1801392.html)","slug":"java学习/位运算/位运算","published":1,"updated":"2021-03-08T03:55:20.394Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmo6tkfl0000t4tk7bv1768m","content":"<h2 id=\"一、按位与-amp-操作\"><a href=\"#一、按位与-amp-操作\" class=\"headerlink\" title=\"一、按位与&amp;操作\"></a>一、按位与&amp;操作</h2><p>[TOC]</p>\n<h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​    &amp; 与运算 两个位都是 1 时，结果才为 1，否则为 0。</p>\n<pre><code class=\"java\">  1 0 0 1 1\n&amp; 1 1 0 0 1\n------------------------------\n  1 0 0 0 1</code></pre>\n<h3 id=\"2-应用场景\"><a href=\"#2-应用场景\" class=\"headerlink\" title=\"2. 应用场景\"></a>2. 应用场景</h3><h4 id=\"2-1-奇偶性判断\"><a href=\"#2-1-奇偶性判断\" class=\"headerlink\" title=\"2.1 奇偶性判断\"></a>2.1 奇偶性判断</h4><pre><code class=\"java\">n&amp;1 == 0 则为偶数</code></pre>\n<h4 id=\"2-2-判断n是否是2的正整数幂\"><a href=\"#2-2-判断n是否是2的正整数幂\" class=\"headerlink\" title=\"2.2 判断n是否是2的正整数幂\"></a>2.2 判断n是否是2的正整数幂</h4><p>​    原理：2的正整数幂始终比 前一个数字 多一个0</p>\n<pre><code class=\"java\">n&amp;(n-1) == 0 为2的正整数幂\neg:\n    n  = 16 = 1 0 0 0 0\n &amp; n-1 = 15 = 0 1 1 1 1\n------------------------------ \n              0</code></pre>\n<h4 id=\"2-3-统计n中1的个数\"><a href=\"#2-3-统计n中1的个数\" class=\"headerlink\" title=\"2.3 统计n中1的个数\"></a>2.3 统计n中1的个数</h4><ol>\n<li><p>判断奇偶，计数器+1，右移（只能正整数，负数死循环）</p>\n<pre><code class=\"java\">int count1(int n)&#123;\n    // 负数取绝对值\n    n = n &lt; 0 ? Math.abs(n) : n;\n    int count = 0;\n    while (n!=0)&#123;\n        if((n&amp;1) != 0)&#123;\n            count++;\n        &#125;\n        n&gt;&gt;=1;\n    &#125;\n    return count;\n&#125;</code></pre>\n</li>\n<li><p>根据最大正整数幂</p>\n<pre><code class=\"java\">int count1(int n)&#123;\n    // 负数取绝对值\n    n = n &lt; 0 ? Math.abs(n) : n;\n    int count = 0;\n    while (n!=0)&#123;\n        n = (n - 1) &amp; n;\n        count++;\n    &#125;\n    return count;\n&#125;</code></pre>\n</li>\n</ol>\n<h2 id=\"二、-按位或运算\"><a href=\"#二、-按位或运算\" class=\"headerlink\" title=\"二、 按位或运算 |\"></a>二、 按位或运算 |</h2><h3 id=\"1-定义-1\"><a href=\"#1-定义-1\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​        | 或运算 两个位都是 0 时，结果才为 0，否则为 1。</p>\n<pre><code class=\"java\">  1 0 0 1 1\n| 1 1 0 0 1\n------------------------------\n  1 1 0 1 1</code></pre>\n<h2 id=\"三、异或运算\"><a href=\"#三、异或运算\" class=\"headerlink\" title=\"三、异或运算 ^\"></a>三、异或运算 ^</h2><h3 id=\"1-定义-2\"><a href=\"#1-定义-2\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​        ^ 异或运算，两个位相同则为 0，不同则为 1。</p>\n<pre><code class=\"java\">  1 0 0 1 1\n^ 1 1 0 0 1\n-----------------------------\n  0 1 0 1 0</code></pre>\n<h2 id=\"四、取反运算\"><a href=\"#四、取反运算\" class=\"headerlink\" title=\"四、取反运算 ~\"></a>四、取反运算 ~</h2><h3 id=\"1-定义-3\"><a href=\"#1-定义-3\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​    ~ 取反运算，0 则变为 1，1 则变为 0。</p>\n<pre><code class=\"java\">~ 1 0 0 1 1\n-----------------------------\n  0 1 1 0 0</code></pre>\n<h2 id=\"五、左移运算-lt-lt\"><a href=\"#五、左移运算-lt-lt\" class=\"headerlink\" title=\"五、左移运算 &lt;&lt;\"></a>五、左移运算 &lt;&lt;</h2><h3 id=\"1-定义-4\"><a href=\"#1-定义-4\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​    &lt;&lt; 左移运算，向左进行移位操作，高位丢弃，低位补 0。</p>\n<pre><code class=\"java\">int a = 8;\na &lt;&lt; 3;\n移位前：0000 0000 0000 0000 0000 0000 0000 1000\n移位后：0000 0000 0000 0000 0000 0000 0100 0000</code></pre>\n<h3 id=\"2-应用场景-1\"><a href=\"#2-应用场景-1\" class=\"headerlink\" title=\"2. 应用场景\"></a>2. 应用场景</h3><ol>\n<li>实现2的幂次方乘法   </li>\n</ol>\n<pre><code class=\"java\">int a = 2;\na &lt;&lt; 1; ---&gt; a*2 = 4\na &lt;&lt; 3; ---&gt; a*2³ = 16</code></pre>\n<ol start=\"2\">\n<li></li>\n</ol>\n<h2 id=\"六、右移运算-gt-gt\"><a href=\"#六、右移运算-gt-gt\" class=\"headerlink\" title=\"六、右移运算 &gt;&gt;\"></a>六、右移运算 &gt;&gt;</h2><h3 id=\"1-定义-5\"><a href=\"#1-定义-5\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​    &gt;&gt; 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位。</p>\n<pre><code>int a = 8;\na &gt;&gt; 3;\n移位前：0000 0000 0000 0000 0000 0000 0000 1000\n移位后：0000 0000 0000 0000 0000 0000 0000 0001\n\nint a = -8;\na &gt;&gt; 3;\n移位前：1111 1111 1111 1111 1111 1111 1111 1000\n移位前：1111 1111 1111 1111 1111 1111 1111 1111</code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>- <a href=\"https://www.cnblogs.com/roamman/archive/2010/08/17/1801392.html\">位运算 之（1） 按位与（AND）&amp; 操作</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、按位与-amp-操作\"><a href=\"#一、按位与-amp-操作\" class=\"headerlink\" title=\"一、按位与&amp;操作\"></a>一、按位与&amp;操作</h2><p>[TOC]</p>\n<h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​    &amp; 与运算 两个位都是 1 时，结果才为 1，否则为 0。</p>\n<pre><code class=\"java\">  1 0 0 1 1\n&amp; 1 1 0 0 1\n------------------------------\n  1 0 0 0 1</code></pre>\n<h3 id=\"2-应用场景\"><a href=\"#2-应用场景\" class=\"headerlink\" title=\"2. 应用场景\"></a>2. 应用场景</h3><h4 id=\"2-1-奇偶性判断\"><a href=\"#2-1-奇偶性判断\" class=\"headerlink\" title=\"2.1 奇偶性判断\"></a>2.1 奇偶性判断</h4><pre><code class=\"java\">n&amp;1 == 0 则为偶数</code></pre>\n<h4 id=\"2-2-判断n是否是2的正整数幂\"><a href=\"#2-2-判断n是否是2的正整数幂\" class=\"headerlink\" title=\"2.2 判断n是否是2的正整数幂\"></a>2.2 判断n是否是2的正整数幂</h4><p>​    原理：2的正整数幂始终比 前一个数字 多一个0</p>\n<pre><code class=\"java\">n&amp;(n-1) == 0 为2的正整数幂\neg:\n    n  = 16 = 1 0 0 0 0\n &amp; n-1 = 15 = 0 1 1 1 1\n------------------------------ \n              0</code></pre>\n<h4 id=\"2-3-统计n中1的个数\"><a href=\"#2-3-统计n中1的个数\" class=\"headerlink\" title=\"2.3 统计n中1的个数\"></a>2.3 统计n中1的个数</h4><ol>\n<li><p>判断奇偶，计数器+1，右移（只能正整数，负数死循环）</p>\n<pre><code class=\"java\">int count1(int n)&#123;\n    // 负数取绝对值\n    n = n &lt; 0 ? Math.abs(n) : n;\n    int count = 0;\n    while (n!=0)&#123;\n        if((n&amp;1) != 0)&#123;\n            count++;\n        &#125;\n        n&gt;&gt;=1;\n    &#125;\n    return count;\n&#125;</code></pre>\n</li>\n<li><p>根据最大正整数幂</p>\n<pre><code class=\"java\">int count1(int n)&#123;\n    // 负数取绝对值\n    n = n &lt; 0 ? Math.abs(n) : n;\n    int count = 0;\n    while (n!=0)&#123;\n        n = (n - 1) &amp; n;\n        count++;\n    &#125;\n    return count;\n&#125;</code></pre>\n</li>\n</ol>\n<h2 id=\"二、-按位或运算\"><a href=\"#二、-按位或运算\" class=\"headerlink\" title=\"二、 按位或运算 |\"></a>二、 按位或运算 |</h2><h3 id=\"1-定义-1\"><a href=\"#1-定义-1\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​        | 或运算 两个位都是 0 时，结果才为 0，否则为 1。</p>\n<pre><code class=\"java\">  1 0 0 1 1\n| 1 1 0 0 1\n------------------------------\n  1 1 0 1 1</code></pre>\n<h2 id=\"三、异或运算\"><a href=\"#三、异或运算\" class=\"headerlink\" title=\"三、异或运算 ^\"></a>三、异或运算 ^</h2><h3 id=\"1-定义-2\"><a href=\"#1-定义-2\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​        ^ 异或运算，两个位相同则为 0，不同则为 1。</p>\n<pre><code class=\"java\">  1 0 0 1 1\n^ 1 1 0 0 1\n-----------------------------\n  0 1 0 1 0</code></pre>\n<h2 id=\"四、取反运算\"><a href=\"#四、取反运算\" class=\"headerlink\" title=\"四、取反运算 ~\"></a>四、取反运算 ~</h2><h3 id=\"1-定义-3\"><a href=\"#1-定义-3\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​    ~ 取反运算，0 则变为 1，1 则变为 0。</p>\n<pre><code class=\"java\">~ 1 0 0 1 1\n-----------------------------\n  0 1 1 0 0</code></pre>\n<h2 id=\"五、左移运算-lt-lt\"><a href=\"#五、左移运算-lt-lt\" class=\"headerlink\" title=\"五、左移运算 &lt;&lt;\"></a>五、左移运算 &lt;&lt;</h2><h3 id=\"1-定义-4\"><a href=\"#1-定义-4\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​    &lt;&lt; 左移运算，向左进行移位操作，高位丢弃，低位补 0。</p>\n<pre><code class=\"java\">int a = 8;\na &lt;&lt; 3;\n移位前：0000 0000 0000 0000 0000 0000 0000 1000\n移位后：0000 0000 0000 0000 0000 0000 0100 0000</code></pre>\n<h3 id=\"2-应用场景-1\"><a href=\"#2-应用场景-1\" class=\"headerlink\" title=\"2. 应用场景\"></a>2. 应用场景</h3><ol>\n<li>实现2的幂次方乘法   </li>\n</ol>\n<pre><code class=\"java\">int a = 2;\na &lt;&lt; 1; ---&gt; a*2 = 4\na &lt;&lt; 3; ---&gt; a*2³ = 16</code></pre>\n<ol start=\"2\">\n<li></li>\n</ol>\n<h2 id=\"六、右移运算-gt-gt\"><a href=\"#六、右移运算-gt-gt\" class=\"headerlink\" title=\"六、右移运算 &gt;&gt;\"></a>六、右移运算 &gt;&gt;</h2><h3 id=\"1-定义-5\"><a href=\"#1-定义-5\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​    &gt;&gt; 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位。</p>\n<pre><code>int a = 8;\na &gt;&gt; 3;\n移位前：0000 0000 0000 0000 0000 0000 0000 1000\n移位后：0000 0000 0000 0000 0000 0000 0000 0001\n\nint a = -8;\na &gt;&gt; 3;\n移位前：1111 1111 1111 1111 1111 1111 1111 1000\n移位前：1111 1111 1111 1111 1111 1111 1111 1111</code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>- <a href=\"https://www.cnblogs.com/roamman/archive/2010/08/17/1801392.html\">位运算 之（1） 按位与（AND）&amp; 操作</a></p>\n"},{"_content":"## 微信jsapi支付\n\n### 1. 微信获取openid所需配置信息\n\n1. 进入地址：[微信公众号平台](https://mp.weixin.qq.com/cgi-bin/home?t=home/index&token=1709035801&lang=zh_CN)\n\n2. 进入**【开发】**—**【基本设置】**，配置 **开发者密码**、**服务器地址**、**令牌**、**消费加解密秘钥** 相关信息，开发者密码需要自己保存。\n\n   ![image-20210203152515345](流程\\image-20210203152515345.png)![image-20210203152440553](流程\\image-20210203152440553.png)\n\n4. 进入 **【设置】**—**【公众号设置】**，点击**【功能设置】**，配置**网页授权域名**，用于获取**code**和**openid**选项\n\n    ![image-20210203153111406](流程\\image-20210203153111406.png)![image-20210203153129592](流程\\image-20210203153129592.png)\n\n5. 参考代码如下\n\n    ```java\n    public static void main(String[] args) {\n            \n            //获取微信code\n            String REDIRECT_URI=\"http://yangsongxiao.cn/Web/Web\";\n            String APPID=\"wxafb534aced348cf5\";\n            String SECRET=\"1c9d8089a89893fa077a597ef5d35055\";\n            String ACCESS_TOKEN_URL = \"https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=snsapi_base&state=STATE#wechat_redirect\";\n            String url = ACCESS_TOKEN_URL.replace(\"APPID\", APPID).replace(\"STATE\",\"1\").replace(\"REDIRECT_URI\", REDIRECT_URI );\n            //微信访问这个页面  服务器可以获取到code \n            System.out.println(url);\n            \n            //获取openid\n            String CODE=\"051pqs100IRy8L10XF300vWp1u1pqs1m\";\n            String url2 = \"https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&secret=SECRET&code=CODE&grant_type=authorization_code\";\n            String Get_Openid = url2.replace(\"APPID\", APPID).replace(\"SECRET\", SECRET).replace(\"CODE\", CODE);\n            System.out.println(Get_Openid);\n            String resp = HttpUtil.doGetStr(Get_Openid);\n            JSONObject re = JSONObject.parseObject(resp);\n            String result = re.containsKey(InitConfig.OPEN_ID) ? re.getString(InitConfig.OPEN_ID) : InitConfig.ERR_START + re.getString(InitConfig.ERR_MSG);\n            System.out.println(result);\n    \n        }\n    ```\n\n6. [微信获取openid方式参考链接](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html)\n\n7. [微信商户平台地址](https://pay.weixin.qq.com/index.php)\n\n\n\n### 2. 前后端拉起\n\n1. [JSAPI 调起支付参考链接](https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_4.shtml)\n2. [微信JSAPI开发指引](https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_3.shtml)\n\n### 3. 注意\n\n​\t**需要配置支付授权目录!!!  由于目前使用钱宝appid下单，所用授权目录地址为钱宝配置。**\n\n## 微信小程序支付相关\n\n> 目前仅知，需要钱宝下单的appid登录小程序开发工具，或者把我方小程序开发人员，拉入到下单appid的项目组中，借用其资质开发一个小程序可用。\n\n## 支付宝相关\n\n### 1. 支付宝获取userid方法\n\n1. 登录[支付宝开放平台](https://openhome.alipay.com/platform/home.htm)\n\n   ```\n   账号:  yhtdpay@163.com\n   密码:  chen1992*+\n   手机号绑定人：陈华材\n   ```\n\n2. 创建一个**【应用】**，进入**【应用】**![image-20210203162313099](流程\\image-20210203162313099.png)\n\n3.  点击**【设置】**按钮，配置**【接口加签方式】**（用于获取openid时加签验签操作）、**【授权回调地址】**（用来获取openid信息）\n\n   ![image-20210203162712582](流程\\image-20210203162712582.png)\n\n   ![image-20210203163036267](流程\\image-20210203163036267.png)\n\n4. [获取userid参考链接](https://opendocs.alipay.com/isv/10467/xldcyq)\n\n   [支付宝官方公私钥配置参考链接](https://opensupport.alipay.com/support/helpcenter/207/201602471154?ant_source=manual&recommend=ab2418594aa12994227b51f38a16d735)\n\n5. 参考代码\n\n   ```java\n   \t\t//获取zfb appid\n           String appid=\"2021001156603164\";\n           //进行url转码\n           String returnurl=\"http%3a%2f%2fyangsongxiao.cn%2fWeb%2fWeb\";\n           String url=\"https://openauth.alipay.com/oauth2/appToAppAuth.htm?app_id=\"+appid+\"&redirect_uri=\"+returnurl;\n           //支付宝访问这个地址，点击授权  服务器获取 app_id 和 app_auth_code\n           System.out.println(url);\n           String app_id=\"2021001156603164\";\n           String app_auth_code=\"06ff73b078c24a24bc720b038ec77B74\";\n   \n           //支付宝公钥\n           String alipay_public_key=\"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAshrxiMZappfjphxroVLUWNFErcuC22OlsWZdvgVCgDCJuvBO5ZPqZ4pWNeInWBAoCZiqElYPV+2Tt8vHOyeWpQiHTMOUm+FXOHCvRieyYiFtTCkn61E70ZWI6VAxsyYAbiqYJ48/LmooFAD27Qw5YgWDn2Zi5FEKjWpYtfxVz/QfDbpf85HjUdlmZQsU0fppXwCY38nGzzDZ2jG9sURlcwNgV7bxnYUirFNeEVssMqgQGOLMMvvx2Dm6CoZPpQ4/9ripMYGluHxHk0Open0Khg8M4X0VSfYopwJc4P6SQbKj1B0OdGinIPzyHqFoO3g083DjYYKtD5Cj3LmA+n5gPQIDAQAB\";\n   \n           String app_private_key=\"\";\n   \n           //获取AppAuthToken\n           AlipayClient alipayClient= new DefaultAlipayClient( \"https://openapi.alipay.com/gateway.do\" ,  app_id , app_private_key , \"json\" ,  \"GBK\" ,  alipay_public_key , \"RSA2\" );\n           AlipayOpenAuthTokenAppRequest request = new AlipayOpenAuthTokenAppRequest ();\n           request.setBizContent (\n                   \"{\"   + \"\\\"grant_type\\\":\\\"authorization_code\\\",\"   +\n                           \"\\\"code\\\":\\\"\"+app_auth_code+\"\\\"\" +\n                   \"}\"\n           );\n           AlipayOpenAuthTokenAppResponse response = alipayClient.execute ( request );\n           System.out.println(response.getAppAuthToken());\n   ```\n\n### 2. 支付宝拉起支付\n\n1. [支付宝老方式前端拉起支付链接](https://opendocs.alipay.com/open/common/105591)\n\n   ```html\n   <p id=\"result\">result: </p>\n   <script type=\"application/javascript\">\n       // 调试时可以通过在页面定义一个元素，打印信息，使用alert方法不够优雅\n       function log(obj) {\n           $(\"#result\").append(obj).append(\" \").append(\"<br />\");\n       }\n   \n       $(document).ready(function(){\n           // 页面载入完成后即唤起收银台\n           // 此处${tradeNO}为模板语言语法，实际调用样例类似为tradePpay(\"2016072621001004200000000752\")\n            tradePay(\"${tradeNO}\"); \n   \n            // 点击payButton按钮后唤起收银台\n            $(\"#payButton\").click(function() {\n               tradePay(\"${tradeNO}\");\n            });\n   \n            // 通过jsapi关闭当前窗口，仅供参考，更多jsapi请访问\n            // /aod/54/104510\n            $(\"#closeButton\").click(function() {\n               AlipayJSBridge.call('closeWebview');\n            });\n        });\n   \n       // 由于js的载入是异步的，所以可以通过该方法，当AlipayJSBridgeReady事件发生后，再执行callback方法\n        function ready(callback) {\n            if (window.AlipayJSBridge) {\n                callback && callback();\n            } else {\n                document.addEventListener('AlipayJSBridgeReady', callback, false);\n            }\n        }\n   \n        function tradePay(tradeNO) {\n           ready(function(){\n                // 通过传入交易号唤起快捷调用方式(注意tradeNO大小写严格)\n                AlipayJSBridge.call(\"tradePay\", {\n   tradeNO: tradeNO\n                }, function (data) {\n                    log(JSON.stringify(data));\n                    if (\"9000\" == data.resultCode) {\n                        log(\"支付成功\");\n                    }\n                });\n           });\n       }\n   </script>\n   ```\n\n2. [支付宝新版拉起支付参考链接](https://myjsapi.alipay.com/alipayjsapi/util/pay/tradePay.html)\n\n   ```js\n   <script src=\"https://gw.alipayobjects.com/as/g/h5-lib/alipayjsapi/3.1.1/alipayjsapi.inc.min.js\"></script>\n   <script type=\"text/javascript\">\n       window.onload = function () {\n       /* 支付宝 */\n       var btn = document.querySelector('#J_btn');\n       btn.addEventListener('click', function(){\n           alert(\"支付\")\n           ap.tradePay({\n               tradeNO: '2021020322001430791435578886',\n           }, function(res){\n               ap.alert(res.resultCode);\n           });\n       });\n   </script>\n   ```\n\n### 3. 支付宝秘钥相关\n\n1. 支付宝平台公钥\n\n```\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAshrxiMZappfjphxroVLUWNFErcuC22OlsWZdvgVCgDCJuvBO5ZPqZ4pWNeInWBAoCZiqElYPV+2Tt8vHOyeWpQiHTMOUm+FXOHCvRieyYiFtTCkn61E70ZWI6VAxsyYAbiqYJ48/LmooFAD27Qw5YgWDn2Zi5FEKjWpYtfxVz/QfDbpf85HjUdlmZQsU0fppXwCY38nGzzDZ2jG9sURlcwNgV7bxnYUirFNeEVssMqgQGOLMMvvx2Dm6CoZPpQ4/9ripMYGluHxHk0Open0Khg8M4X0VSfYopwJc4P6SQbKj1B0OdGinIPzyHqFoO3g083DjYYKtD5Cj3LmA+n5gPQIDAQAB\n```\n\n2. 商户自己公私钥\n\n   2.1 公钥\n\n   ```\n   MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAstPGBWAJfHmu3WXWnX2TRM8doL1oDmgmIc0mVLvJyjI937KpCXpE8STz5dWgIGnzuuvhx7iWWbRA33ItzwQD61aatGjWlUA9afyU6mqkWk8X2HogbfnLTo+X7DKVLk+v7fLXxc7PKP3albF9rNs3qdNbwe+6WoOLv6JXgBXgWxGeGNNWIMyI34+f1bnPhw5dhFKkVMBsVTmbI8CFlhUaBy1oW+lF2bviDPn4OPfuhizPg2DKaRKPv8ucnBWrYnSN2jQZWoK72lf8qxl8Musi4sOMzhXWN0mVA0DAr4v9MQccbsmjjm6agyHeYmC+dmP7C9dwjxwvQKfhSNNdAnWpTQIDAQAB\n   ```\n\n   2.2 私钥\n\n   ```\n   MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCy08YFYAl8ea7dZdadfZNEzx2gvWgOaCYhzSZUu8nKMj3fsqkJekTxJPPl1aAgafO66+HHuJZZtEDfci3PBAPrVpq0aNaVQD1p/JTqaqRaTxfYeiBt+ctOj5fsMpUuT6/t8tfFzs8o/dqVsX2s2zep01vB77pag4u/oleAFeBbEZ4Y01YgzIjfj5/Vuc+HDl2EUqRUwGxVOZsjwIWWFRoHLWhb6UXZu+IM+fg49+6GLM+DYMppEo+/y5ycFatidI3aNBlagrvaV/yrGXwy6yLiw4zOFdY3SZUDQMCvi/0xBxxuyaOObpqDId5iYL52Y/sL13CPHC9Ap+FI010CdalNAgMBAAECggEAP+emEC2ttinV75CBDW7evew17kdBdESLu/CQDh+9kOA7dEFoXtau5G4MKsoYmvzB+L5qxPCV6iCcPj2TWTNaIzOjvWzpohR+3e1BWjQZ35v8LYQXKrXljYGLDQFWhmI7wJDTwwCQz1lIT85J1wfP8IRzee6tbcMsoaLmGgO3VVNwp9kkbwODG/d48P33joQ8MT0JUjZUDGQGaRhVLh1GOfJny9rT2CmNIrzNriovwb4Gz4+UFLGNhbPOHZPBS62mnEzm/0Yjhj4V9y9qxt6IygwAs08rjRRY1bwQf1WoHp3bT2k5ueB2QF9b2MXljzC3yloufGkzD/vASp+T6xK4AQKBgQDtZxxLZPzS5YDN18CX1efqkMZGS+ov4y+aXM6W34eRIYeN5PUIkCoRER+G6B47y0b498JYMqgSkDEzy+PfYTIE0evMSnbYpU62chqRQ0k5dOWTScJyuEDdPyQpRv4ECSEyVuV48i1AWTH8AH+PLFj5A55j05rsGNk+OR9PXCt9zQKBgQDA1fxXHdbyGh9hqWyvUE4p9gbwhA2Qq6pkrDM68JcxokNpw9WuGsU4hHeqx4+FvVOqPH9RrfAKHUTB6ADWz47Z5i7+LxPbue///TX81m76V/8soxCMVME1lDmOO6vBOxIvYYP2dVFPT7JGmECbcuY/bghrlWzknN4RewB0MgtZgQKBgFh6SlBLFfLfuA5/b3bnMOT6CftfBavNRwuHtTMDofnT/jpC75O+bv8nW5Gi5smwLAZUCGloj71DYiMExSuWhNbJCdF8myiJC3nxsrca1aqFR56KKd8pjnsmsip0G+2THX0uZ52Y3IaT944M/X11sL81uw1HawC9DhIjpeik2EytAoGAJ/Ir+7/qruxKY+i84vQ3vOmCNoCkbrug6Injcuoz58w9OsOemBpjkHmgcHg2evXlRvaRSVJGz1GQ1LpCsjz80pakVXNbIcE6vkSt0lp5UtK3wX9mBivoejjiU1x5D+Y0tiv1MjDLTyqrO4R+nbUHjUw14lNp41G7jtN0HJ3hTAECgYEAkgtwQMEydeqaJ5VV74B3xeQwa5jLUuoosbRg8qSD8UGHl1+i7k2ttumtv0t4NpMpVjmO/n9WOld3BAvrN3IuO1FVmc9JuNBP9s+vQxeD9wvx0XcB4RKlY7mNAi/J3WQkBJfj1q0hTGtB9ZxWLfqLIv9yDxYPkWoPyJwWxA0ohBA=\n   ```\n\n## QQ \n\n### 1. 获取sid流程\n\n### 2. 前端代码\n\n```js\n<script type=\"application/javascript\" src=\"https://open.mobile.qq.com/sdk/qqapi.js?_bid=152\"></script>\n<script type=\"text/javascript\">\n\tfunction pay(){\n            //验证是否是QQ\n            mqq.device.isMobileQQ(function(result){\n                if(result) {\n                    var isIos = mqq.iOS;\n                    //alert(\"是否是IOS:\" + isIos);\n                    var isAndroid = mqq.android;\n                    //alert(\"是否是Android:\" + isAndroid);\n                    var qqVersion = mqq.QQVersion;\n                    //alert(\"QQVersion:\" + qqVersion);\n                    //唤起QQ钱包\n                    this.callPay()\n                } else {\n                    alert(\"请在手机QQ中打开此页面\");\n                    return false;\n                }\n            });\n        }\n\n        function callPay(){\n            mqq.tenpay.pay({\n                tokenId: \"5Mfd2ffe642c61f498b8c03a4638a04e\",\n            }, function(result, resultCode){\n                if(result == \"Permission denied\") {\n                    alert(\"无权限 \");\n                } else {\n                    alert(result.resultCode);\n                    document.location.href = \"${redirectUrl}\";\n                }\n            });\n        }\n</script>\n```\n\n\n\n## 钱宝相关\n\n```\n测试商户号：848290972306000  \n测试终端号：29002210\n目前配置支付授权目录：http://yangsongxiao.cn/ysf/\n```\n\n![image-20210203155002102](流程\\image-20210203155002102.png)","source":"_posts/工具安装使用/聚合支付拉起流程/流程.md","raw":"## 微信jsapi支付\n\n### 1. 微信获取openid所需配置信息\n\n1. 进入地址：[微信公众号平台](https://mp.weixin.qq.com/cgi-bin/home?t=home/index&token=1709035801&lang=zh_CN)\n\n2. 进入**【开发】**—**【基本设置】**，配置 **开发者密码**、**服务器地址**、**令牌**、**消费加解密秘钥** 相关信息，开发者密码需要自己保存。\n\n   ![image-20210203152515345](流程\\image-20210203152515345.png)![image-20210203152440553](流程\\image-20210203152440553.png)\n\n4. 进入 **【设置】**—**【公众号设置】**，点击**【功能设置】**，配置**网页授权域名**，用于获取**code**和**openid**选项\n\n    ![image-20210203153111406](流程\\image-20210203153111406.png)![image-20210203153129592](流程\\image-20210203153129592.png)\n\n5. 参考代码如下\n\n    ```java\n    public static void main(String[] args) {\n            \n            //获取微信code\n            String REDIRECT_URI=\"http://yangsongxiao.cn/Web/Web\";\n            String APPID=\"wxafb534aced348cf5\";\n            String SECRET=\"1c9d8089a89893fa077a597ef5d35055\";\n            String ACCESS_TOKEN_URL = \"https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=snsapi_base&state=STATE#wechat_redirect\";\n            String url = ACCESS_TOKEN_URL.replace(\"APPID\", APPID).replace(\"STATE\",\"1\").replace(\"REDIRECT_URI\", REDIRECT_URI );\n            //微信访问这个页面  服务器可以获取到code \n            System.out.println(url);\n            \n            //获取openid\n            String CODE=\"051pqs100IRy8L10XF300vWp1u1pqs1m\";\n            String url2 = \"https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&secret=SECRET&code=CODE&grant_type=authorization_code\";\n            String Get_Openid = url2.replace(\"APPID\", APPID).replace(\"SECRET\", SECRET).replace(\"CODE\", CODE);\n            System.out.println(Get_Openid);\n            String resp = HttpUtil.doGetStr(Get_Openid);\n            JSONObject re = JSONObject.parseObject(resp);\n            String result = re.containsKey(InitConfig.OPEN_ID) ? re.getString(InitConfig.OPEN_ID) : InitConfig.ERR_START + re.getString(InitConfig.ERR_MSG);\n            System.out.println(result);\n    \n        }\n    ```\n\n6. [微信获取openid方式参考链接](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html)\n\n7. [微信商户平台地址](https://pay.weixin.qq.com/index.php)\n\n\n\n### 2. 前后端拉起\n\n1. [JSAPI 调起支付参考链接](https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_4.shtml)\n2. [微信JSAPI开发指引](https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_3.shtml)\n\n### 3. 注意\n\n​\t**需要配置支付授权目录!!!  由于目前使用钱宝appid下单，所用授权目录地址为钱宝配置。**\n\n## 微信小程序支付相关\n\n> 目前仅知，需要钱宝下单的appid登录小程序开发工具，或者把我方小程序开发人员，拉入到下单appid的项目组中，借用其资质开发一个小程序可用。\n\n## 支付宝相关\n\n### 1. 支付宝获取userid方法\n\n1. 登录[支付宝开放平台](https://openhome.alipay.com/platform/home.htm)\n\n   ```\n   账号:  yhtdpay@163.com\n   密码:  chen1992*+\n   手机号绑定人：陈华材\n   ```\n\n2. 创建一个**【应用】**，进入**【应用】**![image-20210203162313099](流程\\image-20210203162313099.png)\n\n3.  点击**【设置】**按钮，配置**【接口加签方式】**（用于获取openid时加签验签操作）、**【授权回调地址】**（用来获取openid信息）\n\n   ![image-20210203162712582](流程\\image-20210203162712582.png)\n\n   ![image-20210203163036267](流程\\image-20210203163036267.png)\n\n4. [获取userid参考链接](https://opendocs.alipay.com/isv/10467/xldcyq)\n\n   [支付宝官方公私钥配置参考链接](https://opensupport.alipay.com/support/helpcenter/207/201602471154?ant_source=manual&recommend=ab2418594aa12994227b51f38a16d735)\n\n5. 参考代码\n\n   ```java\n   \t\t//获取zfb appid\n           String appid=\"2021001156603164\";\n           //进行url转码\n           String returnurl=\"http%3a%2f%2fyangsongxiao.cn%2fWeb%2fWeb\";\n           String url=\"https://openauth.alipay.com/oauth2/appToAppAuth.htm?app_id=\"+appid+\"&redirect_uri=\"+returnurl;\n           //支付宝访问这个地址，点击授权  服务器获取 app_id 和 app_auth_code\n           System.out.println(url);\n           String app_id=\"2021001156603164\";\n           String app_auth_code=\"06ff73b078c24a24bc720b038ec77B74\";\n   \n           //支付宝公钥\n           String alipay_public_key=\"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAshrxiMZappfjphxroVLUWNFErcuC22OlsWZdvgVCgDCJuvBO5ZPqZ4pWNeInWBAoCZiqElYPV+2Tt8vHOyeWpQiHTMOUm+FXOHCvRieyYiFtTCkn61E70ZWI6VAxsyYAbiqYJ48/LmooFAD27Qw5YgWDn2Zi5FEKjWpYtfxVz/QfDbpf85HjUdlmZQsU0fppXwCY38nGzzDZ2jG9sURlcwNgV7bxnYUirFNeEVssMqgQGOLMMvvx2Dm6CoZPpQ4/9ripMYGluHxHk0Open0Khg8M4X0VSfYopwJc4P6SQbKj1B0OdGinIPzyHqFoO3g083DjYYKtD5Cj3LmA+n5gPQIDAQAB\";\n   \n           String app_private_key=\"\";\n   \n           //获取AppAuthToken\n           AlipayClient alipayClient= new DefaultAlipayClient( \"https://openapi.alipay.com/gateway.do\" ,  app_id , app_private_key , \"json\" ,  \"GBK\" ,  alipay_public_key , \"RSA2\" );\n           AlipayOpenAuthTokenAppRequest request = new AlipayOpenAuthTokenAppRequest ();\n           request.setBizContent (\n                   \"{\"   + \"\\\"grant_type\\\":\\\"authorization_code\\\",\"   +\n                           \"\\\"code\\\":\\\"\"+app_auth_code+\"\\\"\" +\n                   \"}\"\n           );\n           AlipayOpenAuthTokenAppResponse response = alipayClient.execute ( request );\n           System.out.println(response.getAppAuthToken());\n   ```\n\n### 2. 支付宝拉起支付\n\n1. [支付宝老方式前端拉起支付链接](https://opendocs.alipay.com/open/common/105591)\n\n   ```html\n   <p id=\"result\">result: </p>\n   <script type=\"application/javascript\">\n       // 调试时可以通过在页面定义一个元素，打印信息，使用alert方法不够优雅\n       function log(obj) {\n           $(\"#result\").append(obj).append(\" \").append(\"<br />\");\n       }\n   \n       $(document).ready(function(){\n           // 页面载入完成后即唤起收银台\n           // 此处${tradeNO}为模板语言语法，实际调用样例类似为tradePpay(\"2016072621001004200000000752\")\n            tradePay(\"${tradeNO}\"); \n   \n            // 点击payButton按钮后唤起收银台\n            $(\"#payButton\").click(function() {\n               tradePay(\"${tradeNO}\");\n            });\n   \n            // 通过jsapi关闭当前窗口，仅供参考，更多jsapi请访问\n            // /aod/54/104510\n            $(\"#closeButton\").click(function() {\n               AlipayJSBridge.call('closeWebview');\n            });\n        });\n   \n       // 由于js的载入是异步的，所以可以通过该方法，当AlipayJSBridgeReady事件发生后，再执行callback方法\n        function ready(callback) {\n            if (window.AlipayJSBridge) {\n                callback && callback();\n            } else {\n                document.addEventListener('AlipayJSBridgeReady', callback, false);\n            }\n        }\n   \n        function tradePay(tradeNO) {\n           ready(function(){\n                // 通过传入交易号唤起快捷调用方式(注意tradeNO大小写严格)\n                AlipayJSBridge.call(\"tradePay\", {\n   tradeNO: tradeNO\n                }, function (data) {\n                    log(JSON.stringify(data));\n                    if (\"9000\" == data.resultCode) {\n                        log(\"支付成功\");\n                    }\n                });\n           });\n       }\n   </script>\n   ```\n\n2. [支付宝新版拉起支付参考链接](https://myjsapi.alipay.com/alipayjsapi/util/pay/tradePay.html)\n\n   ```js\n   <script src=\"https://gw.alipayobjects.com/as/g/h5-lib/alipayjsapi/3.1.1/alipayjsapi.inc.min.js\"></script>\n   <script type=\"text/javascript\">\n       window.onload = function () {\n       /* 支付宝 */\n       var btn = document.querySelector('#J_btn');\n       btn.addEventListener('click', function(){\n           alert(\"支付\")\n           ap.tradePay({\n               tradeNO: '2021020322001430791435578886',\n           }, function(res){\n               ap.alert(res.resultCode);\n           });\n       });\n   </script>\n   ```\n\n### 3. 支付宝秘钥相关\n\n1. 支付宝平台公钥\n\n```\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAshrxiMZappfjphxroVLUWNFErcuC22OlsWZdvgVCgDCJuvBO5ZPqZ4pWNeInWBAoCZiqElYPV+2Tt8vHOyeWpQiHTMOUm+FXOHCvRieyYiFtTCkn61E70ZWI6VAxsyYAbiqYJ48/LmooFAD27Qw5YgWDn2Zi5FEKjWpYtfxVz/QfDbpf85HjUdlmZQsU0fppXwCY38nGzzDZ2jG9sURlcwNgV7bxnYUirFNeEVssMqgQGOLMMvvx2Dm6CoZPpQ4/9ripMYGluHxHk0Open0Khg8M4X0VSfYopwJc4P6SQbKj1B0OdGinIPzyHqFoO3g083DjYYKtD5Cj3LmA+n5gPQIDAQAB\n```\n\n2. 商户自己公私钥\n\n   2.1 公钥\n\n   ```\n   MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAstPGBWAJfHmu3WXWnX2TRM8doL1oDmgmIc0mVLvJyjI937KpCXpE8STz5dWgIGnzuuvhx7iWWbRA33ItzwQD61aatGjWlUA9afyU6mqkWk8X2HogbfnLTo+X7DKVLk+v7fLXxc7PKP3albF9rNs3qdNbwe+6WoOLv6JXgBXgWxGeGNNWIMyI34+f1bnPhw5dhFKkVMBsVTmbI8CFlhUaBy1oW+lF2bviDPn4OPfuhizPg2DKaRKPv8ucnBWrYnSN2jQZWoK72lf8qxl8Musi4sOMzhXWN0mVA0DAr4v9MQccbsmjjm6agyHeYmC+dmP7C9dwjxwvQKfhSNNdAnWpTQIDAQAB\n   ```\n\n   2.2 私钥\n\n   ```\n   MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCy08YFYAl8ea7dZdadfZNEzx2gvWgOaCYhzSZUu8nKMj3fsqkJekTxJPPl1aAgafO66+HHuJZZtEDfci3PBAPrVpq0aNaVQD1p/JTqaqRaTxfYeiBt+ctOj5fsMpUuT6/t8tfFzs8o/dqVsX2s2zep01vB77pag4u/oleAFeBbEZ4Y01YgzIjfj5/Vuc+HDl2EUqRUwGxVOZsjwIWWFRoHLWhb6UXZu+IM+fg49+6GLM+DYMppEo+/y5ycFatidI3aNBlagrvaV/yrGXwy6yLiw4zOFdY3SZUDQMCvi/0xBxxuyaOObpqDId5iYL52Y/sL13CPHC9Ap+FI010CdalNAgMBAAECggEAP+emEC2ttinV75CBDW7evew17kdBdESLu/CQDh+9kOA7dEFoXtau5G4MKsoYmvzB+L5qxPCV6iCcPj2TWTNaIzOjvWzpohR+3e1BWjQZ35v8LYQXKrXljYGLDQFWhmI7wJDTwwCQz1lIT85J1wfP8IRzee6tbcMsoaLmGgO3VVNwp9kkbwODG/d48P33joQ8MT0JUjZUDGQGaRhVLh1GOfJny9rT2CmNIrzNriovwb4Gz4+UFLGNhbPOHZPBS62mnEzm/0Yjhj4V9y9qxt6IygwAs08rjRRY1bwQf1WoHp3bT2k5ueB2QF9b2MXljzC3yloufGkzD/vASp+T6xK4AQKBgQDtZxxLZPzS5YDN18CX1efqkMZGS+ov4y+aXM6W34eRIYeN5PUIkCoRER+G6B47y0b498JYMqgSkDEzy+PfYTIE0evMSnbYpU62chqRQ0k5dOWTScJyuEDdPyQpRv4ECSEyVuV48i1AWTH8AH+PLFj5A55j05rsGNk+OR9PXCt9zQKBgQDA1fxXHdbyGh9hqWyvUE4p9gbwhA2Qq6pkrDM68JcxokNpw9WuGsU4hHeqx4+FvVOqPH9RrfAKHUTB6ADWz47Z5i7+LxPbue///TX81m76V/8soxCMVME1lDmOO6vBOxIvYYP2dVFPT7JGmECbcuY/bghrlWzknN4RewB0MgtZgQKBgFh6SlBLFfLfuA5/b3bnMOT6CftfBavNRwuHtTMDofnT/jpC75O+bv8nW5Gi5smwLAZUCGloj71DYiMExSuWhNbJCdF8myiJC3nxsrca1aqFR56KKd8pjnsmsip0G+2THX0uZ52Y3IaT944M/X11sL81uw1HawC9DhIjpeik2EytAoGAJ/Ir+7/qruxKY+i84vQ3vOmCNoCkbrug6Injcuoz58w9OsOemBpjkHmgcHg2evXlRvaRSVJGz1GQ1LpCsjz80pakVXNbIcE6vkSt0lp5UtK3wX9mBivoejjiU1x5D+Y0tiv1MjDLTyqrO4R+nbUHjUw14lNp41G7jtN0HJ3hTAECgYEAkgtwQMEydeqaJ5VV74B3xeQwa5jLUuoosbRg8qSD8UGHl1+i7k2ttumtv0t4NpMpVjmO/n9WOld3BAvrN3IuO1FVmc9JuNBP9s+vQxeD9wvx0XcB4RKlY7mNAi/J3WQkBJfj1q0hTGtB9ZxWLfqLIv9yDxYPkWoPyJwWxA0ohBA=\n   ```\n\n## QQ \n\n### 1. 获取sid流程\n\n### 2. 前端代码\n\n```js\n<script type=\"application/javascript\" src=\"https://open.mobile.qq.com/sdk/qqapi.js?_bid=152\"></script>\n<script type=\"text/javascript\">\n\tfunction pay(){\n            //验证是否是QQ\n            mqq.device.isMobileQQ(function(result){\n                if(result) {\n                    var isIos = mqq.iOS;\n                    //alert(\"是否是IOS:\" + isIos);\n                    var isAndroid = mqq.android;\n                    //alert(\"是否是Android:\" + isAndroid);\n                    var qqVersion = mqq.QQVersion;\n                    //alert(\"QQVersion:\" + qqVersion);\n                    //唤起QQ钱包\n                    this.callPay()\n                } else {\n                    alert(\"请在手机QQ中打开此页面\");\n                    return false;\n                }\n            });\n        }\n\n        function callPay(){\n            mqq.tenpay.pay({\n                tokenId: \"5Mfd2ffe642c61f498b8c03a4638a04e\",\n            }, function(result, resultCode){\n                if(result == \"Permission denied\") {\n                    alert(\"无权限 \");\n                } else {\n                    alert(result.resultCode);\n                    document.location.href = \"${redirectUrl}\";\n                }\n            });\n        }\n</script>\n```\n\n\n\n## 钱宝相关\n\n```\n测试商户号：848290972306000  \n测试终端号：29002210\n目前配置支付授权目录：http://yangsongxiao.cn/ysf/\n```\n\n![image-20210203155002102](流程\\image-20210203155002102.png)","slug":"工具安装使用/聚合支付拉起流程/流程","published":1,"date":"2021-03-25T01:17:16.425Z","updated":"2021-03-25T01:18:05.968Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmo6tkfs0007t4tkhypp23z1","content":"<h2 id=\"微信jsapi支付\"><a href=\"#微信jsapi支付\" class=\"headerlink\" title=\"微信jsapi支付\"></a>微信jsapi支付</h2><h3 id=\"1-微信获取openid所需配置信息\"><a href=\"#1-微信获取openid所需配置信息\" class=\"headerlink\" title=\"1. 微信获取openid所需配置信息\"></a>1. 微信获取openid所需配置信息</h3><ol>\n<li><p>进入地址：<a href=\"https://mp.weixin.qq.com/cgi-bin/home?t=home/index&token=1709035801&lang=zh_CN\">微信公众号平台</a></p>\n</li>\n<li><p>进入<strong>【开发】</strong>—<strong>【基本设置】</strong>，配置 <strong>开发者密码</strong>、<strong>服务器地址</strong>、<strong>令牌</strong>、<strong>消费加解密秘钥</strong> 相关信息，开发者密码需要自己保存。</p>\n<p><img src=\"/2021/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%5Cimage-20210203152515345.png\" alt=\"image-20210203152515345\"><img src=\"/2021/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%5Cimage-20210203152440553.png\" alt=\"image-20210203152440553\"></p>\n</li>\n<li><p>进入 <strong>【设置】</strong>—<strong>【公众号设置】</strong>，点击<strong>【功能设置】</strong>，配置<strong>网页授权域名</strong>，用于获取<strong>code</strong>和<strong>openid</strong>选项</p>\n<p> <img src=\"/2021/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%5Cimage-20210203153111406.png\" alt=\"image-20210203153111406\"><img src=\"/2021/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%5Cimage-20210203153129592.png\" alt=\"image-20210203153129592\"></p>\n</li>\n<li><p>参考代码如下</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n\n        //获取微信code\n        String REDIRECT_URI=&quot;http://yangsongxiao.cn/Web/Web&quot;;\n        String APPID=&quot;wxafb534aced348cf5&quot;;\n        String SECRET=&quot;1c9d8089a89893fa077a597ef5d35055&quot;;\n        String ACCESS_TOKEN_URL = &quot;https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE#wechat_redirect&quot;;\n        String url = ACCESS_TOKEN_URL.replace(&quot;APPID&quot;, APPID).replace(&quot;STATE&quot;,&quot;1&quot;).replace(&quot;REDIRECT_URI&quot;, REDIRECT_URI );\n        //微信访问这个页面  服务器可以获取到code \n        System.out.println(url);\n\n        //获取openid\n        String CODE=&quot;051pqs100IRy8L10XF300vWp1u1pqs1m&quot;;\n        String url2 = &quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code&quot;;\n        String Get_Openid = url2.replace(&quot;APPID&quot;, APPID).replace(&quot;SECRET&quot;, SECRET).replace(&quot;CODE&quot;, CODE);\n        System.out.println(Get_Openid);\n        String resp = HttpUtil.doGetStr(Get_Openid);\n        JSONObject re = JSONObject.parseObject(resp);\n        String result = re.containsKey(InitConfig.OPEN_ID) ? re.getString(InitConfig.OPEN_ID) : InitConfig.ERR_START + re.getString(InitConfig.ERR_MSG);\n        System.out.println(result);\n\n    &#125;</code></pre>\n</li>\n<li><p><a href=\"https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html\">微信获取openid方式参考链接</a></p>\n</li>\n<li><p><a href=\"https://pay.weixin.qq.com/index.php\">微信商户平台地址</a></p>\n</li>\n</ol>\n<h3 id=\"2-前后端拉起\"><a href=\"#2-前后端拉起\" class=\"headerlink\" title=\"2. 前后端拉起\"></a>2. 前后端拉起</h3><ol>\n<li><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_4.shtml\">JSAPI 调起支付参考链接</a></li>\n<li><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_3.shtml\">微信JSAPI开发指引</a></li>\n</ol>\n<h3 id=\"3-注意\"><a href=\"#3-注意\" class=\"headerlink\" title=\"3. 注意\"></a>3. 注意</h3><p>​    <strong>需要配置支付授权目录!!!  由于目前使用钱宝appid下单，所用授权目录地址为钱宝配置。</strong></p>\n<h2 id=\"微信小程序支付相关\"><a href=\"#微信小程序支付相关\" class=\"headerlink\" title=\"微信小程序支付相关\"></a>微信小程序支付相关</h2><blockquote>\n<p>目前仅知，需要钱宝下单的appid登录小程序开发工具，或者把我方小程序开发人员，拉入到下单appid的项目组中，借用其资质开发一个小程序可用。</p>\n</blockquote>\n<h2 id=\"支付宝相关\"><a href=\"#支付宝相关\" class=\"headerlink\" title=\"支付宝相关\"></a>支付宝相关</h2><h3 id=\"1-支付宝获取userid方法\"><a href=\"#1-支付宝获取userid方法\" class=\"headerlink\" title=\"1. 支付宝获取userid方法\"></a>1. 支付宝获取userid方法</h3><ol>\n<li><p>登录<a href=\"https://openhome.alipay.com/platform/home.htm\">支付宝开放平台</a></p>\n<pre><code>账号:  yhtdpay@163.com\n密码:  chen1992*+\n手机号绑定人：陈华材</code></pre>\n</li>\n<li><p>创建一个<strong>【应用】</strong>，进入<strong>【应用】</strong><img src=\"/2021/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%5Cimage-20210203162313099.png\" alt=\"image-20210203162313099\"></p>\n</li>\n<li><p>点击<strong>【设置】</strong>按钮，配置<strong>【接口加签方式】</strong>（用于获取openid时加签验签操作）、<strong>【授权回调地址】</strong>（用来获取openid信息）</p>\n<p><img src=\"/2021/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%5Cimage-20210203162712582.png\" alt=\"image-20210203162712582\"></p>\n<p><img src=\"/2021/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%5Cimage-20210203163036267.png\" alt=\"image-20210203163036267\"></p>\n</li>\n<li><p><a href=\"https://opendocs.alipay.com/isv/10467/xldcyq\">获取userid参考链接</a></p>\n<p><a href=\"https://opensupport.alipay.com/support/helpcenter/207/201602471154?ant_source=manual&recommend=ab2418594aa12994227b51f38a16d735\">支付宝官方公私钥配置参考链接</a></p>\n</li>\n<li><p>参考代码</p>\n<pre><code class=\"java\">        //获取zfb appid\n        String appid=&quot;2021001156603164&quot;;\n        //进行url转码\n        String returnurl=&quot;http%3a%2f%2fyangsongxiao.cn%2fWeb%2fWeb&quot;;\n        String url=&quot;https://openauth.alipay.com/oauth2/appToAppAuth.htm?app_id=&quot;+appid+&quot;&amp;redirect_uri=&quot;+returnurl;\n        //支付宝访问这个地址，点击授权  服务器获取 app_id 和 app_auth_code\n        System.out.println(url);\n        String app_id=&quot;2021001156603164&quot;;\n        String app_auth_code=&quot;06ff73b078c24a24bc720b038ec77B74&quot;;\n\n        //支付宝公钥\n        String alipay_public_key=&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAshrxiMZappfjphxroVLUWNFErcuC22OlsWZdvgVCgDCJuvBO5ZPqZ4pWNeInWBAoCZiqElYPV+2Tt8vHOyeWpQiHTMOUm+FXOHCvRieyYiFtTCkn61E70ZWI6VAxsyYAbiqYJ48/LmooFAD27Qw5YgWDn2Zi5FEKjWpYtfxVz/QfDbpf85HjUdlmZQsU0fppXwCY38nGzzDZ2jG9sURlcwNgV7bxnYUirFNeEVssMqgQGOLMMvvx2Dm6CoZPpQ4/9ripMYGluHxHk0Open0Khg8M4X0VSfYopwJc4P6SQbKj1B0OdGinIPzyHqFoO3g083DjYYKtD5Cj3LmA+n5gPQIDAQAB&quot;;\n\n        String app_private_key=&quot;&quot;;\n\n        //获取AppAuthToken\n        AlipayClient alipayClient= new DefaultAlipayClient( &quot;https://openapi.alipay.com/gateway.do&quot; ,  app_id , app_private_key , &quot;json&quot; ,  &quot;GBK&quot; ,  alipay_public_key , &quot;RSA2&quot; );\n        AlipayOpenAuthTokenAppRequest request = new AlipayOpenAuthTokenAppRequest ();\n        request.setBizContent (\n                &quot;&#123;&quot;   + &quot;\\&quot;grant_type\\&quot;:\\&quot;authorization_code\\&quot;,&quot;   +\n                        &quot;\\&quot;code\\&quot;:\\&quot;&quot;+app_auth_code+&quot;\\&quot;&quot; +\n                &quot;&#125;&quot;\n        );\n        AlipayOpenAuthTokenAppResponse response = alipayClient.execute ( request );\n        System.out.println(response.getAppAuthToken());</code></pre>\n</li>\n</ol>\n<h3 id=\"2-支付宝拉起支付\"><a href=\"#2-支付宝拉起支付\" class=\"headerlink\" title=\"2. 支付宝拉起支付\"></a>2. 支付宝拉起支付</h3><ol>\n<li><p><a href=\"https://opendocs.alipay.com/open/common/105591\">支付宝老方式前端拉起支付链接</a></p>\n<pre><code class=\"html\">&lt;p id=&quot;result&quot;&gt;result: &lt;/p&gt;\n&lt;script type=&quot;application/javascript&quot;&gt;\n    // 调试时可以通过在页面定义一个元素，打印信息，使用alert方法不够优雅\n    function log(obj) &#123;\n        $(&quot;#result&quot;).append(obj).append(&quot; &quot;).append(&quot;&lt;br /&gt;&quot;);\n    &#125;\n\n    $(document).ready(function()&#123;\n        // 页面载入完成后即唤起收银台\n        // 此处$&#123;tradeNO&#125;为模板语言语法，实际调用样例类似为tradePpay(&quot;2016072621001004200000000752&quot;)\n         tradePay(&quot;$&#123;tradeNO&#125;&quot;); \n\n         // 点击payButton按钮后唤起收银台\n         $(&quot;#payButton&quot;).click(function() &#123;\n            tradePay(&quot;$&#123;tradeNO&#125;&quot;);\n         &#125;);\n\n         // 通过jsapi关闭当前窗口，仅供参考，更多jsapi请访问\n         // /aod/54/104510\n         $(&quot;#closeButton&quot;).click(function() &#123;\n            AlipayJSBridge.call(&#39;closeWebview&#39;);\n         &#125;);\n     &#125;);\n\n    // 由于js的载入是异步的，所以可以通过该方法，当AlipayJSBridgeReady事件发生后，再执行callback方法\n     function ready(callback) &#123;\n         if (window.AlipayJSBridge) &#123;\n             callback &amp;&amp; callback();\n         &#125; else &#123;\n             document.addEventListener(&#39;AlipayJSBridgeReady&#39;, callback, false);\n         &#125;\n     &#125;\n\n     function tradePay(tradeNO) &#123;\n        ready(function()&#123;\n             // 通过传入交易号唤起快捷调用方式(注意tradeNO大小写严格)\n             AlipayJSBridge.call(&quot;tradePay&quot;, &#123;\ntradeNO: tradeNO\n             &#125;, function (data) &#123;\n                 log(JSON.stringify(data));\n                 if (&quot;9000&quot; == data.resultCode) &#123;\n                     log(&quot;支付成功&quot;);\n                 &#125;\n             &#125;);\n        &#125;);\n    &#125;\n&lt;/script&gt;</code></pre>\n</li>\n<li><p><a href=\"https://myjsapi.alipay.com/alipayjsapi/util/pay/tradePay.html\">支付宝新版拉起支付参考链接</a></p>\n<pre><code class=\"js\">&lt;script src=&quot;https://gw.alipayobjects.com/as/g/h5-lib/alipayjsapi/3.1.1/alipayjsapi.inc.min.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    window.onload = function () &#123;\n    /* 支付宝 */\n    var btn = document.querySelector(&#39;#J_btn&#39;);\n    btn.addEventListener(&#39;click&#39;, function()&#123;\n        alert(&quot;支付&quot;)\n        ap.tradePay(&#123;\n            tradeNO: &#39;2021020322001430791435578886&#39;,\n        &#125;, function(res)&#123;\n            ap.alert(res.resultCode);\n        &#125;);\n    &#125;);\n&lt;/script&gt;</code></pre>\n</li>\n</ol>\n<h3 id=\"3-支付宝秘钥相关\"><a href=\"#3-支付宝秘钥相关\" class=\"headerlink\" title=\"3. 支付宝秘钥相关\"></a>3. 支付宝秘钥相关</h3><ol>\n<li>支付宝平台公钥</li>\n</ol>\n<pre><code>MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAshrxiMZappfjphxroVLUWNFErcuC22OlsWZdvgVCgDCJuvBO5ZPqZ4pWNeInWBAoCZiqElYPV+2Tt8vHOyeWpQiHTMOUm+FXOHCvRieyYiFtTCkn61E70ZWI6VAxsyYAbiqYJ48/LmooFAD27Qw5YgWDn2Zi5FEKjWpYtfxVz/QfDbpf85HjUdlmZQsU0fppXwCY38nGzzDZ2jG9sURlcwNgV7bxnYUirFNeEVssMqgQGOLMMvvx2Dm6CoZPpQ4/9ripMYGluHxHk0Open0Khg8M4X0VSfYopwJc4P6SQbKj1B0OdGinIPzyHqFoO3g083DjYYKtD5Cj3LmA+n5gPQIDAQAB</code></pre>\n<ol start=\"2\">\n<li><p>商户自己公私钥</p>\n<p>2.1 公钥</p>\n<pre><code>MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAstPGBWAJfHmu3WXWnX2TRM8doL1oDmgmIc0mVLvJyjI937KpCXpE8STz5dWgIGnzuuvhx7iWWbRA33ItzwQD61aatGjWlUA9afyU6mqkWk8X2HogbfnLTo+X7DKVLk+v7fLXxc7PKP3albF9rNs3qdNbwe+6WoOLv6JXgBXgWxGeGNNWIMyI34+f1bnPhw5dhFKkVMBsVTmbI8CFlhUaBy1oW+lF2bviDPn4OPfuhizPg2DKaRKPv8ucnBWrYnSN2jQZWoK72lf8qxl8Musi4sOMzhXWN0mVA0DAr4v9MQccbsmjjm6agyHeYmC+dmP7C9dwjxwvQKfhSNNdAnWpTQIDAQAB</code></pre>\n<p>2.2 私钥</p>\n<pre><code>MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCy08YFYAl8ea7dZdadfZNEzx2gvWgOaCYhzSZUu8nKMj3fsqkJekTxJPPl1aAgafO66+HHuJZZtEDfci3PBAPrVpq0aNaVQD1p/JTqaqRaTxfYeiBt+ctOj5fsMpUuT6/t8tfFzs8o/dqVsX2s2zep01vB77pag4u/oleAFeBbEZ4Y01YgzIjfj5/Vuc+HDl2EUqRUwGxVOZsjwIWWFRoHLWhb6UXZu+IM+fg49+6GLM+DYMppEo+/y5ycFatidI3aNBlagrvaV/yrGXwy6yLiw4zOFdY3SZUDQMCvi/0xBxxuyaOObpqDId5iYL52Y/sL13CPHC9Ap+FI010CdalNAgMBAAECggEAP+emEC2ttinV75CBDW7evew17kdBdESLu/CQDh+9kOA7dEFoXtau5G4MKsoYmvzB+L5qxPCV6iCcPj2TWTNaIzOjvWzpohR+3e1BWjQZ35v8LYQXKrXljYGLDQFWhmI7wJDTwwCQz1lIT85J1wfP8IRzee6tbcMsoaLmGgO3VVNwp9kkbwODG/d48P33joQ8MT0JUjZUDGQGaRhVLh1GOfJny9rT2CmNIrzNriovwb4Gz4+UFLGNhbPOHZPBS62mnEzm/0Yjhj4V9y9qxt6IygwAs08rjRRY1bwQf1WoHp3bT2k5ueB2QF9b2MXljzC3yloufGkzD/vASp+T6xK4AQKBgQDtZxxLZPzS5YDN18CX1efqkMZGS+ov4y+aXM6W34eRIYeN5PUIkCoRER+G6B47y0b498JYMqgSkDEzy+PfYTIE0evMSnbYpU62chqRQ0k5dOWTScJyuEDdPyQpRv4ECSEyVuV48i1AWTH8AH+PLFj5A55j05rsGNk+OR9PXCt9zQKBgQDA1fxXHdbyGh9hqWyvUE4p9gbwhA2Qq6pkrDM68JcxokNpw9WuGsU4hHeqx4+FvVOqPH9RrfAKHUTB6ADWz47Z5i7+LxPbue///TX81m76V/8soxCMVME1lDmOO6vBOxIvYYP2dVFPT7JGmECbcuY/bghrlWzknN4RewB0MgtZgQKBgFh6SlBLFfLfuA5/b3bnMOT6CftfBavNRwuHtTMDofnT/jpC75O+bv8nW5Gi5smwLAZUCGloj71DYiMExSuWhNbJCdF8myiJC3nxsrca1aqFR56KKd8pjnsmsip0G+2THX0uZ52Y3IaT944M/X11sL81uw1HawC9DhIjpeik2EytAoGAJ/Ir+7/qruxKY+i84vQ3vOmCNoCkbrug6Injcuoz58w9OsOemBpjkHmgcHg2evXlRvaRSVJGz1GQ1LpCsjz80pakVXNbIcE6vkSt0lp5UtK3wX9mBivoejjiU1x5D+Y0tiv1MjDLTyqrO4R+nbUHjUw14lNp41G7jtN0HJ3hTAECgYEAkgtwQMEydeqaJ5VV74B3xeQwa5jLUuoosbRg8qSD8UGHl1+i7k2ttumtv0t4NpMpVjmO/n9WOld3BAvrN3IuO1FVmc9JuNBP9s+vQxeD9wvx0XcB4RKlY7mNAi/J3WQkBJfj1q0hTGtB9ZxWLfqLIv9yDxYPkWoPyJwWxA0ohBA=</code></pre>\n</li>\n</ol>\n<h2 id=\"QQ\"><a href=\"#QQ\" class=\"headerlink\" title=\"QQ\"></a>QQ</h2><h3 id=\"1-获取sid流程\"><a href=\"#1-获取sid流程\" class=\"headerlink\" title=\"1. 获取sid流程\"></a>1. 获取sid流程</h3><h3 id=\"2-前端代码\"><a href=\"#2-前端代码\" class=\"headerlink\" title=\"2. 前端代码\"></a>2. 前端代码</h3><pre><code class=\"js\">&lt;script type=&quot;application/javascript&quot; src=&quot;https://open.mobile.qq.com/sdk/qqapi.js?_bid=152&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    function pay()&#123;\n            //验证是否是QQ\n            mqq.device.isMobileQQ(function(result)&#123;\n                if(result) &#123;\n                    var isIos = mqq.iOS;\n                    //alert(&quot;是否是IOS:&quot; + isIos);\n                    var isAndroid = mqq.android;\n                    //alert(&quot;是否是Android:&quot; + isAndroid);\n                    var qqVersion = mqq.QQVersion;\n                    //alert(&quot;QQVersion:&quot; + qqVersion);\n                    //唤起QQ钱包\n                    this.callPay()\n                &#125; else &#123;\n                    alert(&quot;请在手机QQ中打开此页面&quot;);\n                    return false;\n                &#125;\n            &#125;);\n        &#125;\n\n        function callPay()&#123;\n            mqq.tenpay.pay(&#123;\n                tokenId: &quot;5Mfd2ffe642c61f498b8c03a4638a04e&quot;,\n            &#125;, function(result, resultCode)&#123;\n                if(result == &quot;Permission denied&quot;) &#123;\n                    alert(&quot;无权限 &quot;);\n                &#125; else &#123;\n                    alert(result.resultCode);\n                    document.location.href = &quot;$&#123;redirectUrl&#125;&quot;;\n                &#125;\n            &#125;);\n        &#125;\n&lt;/script&gt;</code></pre>\n<h2 id=\"钱宝相关\"><a href=\"#钱宝相关\" class=\"headerlink\" title=\"钱宝相关\"></a>钱宝相关</h2><pre><code>测试商户号：848290972306000  \n测试终端号：29002210\n目前配置支付授权目录：http://yangsongxiao.cn/ysf/</code></pre>\n<p><img src=\"/2021/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%5Cimage-20210203155002102.png\" alt=\"image-20210203155002102\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"微信jsapi支付\"><a href=\"#微信jsapi支付\" class=\"headerlink\" title=\"微信jsapi支付\"></a>微信jsapi支付</h2><h3 id=\"1-微信获取openid所需配置信息\"><a href=\"#1-微信获取openid所需配置信息\" class=\"headerlink\" title=\"1. 微信获取openid所需配置信息\"></a>1. 微信获取openid所需配置信息</h3><ol>\n<li><p>进入地址：<a href=\"https://mp.weixin.qq.com/cgi-bin/home?t=home/index&token=1709035801&lang=zh_CN\">微信公众号平台</a></p>\n</li>\n<li><p>进入<strong>【开发】</strong>—<strong>【基本设置】</strong>，配置 <strong>开发者密码</strong>、<strong>服务器地址</strong>、<strong>令牌</strong>、<strong>消费加解密秘钥</strong> 相关信息，开发者密码需要自己保存。</p>\n<p><img src=\"/2021/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%5Cimage-20210203152515345.png\" alt=\"image-20210203152515345\"><img src=\"/2021/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%5Cimage-20210203152440553.png\" alt=\"image-20210203152440553\"></p>\n</li>\n<li><p>进入 <strong>【设置】</strong>—<strong>【公众号设置】</strong>，点击<strong>【功能设置】</strong>，配置<strong>网页授权域名</strong>，用于获取<strong>code</strong>和<strong>openid</strong>选项</p>\n<p> <img src=\"/2021/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%5Cimage-20210203153111406.png\" alt=\"image-20210203153111406\"><img src=\"/2021/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%5Cimage-20210203153129592.png\" alt=\"image-20210203153129592\"></p>\n</li>\n<li><p>参考代码如下</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n\n        //获取微信code\n        String REDIRECT_URI=&quot;http://yangsongxiao.cn/Web/Web&quot;;\n        String APPID=&quot;wxafb534aced348cf5&quot;;\n        String SECRET=&quot;1c9d8089a89893fa077a597ef5d35055&quot;;\n        String ACCESS_TOKEN_URL = &quot;https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE#wechat_redirect&quot;;\n        String url = ACCESS_TOKEN_URL.replace(&quot;APPID&quot;, APPID).replace(&quot;STATE&quot;,&quot;1&quot;).replace(&quot;REDIRECT_URI&quot;, REDIRECT_URI );\n        //微信访问这个页面  服务器可以获取到code \n        System.out.println(url);\n\n        //获取openid\n        String CODE=&quot;051pqs100IRy8L10XF300vWp1u1pqs1m&quot;;\n        String url2 = &quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code&quot;;\n        String Get_Openid = url2.replace(&quot;APPID&quot;, APPID).replace(&quot;SECRET&quot;, SECRET).replace(&quot;CODE&quot;, CODE);\n        System.out.println(Get_Openid);\n        String resp = HttpUtil.doGetStr(Get_Openid);\n        JSONObject re = JSONObject.parseObject(resp);\n        String result = re.containsKey(InitConfig.OPEN_ID) ? re.getString(InitConfig.OPEN_ID) : InitConfig.ERR_START + re.getString(InitConfig.ERR_MSG);\n        System.out.println(result);\n\n    &#125;</code></pre>\n</li>\n<li><p><a href=\"https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html\">微信获取openid方式参考链接</a></p>\n</li>\n<li><p><a href=\"https://pay.weixin.qq.com/index.php\">微信商户平台地址</a></p>\n</li>\n</ol>\n<h3 id=\"2-前后端拉起\"><a href=\"#2-前后端拉起\" class=\"headerlink\" title=\"2. 前后端拉起\"></a>2. 前后端拉起</h3><ol>\n<li><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_4.shtml\">JSAPI 调起支付参考链接</a></li>\n<li><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_3.shtml\">微信JSAPI开发指引</a></li>\n</ol>\n<h3 id=\"3-注意\"><a href=\"#3-注意\" class=\"headerlink\" title=\"3. 注意\"></a>3. 注意</h3><p>​    <strong>需要配置支付授权目录!!!  由于目前使用钱宝appid下单，所用授权目录地址为钱宝配置。</strong></p>\n<h2 id=\"微信小程序支付相关\"><a href=\"#微信小程序支付相关\" class=\"headerlink\" title=\"微信小程序支付相关\"></a>微信小程序支付相关</h2><blockquote>\n<p>目前仅知，需要钱宝下单的appid登录小程序开发工具，或者把我方小程序开发人员，拉入到下单appid的项目组中，借用其资质开发一个小程序可用。</p>\n</blockquote>\n<h2 id=\"支付宝相关\"><a href=\"#支付宝相关\" class=\"headerlink\" title=\"支付宝相关\"></a>支付宝相关</h2><h3 id=\"1-支付宝获取userid方法\"><a href=\"#1-支付宝获取userid方法\" class=\"headerlink\" title=\"1. 支付宝获取userid方法\"></a>1. 支付宝获取userid方法</h3><ol>\n<li><p>登录<a href=\"https://openhome.alipay.com/platform/home.htm\">支付宝开放平台</a></p>\n<pre><code>账号:  yhtdpay@163.com\n密码:  chen1992*+\n手机号绑定人：陈华材</code></pre>\n</li>\n<li><p>创建一个<strong>【应用】</strong>，进入<strong>【应用】</strong><img src=\"/2021/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%5Cimage-20210203162313099.png\" alt=\"image-20210203162313099\"></p>\n</li>\n<li><p>点击<strong>【设置】</strong>按钮，配置<strong>【接口加签方式】</strong>（用于获取openid时加签验签操作）、<strong>【授权回调地址】</strong>（用来获取openid信息）</p>\n<p><img src=\"/2021/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%5Cimage-20210203162712582.png\" alt=\"image-20210203162712582\"></p>\n<p><img src=\"/2021/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%5Cimage-20210203163036267.png\" alt=\"image-20210203163036267\"></p>\n</li>\n<li><p><a href=\"https://opendocs.alipay.com/isv/10467/xldcyq\">获取userid参考链接</a></p>\n<p><a href=\"https://opensupport.alipay.com/support/helpcenter/207/201602471154?ant_source=manual&recommend=ab2418594aa12994227b51f38a16d735\">支付宝官方公私钥配置参考链接</a></p>\n</li>\n<li><p>参考代码</p>\n<pre><code class=\"java\">        //获取zfb appid\n        String appid=&quot;2021001156603164&quot;;\n        //进行url转码\n        String returnurl=&quot;http%3a%2f%2fyangsongxiao.cn%2fWeb%2fWeb&quot;;\n        String url=&quot;https://openauth.alipay.com/oauth2/appToAppAuth.htm?app_id=&quot;+appid+&quot;&amp;redirect_uri=&quot;+returnurl;\n        //支付宝访问这个地址，点击授权  服务器获取 app_id 和 app_auth_code\n        System.out.println(url);\n        String app_id=&quot;2021001156603164&quot;;\n        String app_auth_code=&quot;06ff73b078c24a24bc720b038ec77B74&quot;;\n\n        //支付宝公钥\n        String alipay_public_key=&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAshrxiMZappfjphxroVLUWNFErcuC22OlsWZdvgVCgDCJuvBO5ZPqZ4pWNeInWBAoCZiqElYPV+2Tt8vHOyeWpQiHTMOUm+FXOHCvRieyYiFtTCkn61E70ZWI6VAxsyYAbiqYJ48/LmooFAD27Qw5YgWDn2Zi5FEKjWpYtfxVz/QfDbpf85HjUdlmZQsU0fppXwCY38nGzzDZ2jG9sURlcwNgV7bxnYUirFNeEVssMqgQGOLMMvvx2Dm6CoZPpQ4/9ripMYGluHxHk0Open0Khg8M4X0VSfYopwJc4P6SQbKj1B0OdGinIPzyHqFoO3g083DjYYKtD5Cj3LmA+n5gPQIDAQAB&quot;;\n\n        String app_private_key=&quot;&quot;;\n\n        //获取AppAuthToken\n        AlipayClient alipayClient= new DefaultAlipayClient( &quot;https://openapi.alipay.com/gateway.do&quot; ,  app_id , app_private_key , &quot;json&quot; ,  &quot;GBK&quot; ,  alipay_public_key , &quot;RSA2&quot; );\n        AlipayOpenAuthTokenAppRequest request = new AlipayOpenAuthTokenAppRequest ();\n        request.setBizContent (\n                &quot;&#123;&quot;   + &quot;\\&quot;grant_type\\&quot;:\\&quot;authorization_code\\&quot;,&quot;   +\n                        &quot;\\&quot;code\\&quot;:\\&quot;&quot;+app_auth_code+&quot;\\&quot;&quot; +\n                &quot;&#125;&quot;\n        );\n        AlipayOpenAuthTokenAppResponse response = alipayClient.execute ( request );\n        System.out.println(response.getAppAuthToken());</code></pre>\n</li>\n</ol>\n<h3 id=\"2-支付宝拉起支付\"><a href=\"#2-支付宝拉起支付\" class=\"headerlink\" title=\"2. 支付宝拉起支付\"></a>2. 支付宝拉起支付</h3><ol>\n<li><p><a href=\"https://opendocs.alipay.com/open/common/105591\">支付宝老方式前端拉起支付链接</a></p>\n<pre><code class=\"html\">&lt;p id=&quot;result&quot;&gt;result: &lt;/p&gt;\n&lt;script type=&quot;application/javascript&quot;&gt;\n    // 调试时可以通过在页面定义一个元素，打印信息，使用alert方法不够优雅\n    function log(obj) &#123;\n        $(&quot;#result&quot;).append(obj).append(&quot; &quot;).append(&quot;&lt;br /&gt;&quot;);\n    &#125;\n\n    $(document).ready(function()&#123;\n        // 页面载入完成后即唤起收银台\n        // 此处$&#123;tradeNO&#125;为模板语言语法，实际调用样例类似为tradePpay(&quot;2016072621001004200000000752&quot;)\n         tradePay(&quot;$&#123;tradeNO&#125;&quot;); \n\n         // 点击payButton按钮后唤起收银台\n         $(&quot;#payButton&quot;).click(function() &#123;\n            tradePay(&quot;$&#123;tradeNO&#125;&quot;);\n         &#125;);\n\n         // 通过jsapi关闭当前窗口，仅供参考，更多jsapi请访问\n         // /aod/54/104510\n         $(&quot;#closeButton&quot;).click(function() &#123;\n            AlipayJSBridge.call(&#39;closeWebview&#39;);\n         &#125;);\n     &#125;);\n\n    // 由于js的载入是异步的，所以可以通过该方法，当AlipayJSBridgeReady事件发生后，再执行callback方法\n     function ready(callback) &#123;\n         if (window.AlipayJSBridge) &#123;\n             callback &amp;&amp; callback();\n         &#125; else &#123;\n             document.addEventListener(&#39;AlipayJSBridgeReady&#39;, callback, false);\n         &#125;\n     &#125;\n\n     function tradePay(tradeNO) &#123;\n        ready(function()&#123;\n             // 通过传入交易号唤起快捷调用方式(注意tradeNO大小写严格)\n             AlipayJSBridge.call(&quot;tradePay&quot;, &#123;\ntradeNO: tradeNO\n             &#125;, function (data) &#123;\n                 log(JSON.stringify(data));\n                 if (&quot;9000&quot; == data.resultCode) &#123;\n                     log(&quot;支付成功&quot;);\n                 &#125;\n             &#125;);\n        &#125;);\n    &#125;\n&lt;/script&gt;</code></pre>\n</li>\n<li><p><a href=\"https://myjsapi.alipay.com/alipayjsapi/util/pay/tradePay.html\">支付宝新版拉起支付参考链接</a></p>\n<pre><code class=\"js\">&lt;script src=&quot;https://gw.alipayobjects.com/as/g/h5-lib/alipayjsapi/3.1.1/alipayjsapi.inc.min.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    window.onload = function () &#123;\n    /* 支付宝 */\n    var btn = document.querySelector(&#39;#J_btn&#39;);\n    btn.addEventListener(&#39;click&#39;, function()&#123;\n        alert(&quot;支付&quot;)\n        ap.tradePay(&#123;\n            tradeNO: &#39;2021020322001430791435578886&#39;,\n        &#125;, function(res)&#123;\n            ap.alert(res.resultCode);\n        &#125;);\n    &#125;);\n&lt;/script&gt;</code></pre>\n</li>\n</ol>\n<h3 id=\"3-支付宝秘钥相关\"><a href=\"#3-支付宝秘钥相关\" class=\"headerlink\" title=\"3. 支付宝秘钥相关\"></a>3. 支付宝秘钥相关</h3><ol>\n<li>支付宝平台公钥</li>\n</ol>\n<pre><code>MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAshrxiMZappfjphxroVLUWNFErcuC22OlsWZdvgVCgDCJuvBO5ZPqZ4pWNeInWBAoCZiqElYPV+2Tt8vHOyeWpQiHTMOUm+FXOHCvRieyYiFtTCkn61E70ZWI6VAxsyYAbiqYJ48/LmooFAD27Qw5YgWDn2Zi5FEKjWpYtfxVz/QfDbpf85HjUdlmZQsU0fppXwCY38nGzzDZ2jG9sURlcwNgV7bxnYUirFNeEVssMqgQGOLMMvvx2Dm6CoZPpQ4/9ripMYGluHxHk0Open0Khg8M4X0VSfYopwJc4P6SQbKj1B0OdGinIPzyHqFoO3g083DjYYKtD5Cj3LmA+n5gPQIDAQAB</code></pre>\n<ol start=\"2\">\n<li><p>商户自己公私钥</p>\n<p>2.1 公钥</p>\n<pre><code>MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAstPGBWAJfHmu3WXWnX2TRM8doL1oDmgmIc0mVLvJyjI937KpCXpE8STz5dWgIGnzuuvhx7iWWbRA33ItzwQD61aatGjWlUA9afyU6mqkWk8X2HogbfnLTo+X7DKVLk+v7fLXxc7PKP3albF9rNs3qdNbwe+6WoOLv6JXgBXgWxGeGNNWIMyI34+f1bnPhw5dhFKkVMBsVTmbI8CFlhUaBy1oW+lF2bviDPn4OPfuhizPg2DKaRKPv8ucnBWrYnSN2jQZWoK72lf8qxl8Musi4sOMzhXWN0mVA0DAr4v9MQccbsmjjm6agyHeYmC+dmP7C9dwjxwvQKfhSNNdAnWpTQIDAQAB</code></pre>\n<p>2.2 私钥</p>\n<pre><code>MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCy08YFYAl8ea7dZdadfZNEzx2gvWgOaCYhzSZUu8nKMj3fsqkJekTxJPPl1aAgafO66+HHuJZZtEDfci3PBAPrVpq0aNaVQD1p/JTqaqRaTxfYeiBt+ctOj5fsMpUuT6/t8tfFzs8o/dqVsX2s2zep01vB77pag4u/oleAFeBbEZ4Y01YgzIjfj5/Vuc+HDl2EUqRUwGxVOZsjwIWWFRoHLWhb6UXZu+IM+fg49+6GLM+DYMppEo+/y5ycFatidI3aNBlagrvaV/yrGXwy6yLiw4zOFdY3SZUDQMCvi/0xBxxuyaOObpqDId5iYL52Y/sL13CPHC9Ap+FI010CdalNAgMBAAECggEAP+emEC2ttinV75CBDW7evew17kdBdESLu/CQDh+9kOA7dEFoXtau5G4MKsoYmvzB+L5qxPCV6iCcPj2TWTNaIzOjvWzpohR+3e1BWjQZ35v8LYQXKrXljYGLDQFWhmI7wJDTwwCQz1lIT85J1wfP8IRzee6tbcMsoaLmGgO3VVNwp9kkbwODG/d48P33joQ8MT0JUjZUDGQGaRhVLh1GOfJny9rT2CmNIrzNriovwb4Gz4+UFLGNhbPOHZPBS62mnEzm/0Yjhj4V9y9qxt6IygwAs08rjRRY1bwQf1WoHp3bT2k5ueB2QF9b2MXljzC3yloufGkzD/vASp+T6xK4AQKBgQDtZxxLZPzS5YDN18CX1efqkMZGS+ov4y+aXM6W34eRIYeN5PUIkCoRER+G6B47y0b498JYMqgSkDEzy+PfYTIE0evMSnbYpU62chqRQ0k5dOWTScJyuEDdPyQpRv4ECSEyVuV48i1AWTH8AH+PLFj5A55j05rsGNk+OR9PXCt9zQKBgQDA1fxXHdbyGh9hqWyvUE4p9gbwhA2Qq6pkrDM68JcxokNpw9WuGsU4hHeqx4+FvVOqPH9RrfAKHUTB6ADWz47Z5i7+LxPbue///TX81m76V/8soxCMVME1lDmOO6vBOxIvYYP2dVFPT7JGmECbcuY/bghrlWzknN4RewB0MgtZgQKBgFh6SlBLFfLfuA5/b3bnMOT6CftfBavNRwuHtTMDofnT/jpC75O+bv8nW5Gi5smwLAZUCGloj71DYiMExSuWhNbJCdF8myiJC3nxsrca1aqFR56KKd8pjnsmsip0G+2THX0uZ52Y3IaT944M/X11sL81uw1HawC9DhIjpeik2EytAoGAJ/Ir+7/qruxKY+i84vQ3vOmCNoCkbrug6Injcuoz58w9OsOemBpjkHmgcHg2evXlRvaRSVJGz1GQ1LpCsjz80pakVXNbIcE6vkSt0lp5UtK3wX9mBivoejjiU1x5D+Y0tiv1MjDLTyqrO4R+nbUHjUw14lNp41G7jtN0HJ3hTAECgYEAkgtwQMEydeqaJ5VV74B3xeQwa5jLUuoosbRg8qSD8UGHl1+i7k2ttumtv0t4NpMpVjmO/n9WOld3BAvrN3IuO1FVmc9JuNBP9s+vQxeD9wvx0XcB4RKlY7mNAi/J3WQkBJfj1q0hTGtB9ZxWLfqLIv9yDxYPkWoPyJwWxA0ohBA=</code></pre>\n</li>\n</ol>\n<h2 id=\"QQ\"><a href=\"#QQ\" class=\"headerlink\" title=\"QQ\"></a>QQ</h2><h3 id=\"1-获取sid流程\"><a href=\"#1-获取sid流程\" class=\"headerlink\" title=\"1. 获取sid流程\"></a>1. 获取sid流程</h3><h3 id=\"2-前端代码\"><a href=\"#2-前端代码\" class=\"headerlink\" title=\"2. 前端代码\"></a>2. 前端代码</h3><pre><code class=\"js\">&lt;script type=&quot;application/javascript&quot; src=&quot;https://open.mobile.qq.com/sdk/qqapi.js?_bid=152&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    function pay()&#123;\n            //验证是否是QQ\n            mqq.device.isMobileQQ(function(result)&#123;\n                if(result) &#123;\n                    var isIos = mqq.iOS;\n                    //alert(&quot;是否是IOS:&quot; + isIos);\n                    var isAndroid = mqq.android;\n                    //alert(&quot;是否是Android:&quot; + isAndroid);\n                    var qqVersion = mqq.QQVersion;\n                    //alert(&quot;QQVersion:&quot; + qqVersion);\n                    //唤起QQ钱包\n                    this.callPay()\n                &#125; else &#123;\n                    alert(&quot;请在手机QQ中打开此页面&quot;);\n                    return false;\n                &#125;\n            &#125;);\n        &#125;\n\n        function callPay()&#123;\n            mqq.tenpay.pay(&#123;\n                tokenId: &quot;5Mfd2ffe642c61f498b8c03a4638a04e&quot;,\n            &#125;, function(result, resultCode)&#123;\n                if(result == &quot;Permission denied&quot;) &#123;\n                    alert(&quot;无权限 &quot;);\n                &#125; else &#123;\n                    alert(result.resultCode);\n                    document.location.href = &quot;$&#123;redirectUrl&#125;&quot;;\n                &#125;\n            &#125;);\n        &#125;\n&lt;/script&gt;</code></pre>\n<h2 id=\"钱宝相关\"><a href=\"#钱宝相关\" class=\"headerlink\" title=\"钱宝相关\"></a>钱宝相关</h2><pre><code>测试商户号：848290972306000  \n测试终端号：29002210\n目前配置支付授权目录：http://yangsongxiao.cn/ysf/</code></pre>\n<p><img src=\"/2021/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B/%E6%B5%81%E7%A8%8B%5Cimage-20210203155002102.png\" alt=\"image-20210203155002102\"></p>\n"}],"PostAsset":[{"_id":"source/_posts/并发/悲观锁与乐观锁/1.jpg","slug":"1.jpg","post":"ckgk92amv0001agtkacmb2l9r","modified":0,"renderable":0},{"_id":"source/_posts/并发/悲观锁与乐观锁/2.jpg","slug":"2.jpg","post":"ckgk92amv0001agtkacmb2l9r","modified":0,"renderable":0},{"_id":"source/_posts/并发/悲观锁与乐观锁/3.png","slug":"3.png","post":"ckgk92amv0001agtkacmb2l9r","modified":0,"renderable":0},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/1266638-20180711104523327-1846448145.png","slug":"1266638-20180711104523327-1846448145.png","post":"ckh2sbz180000actk8oc87qaf","modified":0,"renderable":0},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/aa18972bd40735fa901e88768e0966b60d2408f4.jpeg","slug":"aa18972bd40735fa901e88768e0966b60d2408f4.jpeg","post":"ckh2sbz180000actk8oc87qaf","modified":0,"renderable":0},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/image-20201104094518290.png","slug":"image-20201104094518290.png","post":"ckh2sbz180000actk8oc87qaf","modified":0,"renderable":0},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/JVM运行时数据区域.png","slug":"JVM运行时数据区域.png","post":"ckh2sbz180000actk8oc87qaf","modified":0,"renderable":0},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/进程.png","slug":"进程.png","post":"ckh2sbz180000actk8oc87qaf","modified":0,"renderable":0},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/2019-4死锁1.png","slug":"2019-4死锁1.png","post":"ckh2sbz180000actk8oc87qaf","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203152440553.png","slug":"image-20210203152440553.png","post":"ckmo6tkfs0007t4tkhypp23z1","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203152515345.png","slug":"image-20210203152515345.png","post":"ckmo6tkfs0007t4tkhypp23z1","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203153111406.png","slug":"image-20210203153111406.png","post":"ckmo6tkfs0007t4tkhypp23z1","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203153129592.png","slug":"image-20210203153129592.png","post":"ckmo6tkfs0007t4tkhypp23z1","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203155002102.png","slug":"image-20210203155002102.png","post":"ckmo6tkfs0007t4tkhypp23z1","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203162313099.png","slug":"image-20210203162313099.png","post":"ckmo6tkfs0007t4tkhypp23z1","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203162451622.png","slug":"image-20210203162451622.png","post":"ckmo6tkfs0007t4tkhypp23z1","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203162535500.png","slug":"image-20210203162535500.png","post":"ckmo6tkfs0007t4tkhypp23z1","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203162538492.png","slug":"image-20210203162538492.png","post":"ckmo6tkfs0007t4tkhypp23z1","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203162645487.png","slug":"image-20210203162645487.png","post":"ckmo6tkfs0007t4tkhypp23z1","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203162712582.png","slug":"image-20210203162712582.png","post":"ckmo6tkfs0007t4tkhypp23z1","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/流程/image-20210203163036267.png","slug":"image-20210203163036267.png","post":"ckmo6tkfs0007t4tkhypp23z1","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckgk92amv0001agtkacmb2l9r","category_id":"ckgk92amw0002agtkho3b1why","_id":"ckgk92an1000bagtke5f0hrob"},{"post_id":"ckgk92amy0004agtk5vescng3","category_id":"ckgk92an00007agtk9d97af1j","_id":"ckgk92an2000eagtkctgt6crr"},{"post_id":"ckgsoyer10000i8tk8v1j60s9","category_id":"ckgsoyer30001i8tkh1ms43k1","_id":"ckgsoyer60004i8tkbtgi7pi5"},{"post_id":"ckgspvfc10000c0tkgfz1box0","category_id":"ckgspxgm10005c0tkh11ggy47","_id":"ckgspxgm20008c0tk8yj55up8"},{"post_id":"ckh2sbz180000actk8oc87qaf","category_id":"ckgk92amw0002agtkho3b1why","_id":"ckh2sbz1e0002actk7dgihvvn"},{"post_id":"cklujq23m00003gtk8r611y3b","category_id":"ckgk92an00007agtk9d97af1j","_id":"cklujq23q00023gtke6rh7kah"},{"post_id":"cklvnf25f0000estk0n08e9z7","category_id":"ckgspxgm10005c0tkh11ggy47","_id":"cklvnf25k0002estk517o38jk"},{"post_id":"ckmo6tkfl0000t4tk7bv1768m","category_id":"ckmo6tkfo0001t4tkhr8qh9kd","_id":"ckmo6tkfr0004t4tk0pqf0o8o"}],"PostTag":[{"post_id":"ckgk92amv0001agtkacmb2l9r","tag_id":"ckgk92amx0003agtk970kd8is","_id":"ckgk92an3000gagtkbgfffe78"},{"post_id":"ckgk92amv0001agtkacmb2l9r","tag_id":"ckgk92amz0006agtk3esjaimf","_id":"ckgk92an3000hagtk11orcbkv"},{"post_id":"ckgk92amy0004agtk5vescng3","tag_id":"ckgk92an2000fagtk3hje2t8f","_id":"ckgk92an4000kagtk70ga3gei"},{"post_id":"ckgk92amy0004agtk5vescng3","tag_id":"ckgk92an3000iagtkgimf5cns","_id":"ckgk92an4000lagtkears9anw"},{"post_id":"ckgk92amy0004agtk5vescng3","tag_id":"ckgk92an3000jagtkhxop8fu7","_id":"ckgk92an4000magtk8e1r5t56"},{"post_id":"ckgsoyer10000i8tk8v1j60s9","tag_id":"ckgsoyer50002i8tk1xg36c9e","_id":"ckgsoyer60006i8tk510i9oh3"},{"post_id":"ckgsoyer10000i8tk8v1j60s9","tag_id":"ckgsoyer50003i8tkb0xubbyd","_id":"ckgsoyer60007i8tkf1a17y1p"},{"post_id":"ckgsoyer10000i8tk8v1j60s9","tag_id":"ckgsoyer60005i8tka2cf1g0n","_id":"ckgsoyer70008i8tkez9o4q7p"},{"post_id":"ckgspvfc10000c0tkgfz1box0","tag_id":"ckgspxgm10006c0tk9ki4deto","_id":"ckgspxgm20009c0tk1kaw7x46"},{"post_id":"ckgspvfc10000c0tkgfz1box0","tag_id":"ckgspxgm20007c0tkg1595kr8","_id":"ckgspxgm2000ac0tk5n9favna"},{"post_id":"ckh2sbz180000actk8oc87qaf","tag_id":"ckgk92amx0003agtk970kd8is","_id":"ckh2sbz1e0003actk4a3g6lka"},{"post_id":"ckh2sbz180000actk8oc87qaf","tag_id":"ckgk92amz0006agtk3esjaimf","_id":"ckh2sbz1e0004actkalya4doh"},{"post_id":"ckh2sbz180000actk8oc87qaf","tag_id":"ckh2sbz1c0001actk9z7hetwv","_id":"ckh2sbz1e0005actk3yg48bk9"},{"post_id":"cklujq23m00003gtk8r611y3b","tag_id":"cklujq23o00013gtk89aa52hw","_id":"cklujq23q00053gtk7r8m9u5v"},{"post_id":"cklujq23m00003gtk8r611y3b","tag_id":"cklujq23q00033gtkdi7sd6do","_id":"cklujq23q00063gtka5zg58xn"},{"post_id":"cklujq23m00003gtk8r611y3b","tag_id":"cklujq23q00043gtkh8dz16gl","_id":"cklujq23r00073gtk50yxgl8y"},{"post_id":"cklvnf25f0000estk0n08e9z7","tag_id":"cklvnf25i0001estk9fcdaoj2","_id":"cklvnf25l0004estk4tgia696"},{"post_id":"cklvnf25f0000estk0n08e9z7","tag_id":"cklvnf25k0003estkcic86228","_id":"cklvnf25l0005estk6l8r44gn"},{"post_id":"ckmo6tkfl0000t4tk7bv1768m","tag_id":"ckmo6tkfq0002t4tk5v531ip8","_id":"ckmo6tkfs0005t4tk6kqn7dub"},{"post_id":"ckmo6tkfl0000t4tk7bv1768m","tag_id":"ckmo6tkfr0003t4tk80pq3jb6","_id":"ckmo6tkfs0006t4tkbdzydgkm"}],"Tag":[{"name":"锁机制","_id":"ckgk92amx0003agtk970kd8is"},{"name":"并发","_id":"ckgk92amz0006agtk3esjaimf"},{"name":"运维","_id":"ckgk92an2000fagtk3hje2t8f"},{"name":"tag2","_id":"ckgk92an3000iagtkgimf5cns"},{"name":"tag3","_id":"ckgk92an3000jagtkhxop8fu7"},{"name":"Comparable","_id":"ckgsoyer50002i8tk1xg36c9e"},{"name":"Comparator","_id":"ckgsoyer50003i8tkb0xubbyd"},{"name":"排序","_id":"ckgsoyer60005i8tka2cf1g0n"},{"name":"hexo","_id":"ckgspxgm10006c0tk9ki4deto"},{"name":"博客","_id":"ckgspxgm20007c0tkg1595kr8"},{"name":"死锁","_id":"ckh2sbz1c0001actk9z7hetwv"},{"name":"sql","_id":"cklujq23o00013gtk89aa52hw"},{"name":"oracle","_id":"cklujq23q00033gtkdi7sd6do"},{"name":"函数","_id":"cklujq23q00043gtkh8dz16gl"},{"name":"pfx","_id":"cklvnf25i0001estk9fcdaoj2"},{"name":"cer","_id":"cklvnf25k0003estkcic86228"},{"name":"按位与","_id":"ckmo6tkfq0002t4tk5v531ip8"},{"name":"位运算","_id":"ckmo6tkfr0003t4tk80pq3jb6"}]}}