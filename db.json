{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-3-hexo-master/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/mobile.styl","path":"css/mobile.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/img/article-list-background.jpeg","path":"img/article-list-background.jpeg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/img/gov.png","path":"img/gov.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/img/head.jpg","path":"img/head.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/img/school-book.png","path":"img/school-book.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/img/weixin.jpg","path":"img/weixin.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/js/gitalk.js","path":"js/gitalk.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/js/iconfont.js","path":"js/iconfont.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/js/titleTip.js","path":"js/titleTip.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/iconfont.woff2","path":"css/fonts/iconfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":0,"renderable":1},{"_id":"source/img/1.jpg","path":"img/1.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/hexo-theme-3-hexo-master/.DS_Store","hash":"0770f9d42bfdd8d420de48fed463015e001cf579","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/.gitignore","hash":"86a50fa08e69cab561892aa5edef24f9081bbde1","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/LICENSE","hash":"b04140c5f682db2b300428f97bb164fd7f5f18bd","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/README.md","hash":"d2c42534ceabcb7cd2e58ed994bf7d6f734d1f3b","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/_config.yml","hash":"801a22709ee7d5799d2e62652f544af51832685e","modified":1619059377333},{"_id":"themes/hexo-theme-3-hexo-master/.idea/hexo-theme-3-hexo-master.iml","hash":"c7c4a216364e1a90dc9ebf19e4c967f26c4f8e52","modified":1616654231383},{"_id":"themes/hexo-theme-3-hexo-master/.idea/misc.xml","hash":"0d81a7654b3ab7b1fa88a882ac9120820be781d1","modified":1616654231402},{"_id":"themes/hexo-theme-3-hexo-master/.idea/modules.xml","hash":"4b77412c15acd5cd4c6343da0526914c83739ed1","modified":1616654231409},{"_id":"themes/hexo-theme-3-hexo-master/.idea/vcs.xml","hash":"c75f6a9f73d6a593959bbeeb5c8d00a5d919408c","modified":1616654231397},{"_id":"themes/hexo-theme-3-hexo-master/.idea/workspace.xml","hash":"b1f950ebe1eae6f145f33b4a3c230a63b2fcd901","modified":1616655476006},{"_id":"themes/hexo-theme-3-hexo-master/languages/en.yml","hash":"53ae29ae1237fc7822df85a6d2f8da6f0078625e","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/languages/zh-CN.yml","hash":"d2c6d86fe2ff03e6ee9bbc16dff8efe5b47ac297","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/index.ejs","hash":"27ea3dac053d501b79bbef5117b4f3aff063d8cd","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/indexs.md","hash":"20ca23533b31cde7c4b1082096d9ec47dda45d4e","modified":1619059339495},{"_id":"themes/hexo-theme-3-hexo-master/layout/post.ejs","hash":"4abd16c0f5e3f51103d23b73710d695dc7fdc5d2","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/.DS_Store","hash":"fdcc907c46e093a14b153c5dc8c038461997ed3c","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/article.ejs","hash":"516844c4a0e13d6773f6029849f51c59613b6f69","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/article_copyright.ejs","hash":"0ebb17d001cb7bb7606c616c380049a2e7124496","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/comment.ejs","hash":"5507b4dfab2032345e012a0c5356f63b01395157","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/copyright.ejs","hash":"ab41aa9c0e883d40526dd47e132b30a42a96a0e5","modified":1616655101032},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/dashang.ejs","hash":"bc94eee27701b67d238f328737b578e8270989eb","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/footer.ejs","hash":"ed479aa9affee3b02a76da06de45a7c40a97a706","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/friends.ejs","hash":"d11092791e5c140ff81f2aefa0d1b051f403239d","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/full-toc.ejs","hash":"a734c26d86da6697003ed27672c1b9b82b216c82","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/header.ejs","hash":"d0b84370ca81c3baa02a05613ff040003acd2985","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/mathjax.ejs","hash":"c2e5cef2377884cd79e5f686fe4f74b082744306","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/meta.ejs","hash":"8a9e93f9cbe80763264018290da0b14b4bbe8ac5","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/nav-left.ejs","hash":"e1bb54edfa0f666f829afa839fbb24c22bc17757","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/nav-right.ejs","hash":"3f9d91215ff36a6bcdaaf86e5b028dafc5a6a6fc","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/tag.ejs","hash":"3cf8ba0c6112dfa8089603b8df3e31f70a272715","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/toc-ref.ejs","hash":"6406251dabda66ef686d4c15edbc3061b6d828b8","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/mobile.styl","hash":"59a4abd36cc8ff2107f1fcb3c0fe48d0492c9030","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/style.styl","hash":"7090b81f34e26172670c68da6a366ca186523779","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/img/gov.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/js/script.js","hash":"350221b03ef3976cf276a0c16288a10c9e99d964","modified":1616655187305},{"_id":"themes/hexo-theme-3-hexo-master/source/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/js/titleTip.js","hash":"81dca549063e29ba3a4a278f0f4388eba8a2167b","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/comments/click2show.ejs","hash":"fa6675230f8c313236604e26926b142f4f418bdd","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/comments/disqus.ejs","hash":"cd0022ce7e6d6efb07a00e87477cdf791f7f6703","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/comments/gitalk.ejs","hash":"fbd3c7d72c8354d700918390c6cbfc0a11408277","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/comments/gitment.ejs","hash":"f16442568b43d034faaa8e3507f5ae8da34c7b72","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/comments/livere.ejs","hash":"e820aa16b5ed4e024616b5e2d424925820d43e56","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/layout/_partial/comments/utteranc.ejs","hash":"c76773b96860940083baf16470b7b80ac098e645","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/_partial/comment.styl","hash":"2a9b5ffb759be85545a89f6d1194579a800f51a5","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/_partial/dashang.styl","hash":"f6447a2ac407228e1d53e3455db2919ac0e9f094","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/_partial/fade.styl","hash":"4f687cbc74caf8a0887f5e89250284a9bce8b5c1","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/_partial/font.styl","hash":"422a48be8d25901b32e4e1362bb6f79b79f6f105","modified":1619059893897},{"_id":"themes/hexo-theme-3-hexo-master/source/css/_partial/full-toc.styl","hash":"0143711c1221cb4e70a3db866754d79c8a81d253","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/_partial/nav-left.styl","hash":"6089a3eca47dd7c9582a21050efde8d697f935d5","modified":1619059750668},{"_id":"themes/hexo-theme-3-hexo-master/source/css/_partial/nav-right.styl","hash":"e3c30d618d9e1b7a6a3274cff2ca42f054e99ddd","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/_partial/nprogress.styl","hash":"65efbddd23a264e7d1e85f4073228526770e833c","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/_partial/num-load.styl","hash":"4b996440bba8ec755aa70bc6d074d7dbba55ec0c","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/_partial/post.styl","hash":"0dd8d208081b92e05d6db3361743c520a2816828","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/iconfont.eot","hash":"b14b8624988ff069aff3145f88c0d7ac49052bd3","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/iconfont.svg","hash":"13974fe35fca836e870a960ecb11b7eca2e036f8","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/iconfont.ttf","hash":"140829ecf12d30c6e18d8dc6dc0c188a66addd25","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/iconfont.woff","hash":"0d2d4559f1ac4fa801eb8cc099fa5bf9dcf955ef","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/iconfont.woff2","hash":"b0317a0b2ebb1181a8bf5a97d03556dd54538645","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/fonts/selection.json","hash":"57c7f100019d57b512aab509185cb0a6eb9aa4c8","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/atom-light.styl","hash":"553987211d3323a7dfc0b08786b183a3435978c9","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/css/hl_theme/zenbum.styl","hash":"933a3b196d01254dea5e6f48105ea15e210ae000","modified":1596983030000},{"_id":"themes/hexo-theme-3-hexo-master/source/img/alipay.jpg","hash":"f73febcf19fc0b57e9f9cf073af0f91ee65339ac","modified":1616654351529},{"_id":"themes/hexo-theme-3-hexo-master/source/img/head.jpg","hash":"e1772f083c71160a2f78bce1f3ad8d3b88826dc0","modified":1616655014824},{"_id":"themes/hexo-theme-3-hexo-master/source/img/weixin.jpg","hash":"feaecd1608cd9b3bd6f11888c40190620ae099f3","modified":1616654420213},{"_id":"themes/hexo-theme-3-hexo-master/source/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1596983030000},{"_id":"source/img/1.jpg","hash":"af43d741cabeb3bc39b4ed687d4b26fcd32aced9","modified":1603334267937},{"_id":"source/_posts/netty/netty分包粘包问题.md","hash":"6f03a0d3bd4e449e51425c2411e763b3b1a52ddd","modified":1617177491297},{"_id":"source/_posts/并发/Java并发基础常见面试题总结.md","hash":"6b21cb48d4be80db2beb372f3c594cbc55b77985","modified":1606097954453},{"_id":"source/_posts/并发/悲观锁与乐观锁.md","hash":"98de30bee00eb1d9ee89d3a7cb92b84e75895d80","modified":1616655244608},{"_id":"source/_posts/算法学习/动态规划.md","hash":"974c83608aec2f4c270d6cab3571b122954102ae","modified":1618387468961},{"_id":"source/_posts/面试相关/面试题总结.md","hash":"4b63da16d66bb57d1a7b58fb0f12e6bec777a7c4","modified":1618986923654},{"_id":"source/_posts/java学习/JNA/使用c、c++方法.md","hash":"a3678bb5eabe0d8d504e786c51d385e4e0c221f6","modified":1618975936918},{"_id":"source/_posts/java学习/位运算/位运算.md","hash":"cf37f94eda20b901fa0d49e1cdfe840de9fbf28a","modified":1616655368882},{"_id":"source/_posts/java学习/工具包学习/Comparable与Comparator.md","hash":"7706ca789aa16f52cab2e04fb8c6eea9e26bd92f","modified":1617158317797},{"_id":"source/_posts/java学习/并发编程实战/并发编程实战.md","hash":"0b278f48cdf9a9ec57fa75c5c28ca84cf0af1fae","modified":1618975889599},{"_id":"source/_posts/java学习/性能优化/tomcat优化.emmx","hash":"5a9549fe29b544ec199c93ec61e0d06482fd3bd9","modified":1617246958109},{"_id":"source/_posts/netty/netty/image-20210331151558717.png","hash":"4f0c96333c56a639a55ea6458b8dca7e9911651f","modified":1617174958738},{"_id":"source/_posts/netty/netty/image-20210331152602573.png","hash":"5176cbf0e89c286968a96a5923e24509e455cd41","modified":1617175562596},{"_id":"source/_posts/工具安装使用/hexo/hexo搭建静态博客.md","hash":"a186ac6ae5b685825b850f0b3058bfcc3707363d","modified":1618973582149},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程.md","hash":"2eee57893d0c64faa1350e72d683f3dfc3312e47","modified":1618975869783},{"_id":"source/_posts/工具安装使用/证书/证书转换.md","hash":"0ddfa7b9d089606277e89737c0aacf5b0c526f60","modified":1614845217269},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/1266638-20180711104523327-1846448145.png","hash":"58d69f763006d5d0b849d2218dcbb3de33eaca25","modified":1604453307010},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/2019-4死锁1.png","hash":"f63036ff0143e102534f0d1ce048060550b1dd59","modified":1606092994209},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/image-20201104094518290.png","hash":"0cd61c362b6d15708a12782788a4be46acce4403","modified":1604454318298},{"_id":"source/_posts/并发/悲观锁与乐观锁/1.jpg","hash":"af43d741cabeb3bc39b4ed687d4b26fcd32aced9","modified":1603334267937},{"_id":"source/_posts/并发/悲观锁与乐观锁/2.jpg","hash":"ff8b670c49ffa31a77e86d7e9352ea12a81f932d","modified":1603337163487},{"_id":"source/_posts/并发/悲观锁与乐观锁/3.png","hash":"b8fd91642354dffc1e98f5eb9ea2bd6e4d27b8fa","modified":1603338905854},{"_id":"source/_posts/数据库操作/oracle/oracle 误删数据、表的恢复.md","hash":"03f667162ea4bce162d994fc90250952d2e63657","modified":1608173338217},{"_id":"source/_posts/数据库操作/oracle/oracle基础语法.md","hash":"44ecf6ab7c4d112b54e8ff335812993ac915f3be","modified":1608255999628},{"_id":"source/_posts/java学习/JNA/使用c、c++方法/image-20210409171943084.png","hash":"0b0aad8eb035a55b98037b0fd3827b26aa6e14b7","modified":1617959983117},{"_id":"source/_posts/java学习/JNA/使用c、c++方法/image-20210409173144363.png","hash":"9fac614c32536bc01cf6fa3aa1da4ee86864d707","modified":1617960704398},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203152440553.png","hash":"e8f95e2d1dcab08ac7a4fc0e73e31e9dff26c717","modified":1612337080577},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203152515345.png","hash":"09e330644c71af9e78329785aaf54a396d661a41","modified":1612337115349},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203153129592.png","hash":"244032c6dd4eaef751952bb68689d83a48670bb4","modified":1612337489611},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203153111406.png","hash":"125f84d4ad3b6fca1e75479452badbf6f897da56","modified":1612337471409},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203155002102.png","hash":"57e0191c1d8496bb74432eaab811cf47adcd9dee","modified":1612338602121},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162313099.png","hash":"ebe93141ad2771656f32cdb97eebaefb7f5f4fb7","modified":1612340593135},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162451622.png","hash":"4a762cf85e3cc28a232092af08626e371fa80379","modified":1612340691642},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162535500.png","hash":"4a762cf85e3cc28a232092af08626e371fa80379","modified":1612340735519},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162538492.png","hash":"4a762cf85e3cc28a232092af08626e371fa80379","modified":1612340738512},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162645487.png","hash":"6b7c1786db83304463f95cabed86e95a734b2d22","modified":1612340805518},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162712582.png","hash":"60cde1b555bcae1077ab9740d08efe4905b790af","modified":1612340832605},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203163036267.png","hash":"33ef70255b94a9f7b676c91aedc8d88dd7e8b604","modified":1612341036290},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210421105700214.png","hash":"b1968612cb237d2763d3779ac1dfa0fb99a8c49a","modified":1618973820246},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210421112937615.png","hash":"1060384860ce30a1c8acc1b7f1a22cb0f67857c1","modified":1618975777628},{"_id":"source/_posts/netty/netty/image-20210331153715016.png","hash":"75f8931bfc53b7a5fde81ab8aa09ddd4c2b843cf","modified":1617176235050},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/aa18972bd40735fa901e88768e0966b60d2408f4.jpeg","hash":"dbe756a54c16d40e0e12ad5766c84be9e7a8eac7","modified":1604453081444},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/进程.png","hash":"7177eef6438ff01a1f4b7b804cb64012df3a74d9","modified":1604370020549},{"_id":"source/_posts/java学习/工具包学习/Comparable与Comparator/image-20210331103835480.png","hash":"9e330d163b4e788cbb4f7f2e21e23f3230eef9df","modified":1617158315543},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210421112632294.png","hash":"94a7ad6de752085a2bc854e47582e3ca14f36486","modified":1618975592334},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/JVM运行时数据区域.png","hash":"ad04409d1de7cdbb01b3fc6a8b7368ef80f5d80b","modified":1604369676808},{"_id":"themes/hexo-theme-3-hexo-master/source/js/gitalk.js","hash":"a75ead28e6a1fab2a006cc7332ca2d2e868ce8e1","modified":1596983030000},{"_id":"source/_posts/java学习/JNA/使用c、c++方法/ZT_DEV.dll","hash":"35272f2560ad015d9fed9d94d77212878fbebcd1","modified":1588235053376},{"_id":"public/content.json","hash":"2ffa9e2f8d67ec2e5fe0f3b519efa53497c2e3a7","modified":1619060309789},{"_id":"public/search.xml","hash":"d87bb911b19036d8ea2116271e646b05f78a4026","modified":1619060309789},{"_id":"public/sitemap.xml","hash":"2b949d9ca2e9cefb39416b088f35146de4f2e1d3","modified":1619060309789},{"_id":"public/atom.xml","hash":"d67222fb43e5c310852b5db5ab6a0f233b0cc6db","modified":1619060309789},{"_id":"public/2021/04/21/面试相关/面试题总结/index.html","hash":"e4f39c0ac6e7ba4e9a937296fe8303fefcfee214","modified":1619060309789},{"_id":"public/2021/04/19/java学习/并发编程实战/并发编程实战/index.html","hash":"d770b6bd2d49860e1d8b5185a60499ec466d947b","modified":1619060309789},{"_id":"public/2021/04/14/算法学习/动态规划/index.html","hash":"ee222720e8f150e3a1de578297a43a1d87e4b589","modified":1619060309789},{"_id":"public/2021/04/09/java学习/JNA/使用c、c++方法/index.html","hash":"0acfaf092e67668bbe3d042e5534ac0dd6fae218","modified":1619060309789},{"_id":"public/2021/03/30/netty/netty分包粘包问题/index.html","hash":"e926c12ffac1e10e204570d8905115e7543c28df","modified":1619060309789},{"_id":"public/2021/03/08/java学习/位运算/位运算/index.html","hash":"e3b52182ccb3a8b9849a8000095c7de083d4c63f","modified":1619060309789},{"_id":"public/2020/12/17/数据库操作/oracle/oracle基础语法/index.html","hash":"a7e5da653e572b74cbcdf48fc04eb7849caa6c7d","modified":1619060309789},{"_id":"public/2020/11/03/并发/Java并发基础常见面试题总结/index.html","hash":"6f747ee2d5e4fabb5b6901c9623d0fe6a14af626","modified":1619060309789},{"_id":"public/2020/10/28/工具安装使用/证书/证书转换/index.html","hash":"89e9d7195771ac416657456a2d65a2906505d20b","modified":1619060309789},{"_id":"public/2020/10/28/工具安装使用/hexo/hexo搭建静态博客/index.html","hash":"36cf716171d13861fc12eef0db790c7569d4dd23","modified":1619060309789},{"_id":"public/2020/10/27/java学习/工具包学习/Comparable与Comparator/index.html","hash":"ccef71d01262ed6720458464d9c90cfc771d922b","modified":1619060309789},{"_id":"public/2020/10/21/并发/悲观锁与乐观锁/index.html","hash":"8ab088f4c815e9cbb701232b6b63b374c181b628","modified":1619060309789},{"_id":"public/2020/10/21/数据库操作/oracle/oracle 误删数据、表的恢复/index.html","hash":"b392760e8a0d56a3c9926b3168e5de22165042ea","modified":1619060309789},{"_id":"public/2020/03/25/工具安装使用/聚合支付拉起流程/聚合支付流程/index.html","hash":"2e7fd15eb5083ece21516608896d45b3de3c9806","modified":1619060309789},{"_id":"public/archives/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/archives/page/2/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/archives/2020/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/archives/2020/03/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/archives/2020/10/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/archives/2020/11/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/archives/2020/12/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/archives/2021/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/archives/2021/03/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/archives/2021/04/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/categories/并发/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/categories/算法/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/categories/JAVA/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/categories/工具/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/categories/oracle/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/categories/并发、netty/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/锁机制/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/并发/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/死锁/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/动态规划/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/java/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/面试/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/java调用c-方法/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/JNA/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/按位与/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/位运算/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/Comparable/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/Comparator/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/排序/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/pfx/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/cer/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/hexo/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/博客/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/微信支付/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/支付宝/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/运维/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/tag2/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/tag3/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/锁netty/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/分包粘包/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/sql/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/oracle/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/函数/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/page/2/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1618977222103},{"_id":"public/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1618977222103},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1618977222103},{"_id":"public/img/gov.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1618977222103},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1618977222103},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1618977222103},{"_id":"public/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1618977222103},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1618977222103},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1618977222103},{"_id":"public/css/fonts/iconfont.eot","hash":"b14b8624988ff069aff3145f88c0d7ac49052bd3","modified":1618977222103},{"_id":"public/css/fonts/iconfont.svg","hash":"13974fe35fca836e870a960ecb11b7eca2e036f8","modified":1618977222103},{"_id":"public/css/fonts/iconfont.ttf","hash":"140829ecf12d30c6e18d8dc6dc0c188a66addd25","modified":1618977222103},{"_id":"public/css/fonts/iconfont.woff","hash":"0d2d4559f1ac4fa801eb8cc099fa5bf9dcf955ef","modified":1618977222103},{"_id":"public/css/fonts/iconfont.woff2","hash":"b0317a0b2ebb1181a8bf5a97d03556dd54538645","modified":1618977222103},{"_id":"public/img/1.jpg","hash":"af43d741cabeb3bc39b4ed687d4b26fcd32aced9","modified":1618977222103},{"_id":"public/2020/11/03/并发/Java并发基础常见面试题总结/1266638-20180711104523327-1846448145.png","hash":"58d69f763006d5d0b849d2218dcbb3de33eaca25","modified":1618977222103},{"_id":"public/2020/11/03/并发/Java并发基础常见面试题总结/2019-4死锁1.png","hash":"f63036ff0143e102534f0d1ce048060550b1dd59","modified":1618977222103},{"_id":"public/2020/11/03/并发/Java并发基础常见面试题总结/aa18972bd40735fa901e88768e0966b60d2408f4.jpeg","hash":"dbe756a54c16d40e0e12ad5766c84be9e7a8eac7","modified":1618977222103},{"_id":"public/2020/11/03/并发/Java并发基础常见面试题总结/image-20201104094518290.png","hash":"0cd61c362b6d15708a12782788a4be46acce4403","modified":1618977222103},{"_id":"public/2020/11/03/并发/Java并发基础常见面试题总结/进程.png","hash":"7177eef6438ff01a1f4b7b804cb64012df3a74d9","modified":1618977222103},{"_id":"public/2020/10/21/并发/悲观锁与乐观锁/1.jpg","hash":"af43d741cabeb3bc39b4ed687d4b26fcd32aced9","modified":1618977222103},{"_id":"public/2020/10/21/并发/悲观锁与乐观锁/2.jpg","hash":"ff8b670c49ffa31a77e86d7e9352ea12a81f932d","modified":1618977222103},{"_id":"public/2020/10/21/并发/悲观锁与乐观锁/3.png","hash":"b8fd91642354dffc1e98f5eb9ea2bd6e4d27b8fa","modified":1618977222103},{"_id":"public/2021/04/09/java学习/JNA/使用c、c++方法/image-20210409171943084.png","hash":"0b0aad8eb035a55b98037b0fd3827b26aa6e14b7","modified":1618977222103},{"_id":"public/2021/04/09/java学习/JNA/使用c、c++方法/image-20210409173144363.png","hash":"9fac614c32536bc01cf6fa3aa1da4ee86864d707","modified":1618977222103},{"_id":"public/2020/03/25/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203152440553.png","hash":"e8f95e2d1dcab08ac7a4fc0e73e31e9dff26c717","modified":1618977222103},{"_id":"public/2020/03/25/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203152515345.png","hash":"09e330644c71af9e78329785aaf54a396d661a41","modified":1618977222103},{"_id":"public/2020/03/25/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203153111406.png","hash":"125f84d4ad3b6fca1e75479452badbf6f897da56","modified":1618977222103},{"_id":"public/2020/03/25/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203153129592.png","hash":"244032c6dd4eaef751952bb68689d83a48670bb4","modified":1618977222103},{"_id":"public/2020/03/25/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203155002102.png","hash":"57e0191c1d8496bb74432eaab811cf47adcd9dee","modified":1618977222103},{"_id":"public/2020/03/25/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162313099.png","hash":"ebe93141ad2771656f32cdb97eebaefb7f5f4fb7","modified":1618977222103},{"_id":"public/2020/03/25/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162451622.png","hash":"4a762cf85e3cc28a232092af08626e371fa80379","modified":1618977222103},{"_id":"public/2020/03/25/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162535500.png","hash":"4a762cf85e3cc28a232092af08626e371fa80379","modified":1618977222103},{"_id":"public/2020/03/25/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162538492.png","hash":"4a762cf85e3cc28a232092af08626e371fa80379","modified":1618977222103},{"_id":"public/2020/03/25/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162645487.png","hash":"6b7c1786db83304463f95cabed86e95a734b2d22","modified":1618977222103},{"_id":"public/2020/03/25/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162712582.png","hash":"60cde1b555bcae1077ab9740d08efe4905b790af","modified":1618977222103},{"_id":"public/2020/03/25/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203163036267.png","hash":"33ef70255b94a9f7b676c91aedc8d88dd7e8b604","modified":1618977222103},{"_id":"public/2020/03/25/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210421105700214.png","hash":"b1968612cb237d2763d3779ac1dfa0fb99a8c49a","modified":1618977222103},{"_id":"public/2020/03/25/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210421112937615.png","hash":"1060384860ce30a1c8acc1b7f1a22cb0f67857c1","modified":1618977222103},{"_id":"public/2020/03/25/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210421112632294.png","hash":"94a7ad6de752085a2bc854e47582e3ca14f36486","modified":1618977222103},{"_id":"public/img/head.jpg","hash":"e1772f083c71160a2f78bce1f3ad8d3b88826dc0","modified":1618977222103},{"_id":"public/img/weixin.jpg","hash":"feaecd1608cd9b3bd6f11888c40190620ae099f3","modified":1618977222103},{"_id":"public/2020/11/03/并发/Java并发基础常见面试题总结/JVM运行时数据区域.png","hash":"ad04409d1de7cdbb01b3fc6a8b7368ef80f5d80b","modified":1618977222103},{"_id":"public/2020/10/27/java学习/工具包学习/Comparable与Comparator/image-20210331103835480.png","hash":"9e330d163b4e788cbb4f7f2e21e23f3230eef9df","modified":1618977222103},{"_id":"public/img/alipay.jpg","hash":"f73febcf19fc0b57e9f9cf073af0f91ee65339ac","modified":1618977222103},{"_id":"public/css/mobile.css","hash":"5998f6fc27998596beb1e40e4bc3c43be2ed764c","modified":1618977222103},{"_id":"public/js/titleTip.js","hash":"81dca549063e29ba3a4a278f0f4388eba8a2167b","modified":1618977222103},{"_id":"public/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1618977222103},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1618977222103},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1618977222103},{"_id":"public/css/hl_theme/atom-light.css","hash":"d31edb9816dae6b01410028bceb91757a962f780","modified":1618977222103},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1618977222103},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1618977222103},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1618977222103},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1618977222103},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1618977222103},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1618977222103},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1618977222103},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1618977222103},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1618977222103},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1618977222103},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1618977222103},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1618977222103},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1618977222103},{"_id":"public/css/style.css","hash":"2dc2f3d794d4102d3ce4c807d41903277e4585e7","modified":1618977222103},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1618977222103},{"_id":"public/js/script.js","hash":"350221b03ef3976cf276a0c16288a10c9e99d964","modified":1618977222103},{"_id":"public/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1618977222103},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1618977222103},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1618977222103},{"_id":"public/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1618977222103},{"_id":"public/js/gitalk.js","hash":"a75ead28e6a1fab2a006cc7332ca2d2e868ce8e1","modified":1618977222103},{"_id":"public/2021/04/09/java学习/JNA/使用c、c++方法/ZT_DEV.dll","hash":"35272f2560ad015d9fed9d94d77212878fbebcd1","modified":1618977222103},{"_id":"source/_posts/小程序相关/rsa分段加密（小程序+java后台）.md","hash":"b2902b12da775c5d463a7f2aba5acf4e6a9813cc","modified":1619057028421},{"_id":"source/_posts/小程序相关/悲观锁与乐观锁.md","hash":"8adeb28d61245d2ab0447c1af07e898871e78804","modified":1619057348041},{"_id":"source/_posts/小程序相关/rsa分段加密（小程序+java后台）/rsa分段加密（小程序+java后台）.rar","hash":"23ce0eadbad1a9ca70a53850fb9db1a97541d566","modified":1589371117402},{"_id":"source/_posts/小程序相关/rsa分段加密(小程序+java后台)/rsa分段加密.rar","hash":"23ce0eadbad1a9ca70a53850fb9db1a97541d566","modified":1589371117402},{"_id":"source/_posts/小程序相关/rsa分段加密(小程序+java后台).md","hash":"8f966d586e7750fb85587bf6b8a86e0732b33d50","modified":1619057586236},{"_id":"public/2020/10/21/小程序相关/rsa分段加密(小程序+java后台)/index.html","hash":"59b87563acf4b37d3cbf1a14bd6cc91d940c934e","modified":1619060309789},{"_id":"public/categories/小程序/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/小程序/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789},{"_id":"public/tags/RSA分段/index.html","hash":"5b6631e68c30031c78c288fb586320634d15de69","modified":1619060309789}],"Category":[{"name":"并发","_id":"cknqx8ket0002botkb4wabpg3"},{"name":"算法","_id":"cknqx8key0009botkg6dc5vrg"},{"name":"JAVA","_id":"cknqx8kez000dbotkgrj86bso"},{"name":"工具","_id":"cknqx8kf90019botkh7n44jkh"},{"name":"oracle","_id":"cknqx8kfe001obotke8u3esra"},{"name":"并发、netty","_id":"cknqx8kfe001sbotk91d0aya3"},{"name":"小程序","_id":"ckns930w0000otstkgqlb3kuz"}],"Data":[],"Page":[],"Post":[{"title":"Java 并发基础常见面试题总结","date":"2020-11-03T06:16:33.000Z","description":"常见并发基础面试题总结","_content":"\n# 并发基础\n\n[TOC]\n\n## 1. 什么是线程和进程？\n\n### 1.1 进程\n\n&emsp;进程是程序的一次执行过程，**是操作系统分配资源的最小单位**，因此进程是动态的。\n\n![进程展示图](Java并发基础常见面试题总结/进程.png)\n\n### 1.2 线程\n\n&emsp;线程是程序执行的最小单位，一个进程在其执行的过程中可以产生多个线程。每个线程有自己的<span style=\"font-size:20px;color:red;weight:bold;\">**程序计数器、虚拟机栈、本地方法栈**</span>，多个线程共享进程的<span style=\"font-size:20px;color:red;weight:bold;\">**堆**、**方法区资源**</span>。\n\n![img](Java并发基础常见面试题总结/JVM运行时数据区域.png)\n\n### 1.3 区别\n\n|            | 进程                         | 线程                                                         |\n| ---------- | ---------------------------- | :----------------------------------------------------------- |\n| 概念       | 是操作系统分配资源的最小单位 | 线程是程序执行的最小单位                                     |\n| 组成       | 由一个或多个线程组成         | 仅是线程下的一条执行线路                                     |\n| 资源       | 进程之间相互独立             | 同一进程下，各个线程之前共享程序的内存空间（代码段、数据集、堆等）及一些进程级的资源。执行开销小，不利于资源管理及保护 |\n| 调度与切换 | 慢                           | 线程上下文切换快                                             |\n\n## 2. 线程详解\n\n### 2.1 程序计数器为什么是私有的\n\n&emsp;程序计数器作用：\n\n1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、异常处理\n2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了\n\n&emsp;所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。\n\n### 2.2 虚拟机栈和本地方法栈\n\n![img](Java并发基础常见面试题总结/aa18972bd40735fa901e88768e0966b60d2408f4.jpeg)\n\n#### 2.2.1 虚拟机栈\n\n##### 2.2.1.1 虚拟机栈讲解\n\n　**虚拟机栈是用于描述java方法执行的内存模型。**\n\n&emsp;每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“局部变量表、操作数栈、动态链接、方法出口”几个部分。我们常说的“堆内存、栈内存”中的**“栈内存”指的便是虚拟机栈**，确切地说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。\n\n&emsp;方法调用时，创建栈帧，并压入虚拟机栈；方法执行完毕，栈帧出栈并被销毁，如下图所示：\n\n![img](Java并发基础常见面试题总结/1266638-20180711104523327-1846448145.png)\n\n##### 2.2.1.2 虚拟机栈特点\n\n&emsp;虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈。\n\n##### 2.2.1.3 虚拟机栈的StackOverflowError\n\n&emsp;**单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）。**\n\n&emsp;JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用，代码见下：\n\n```\npublic class JavaVMStackSOF {\n\n    private void add(int c){\n        add(c++);\n    }\n\n    public static void main(String[] args) {\n        try {\n            new JavaVMStackSOF().add(0);\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n}\n```\n\n&emsp;在不断的循环调用，最终超出虚拟机允许的深度，抛出栈溢出错误。\n\n![image-20201104094518290](Java并发基础常见面试题总结/image-20201104094518290.png)\n\n##### 2.2.1.4 虚拟机栈的OutOfMemoryError\n\n&emsp;**OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。**\n\n&emsp;JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常（建议不要尝试，容易把电脑跑蹦）\n\n```\npublic class JavaVMStackOOM {\n\n    public static void main(String[] args) {\n        while(true){\n            new Thread(() -> {\n                while (true){\n\n                }\n            }).start();\n        }\n    }\n}\n```\n\n#### 2.2.2 本地方法栈\n\n&emsp;和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务（例如Thread.start0()）。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。由于native方法不是用Java实现的，而是由C语言实现的，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。\n\n<p style=\"color:red\">&emsp;为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p>\n\n### 2.3 堆\n\n#### 2.3.1 什么是堆\n\n&emsp;堆是用于存放对象的内存区域。因此，他是垃圾收集器（GC）管理的主要目标。\n\n#### 2.3.2 特点\n\n1. 堆在逻辑上划分为**新生代**和**老年代**。由于JAVA中的对象大部分是朝生夕灭，还有一小部分能够长期的驻留在内存中，为了对这两种对象进行最有效的回收，将堆划分为新生代和老年代，并且执行不同的回收策略。不同的垃圾收集器对这2个逻辑区域的回收机制不尽相同，\n2. 堆占用的内存并不要求物理连续，只需要逻辑连续即可。\n3. 堆一般实现成可扩展内存大小，使用“-Xms”与“-Xmx”控制堆的最小与最大内存，扩展动作交由虚拟机执行。但由于该行为比较消耗性能，因此一般将堆的最大最小内存设为相等。\n4. 堆是所有线程共享的内存区域，因此每个线程都可以拿到堆上的同一个对象。\n5. 堆的生命周期是随着虚拟机的启动而创建。\n\n#### 2.3.3 堆异常\n\n&emsp;当堆无法分配对象内存且无法再扩展时，会抛出OutOfMemoryError异常。\n\n```\npublic class HeapOOM {\n\n    static class OOMObject {\n    }\n\n    public static void main(String[] args) {\n        List<OOMObject> list = new ArrayList<>();\n        //不断创建新对象，使得Heap溢出\n        while (true) {\n            list.add(new OOMObject());\n        }\n    }\n\n}\n```\n\n&emsp;述代码中对象不断的被创建而不进行引用释放，导致GC无法回收堆内存，最终OutOfMemoryError，错误信息：\n\n```\njava.lang.OutOfMemoryError: Java heap space\n```\n\n### 2.4 方法区\n\n#### 2.4.1 方法区定义\n\n&emsp;方法区，也称非堆（Non-Heap），是一个被线程共享的内存区域。其中主要存储加载的类字节码、class/method/field等元数据对象、static-final常量、static变量、jit编译器编译后的代码等数据。\n\n&emsp;如果系统定义太多的类，导致方法区溢出。虚拟机同样会抛出内存溢出的错误。方法区可以理解为永久区。\n\n### 2.5 上下文切换\n\n> 当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。\n\n&emsp;多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。\n\n&emsp;上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。\n\n&emsp;Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。\n\n### 2.6 死锁\n\n#### 2.6.1 死锁的定义\n\n&emsp;多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。\n\n![线程死锁示意图 ](Java并发基础常见面试题总结/2019-4死锁1.png)\n\n#### 2.6.2 死锁的条件\n\n1. 互斥条件：该资源任意一个时刻只由一个线程占用。\n2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\n3. 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。\n4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。\n\n#### 2.6.3 如何避免死锁\n\n&emsp;为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。\n\n1. **破坏互斥条件** ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。\n2. **破坏请求与保持条件** ：一次性申请所有的资源。\n3. **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\n4. **破坏循环等待条件** ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\n\n## 3 角料\n\n### 3.1  start() 和run() 方法\n\n&emsp;**调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。**\n\n### 3.2 wait()方法和sleep()方法\n\n|      | **sleep 方法**                                               | **wait 方法**                            |\n| ---- | ------------------------------------------------------------ | ---------------------------------------- |\n| 1    | **没有释放锁**                                               | **释放了锁**                             |\n| 2    | 用于暂停执行                                                 | 用于线程间交互/通信                      |\n| 3    | 被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法 | sleep() 方法执行完成后，线程会自动苏醒。 |\n| 4    | 两者都可以暂停线程的执行。                                   |                                          |\n\n\n\n## 参考链接\n\n\\- [Java 并发基础常见面试题总结](https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=java-%e5%b9%b6%e5%8f%91%e5%9f%ba%e7%a1%80%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98%e6%80%bb%e7%bb%93)\n\n\\- [02-JVM内存模型：虚拟机栈与本地方法栈](https://www.cnblogs.com/manayi/p/9293302.html)\n\n\\- [03-JVM内存模型：堆与方法区](https://www.cnblogs.com/manayi/p/9651500.html)\n\n","source":"_posts/并发/Java并发基础常见面试题总结.md","raw":"---\ntitle: Java 并发基础常见面试题总结 \ndate: 2020-11-03 14:16:33 \ncategories: 并发 #分类\ntags: [锁机制,并发,死锁] \ndescription: 常见并发基础面试题总结\n---\n\n# 并发基础\n\n[TOC]\n\n## 1. 什么是线程和进程？\n\n### 1.1 进程\n\n&emsp;进程是程序的一次执行过程，**是操作系统分配资源的最小单位**，因此进程是动态的。\n\n![进程展示图](Java并发基础常见面试题总结/进程.png)\n\n### 1.2 线程\n\n&emsp;线程是程序执行的最小单位，一个进程在其执行的过程中可以产生多个线程。每个线程有自己的<span style=\"font-size:20px;color:red;weight:bold;\">**程序计数器、虚拟机栈、本地方法栈**</span>，多个线程共享进程的<span style=\"font-size:20px;color:red;weight:bold;\">**堆**、**方法区资源**</span>。\n\n![img](Java并发基础常见面试题总结/JVM运行时数据区域.png)\n\n### 1.3 区别\n\n|            | 进程                         | 线程                                                         |\n| ---------- | ---------------------------- | :----------------------------------------------------------- |\n| 概念       | 是操作系统分配资源的最小单位 | 线程是程序执行的最小单位                                     |\n| 组成       | 由一个或多个线程组成         | 仅是线程下的一条执行线路                                     |\n| 资源       | 进程之间相互独立             | 同一进程下，各个线程之前共享程序的内存空间（代码段、数据集、堆等）及一些进程级的资源。执行开销小，不利于资源管理及保护 |\n| 调度与切换 | 慢                           | 线程上下文切换快                                             |\n\n## 2. 线程详解\n\n### 2.1 程序计数器为什么是私有的\n\n&emsp;程序计数器作用：\n\n1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、异常处理\n2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了\n\n&emsp;所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。\n\n### 2.2 虚拟机栈和本地方法栈\n\n![img](Java并发基础常见面试题总结/aa18972bd40735fa901e88768e0966b60d2408f4.jpeg)\n\n#### 2.2.1 虚拟机栈\n\n##### 2.2.1.1 虚拟机栈讲解\n\n　**虚拟机栈是用于描述java方法执行的内存模型。**\n\n&emsp;每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“局部变量表、操作数栈、动态链接、方法出口”几个部分。我们常说的“堆内存、栈内存”中的**“栈内存”指的便是虚拟机栈**，确切地说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。\n\n&emsp;方法调用时，创建栈帧，并压入虚拟机栈；方法执行完毕，栈帧出栈并被销毁，如下图所示：\n\n![img](Java并发基础常见面试题总结/1266638-20180711104523327-1846448145.png)\n\n##### 2.2.1.2 虚拟机栈特点\n\n&emsp;虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈。\n\n##### 2.2.1.3 虚拟机栈的StackOverflowError\n\n&emsp;**单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）。**\n\n&emsp;JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用，代码见下：\n\n```\npublic class JavaVMStackSOF {\n\n    private void add(int c){\n        add(c++);\n    }\n\n    public static void main(String[] args) {\n        try {\n            new JavaVMStackSOF().add(0);\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n}\n```\n\n&emsp;在不断的循环调用，最终超出虚拟机允许的深度，抛出栈溢出错误。\n\n![image-20201104094518290](Java并发基础常见面试题总结/image-20201104094518290.png)\n\n##### 2.2.1.4 虚拟机栈的OutOfMemoryError\n\n&emsp;**OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。**\n\n&emsp;JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常（建议不要尝试，容易把电脑跑蹦）\n\n```\npublic class JavaVMStackOOM {\n\n    public static void main(String[] args) {\n        while(true){\n            new Thread(() -> {\n                while (true){\n\n                }\n            }).start();\n        }\n    }\n}\n```\n\n#### 2.2.2 本地方法栈\n\n&emsp;和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务（例如Thread.start0()）。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。由于native方法不是用Java实现的，而是由C语言实现的，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。\n\n<p style=\"color:red\">&emsp;为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p>\n\n### 2.3 堆\n\n#### 2.3.1 什么是堆\n\n&emsp;堆是用于存放对象的内存区域。因此，他是垃圾收集器（GC）管理的主要目标。\n\n#### 2.3.2 特点\n\n1. 堆在逻辑上划分为**新生代**和**老年代**。由于JAVA中的对象大部分是朝生夕灭，还有一小部分能够长期的驻留在内存中，为了对这两种对象进行最有效的回收，将堆划分为新生代和老年代，并且执行不同的回收策略。不同的垃圾收集器对这2个逻辑区域的回收机制不尽相同，\n2. 堆占用的内存并不要求物理连续，只需要逻辑连续即可。\n3. 堆一般实现成可扩展内存大小，使用“-Xms”与“-Xmx”控制堆的最小与最大内存，扩展动作交由虚拟机执行。但由于该行为比较消耗性能，因此一般将堆的最大最小内存设为相等。\n4. 堆是所有线程共享的内存区域，因此每个线程都可以拿到堆上的同一个对象。\n5. 堆的生命周期是随着虚拟机的启动而创建。\n\n#### 2.3.3 堆异常\n\n&emsp;当堆无法分配对象内存且无法再扩展时，会抛出OutOfMemoryError异常。\n\n```\npublic class HeapOOM {\n\n    static class OOMObject {\n    }\n\n    public static void main(String[] args) {\n        List<OOMObject> list = new ArrayList<>();\n        //不断创建新对象，使得Heap溢出\n        while (true) {\n            list.add(new OOMObject());\n        }\n    }\n\n}\n```\n\n&emsp;述代码中对象不断的被创建而不进行引用释放，导致GC无法回收堆内存，最终OutOfMemoryError，错误信息：\n\n```\njava.lang.OutOfMemoryError: Java heap space\n```\n\n### 2.4 方法区\n\n#### 2.4.1 方法区定义\n\n&emsp;方法区，也称非堆（Non-Heap），是一个被线程共享的内存区域。其中主要存储加载的类字节码、class/method/field等元数据对象、static-final常量、static变量、jit编译器编译后的代码等数据。\n\n&emsp;如果系统定义太多的类，导致方法区溢出。虚拟机同样会抛出内存溢出的错误。方法区可以理解为永久区。\n\n### 2.5 上下文切换\n\n> 当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。\n\n&emsp;多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。\n\n&emsp;上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。\n\n&emsp;Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。\n\n### 2.6 死锁\n\n#### 2.6.1 死锁的定义\n\n&emsp;多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。\n\n![线程死锁示意图 ](Java并发基础常见面试题总结/2019-4死锁1.png)\n\n#### 2.6.2 死锁的条件\n\n1. 互斥条件：该资源任意一个时刻只由一个线程占用。\n2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\n3. 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。\n4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。\n\n#### 2.6.3 如何避免死锁\n\n&emsp;为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。\n\n1. **破坏互斥条件** ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。\n2. **破坏请求与保持条件** ：一次性申请所有的资源。\n3. **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\n4. **破坏循环等待条件** ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\n\n## 3 角料\n\n### 3.1  start() 和run() 方法\n\n&emsp;**调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。**\n\n### 3.2 wait()方法和sleep()方法\n\n|      | **sleep 方法**                                               | **wait 方法**                            |\n| ---- | ------------------------------------------------------------ | ---------------------------------------- |\n| 1    | **没有释放锁**                                               | **释放了锁**                             |\n| 2    | 用于暂停执行                                                 | 用于线程间交互/通信                      |\n| 3    | 被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法 | sleep() 方法执行完成后，线程会自动苏醒。 |\n| 4    | 两者都可以暂停线程的执行。                                   |                                          |\n\n\n\n## 参考链接\n\n\\- [Java 并发基础常见面试题总结](https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=java-%e5%b9%b6%e5%8f%91%e5%9f%ba%e7%a1%80%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98%e6%80%bb%e7%bb%93)\n\n\\- [02-JVM内存模型：虚拟机栈与本地方法栈](https://www.cnblogs.com/manayi/p/9293302.html)\n\n\\- [03-JVM内存模型：堆与方法区](https://www.cnblogs.com/manayi/p/9651500.html)\n\n","slug":"并发/Java并发基础常见面试题总结","published":1,"updated":"2020-11-23T02:19:14.453Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknqx8keo0000botk8top9vin","content":"<h1 id=\"并发基础\"><a href=\"#并发基础\" class=\"headerlink\" title=\"并发基础\"></a>并发基础</h1><p>[TOC]</p>\n<h2 id=\"1-什么是线程和进程？\"><a href=\"#1-什么是线程和进程？\" class=\"headerlink\" title=\"1. 什么是线程和进程？\"></a>1. 什么是线程和进程？</h2><h3 id=\"1-1-进程\"><a href=\"#1-1-进程\" class=\"headerlink\" title=\"1.1 进程\"></a>1.1 进程</h3><p>&emsp;进程是程序的一次执行过程，<strong>是操作系统分配资源的最小单位</strong>，因此进程是动态的。</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/%E8%BF%9B%E7%A8%8B.png\" alt=\"进程展示图\"></p>\n<h3 id=\"1-2-线程\"><a href=\"#1-2-线程\" class=\"headerlink\" title=\"1.2 线程\"></a>1.2 线程</h3><p>&emsp;线程是程序执行的最小单位，一个进程在其执行的过程中可以产生多个线程。每个线程有自己的<span style=\"font-size:20px;color:red;weight:bold;\"><strong>程序计数器、虚拟机栈、本地方法栈</strong></span>，多个线程共享进程的<span style=\"font-size:20px;color:red;weight:bold;\"><strong>堆</strong>、<strong>方法区资源</strong></span>。</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png\" alt=\"img\"></p>\n<h3 id=\"1-3-区别\"><a href=\"#1-3-区别\" class=\"headerlink\" title=\"1.3 区别\"></a>1.3 区别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>进程</th>\n<th align=\"left\">线程</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>概念</td>\n<td>是操作系统分配资源的最小单位</td>\n<td align=\"left\">线程是程序执行的最小单位</td>\n</tr>\n<tr>\n<td>组成</td>\n<td>由一个或多个线程组成</td>\n<td align=\"left\">仅是线程下的一条执行线路</td>\n</tr>\n<tr>\n<td>资源</td>\n<td>进程之间相互独立</td>\n<td align=\"left\">同一进程下，各个线程之前共享程序的内存空间（代码段、数据集、堆等）及一些进程级的资源。执行开销小，不利于资源管理及保护</td>\n</tr>\n<tr>\n<td>调度与切换</td>\n<td>慢</td>\n<td align=\"left\">线程上下文切换快</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-线程详解\"><a href=\"#2-线程详解\" class=\"headerlink\" title=\"2. 线程详解\"></a>2. 线程详解</h2><h3 id=\"2-1-程序计数器为什么是私有的\"><a href=\"#2-1-程序计数器为什么是私有的\" class=\"headerlink\" title=\"2.1 程序计数器为什么是私有的\"></a>2.1 程序计数器为什么是私有的</h3><p>&emsp;程序计数器作用：</p>\n<ol>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、异常处理</li>\n<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了</li>\n</ol>\n<p>&emsp;所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>\n<h3 id=\"2-2-虚拟机栈和本地方法栈\"><a href=\"#2-2-虚拟机栈和本地方法栈\" class=\"headerlink\" title=\"2.2 虚拟机栈和本地方法栈\"></a>2.2 虚拟机栈和本地方法栈</h3><p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/aa18972bd40735fa901e88768e0966b60d2408f4.jpeg\" alt=\"img\"></p>\n<h4 id=\"2-2-1-虚拟机栈\"><a href=\"#2-2-1-虚拟机栈\" class=\"headerlink\" title=\"2.2.1 虚拟机栈\"></a>2.2.1 虚拟机栈</h4><h5 id=\"2-2-1-1-虚拟机栈讲解\"><a href=\"#2-2-1-1-虚拟机栈讲解\" class=\"headerlink\" title=\"2.2.1.1 虚拟机栈讲解\"></a>2.2.1.1 虚拟机栈讲解</h5><p>　<strong>虚拟机栈是用于描述java方法执行的内存模型。</strong></p>\n<p>&emsp;每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“局部变量表、操作数栈、动态链接、方法出口”几个部分。我们常说的“堆内存、栈内存”中的<strong>“栈内存”指的便是虚拟机栈</strong>，确切地说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。</p>\n<p>&emsp;方法调用时，创建栈帧，并压入虚拟机栈；方法执行完毕，栈帧出栈并被销毁，如下图所示：</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/1266638-20180711104523327-1846448145.png\" alt=\"img\"></p>\n<h5 id=\"2-2-1-2-虚拟机栈特点\"><a href=\"#2-2-1-2-虚拟机栈特点\" class=\"headerlink\" title=\"2.2.1.2 虚拟机栈特点\"></a>2.2.1.2 虚拟机栈特点</h5><p>&emsp;虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈。</p>\n<h5 id=\"2-2-1-3-虚拟机栈的StackOverflowError\"><a href=\"#2-2-1-3-虚拟机栈的StackOverflowError\" class=\"headerlink\" title=\"2.2.1.3 虚拟机栈的StackOverflowError\"></a>2.2.1.3 虚拟机栈的StackOverflowError</h5><p>&emsp;<strong>单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）。</strong></p>\n<p>&emsp;JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用，代码见下：</p>\n<pre><code>public class JavaVMStackSOF &#123;\n\n    private void add(int c)&#123;\n        add(c++);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        try &#123;\n            new JavaVMStackSOF().add(0);\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n<p>&emsp;在不断的循环调用，最终超出虚拟机允许的深度，抛出栈溢出错误。</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20201104094518290.png\" alt=\"image-20201104094518290\"></p>\n<h5 id=\"2-2-1-4-虚拟机栈的OutOfMemoryError\"><a href=\"#2-2-1-4-虚拟机栈的OutOfMemoryError\" class=\"headerlink\" title=\"2.2.1.4 虚拟机栈的OutOfMemoryError\"></a>2.2.1.4 虚拟机栈的OutOfMemoryError</h5><p>&emsp;<strong>OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。</strong></p>\n<p>&emsp;JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常（建议不要尝试，容易把电脑跑蹦）</p>\n<pre><code>public class JavaVMStackOOM &#123;\n\n    public static void main(String[] args) &#123;\n        while(true)&#123;\n            new Thread(() -&gt; &#123;\n                while (true)&#123;\n\n                &#125;\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;</code></pre>\n<h4 id=\"2-2-2-本地方法栈\"><a href=\"#2-2-2-本地方法栈\" class=\"headerlink\" title=\"2.2.2 本地方法栈\"></a>2.2.2 本地方法栈</h4><p>&emsp;和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务（例如Thread.start0()）。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。由于native方法不是用Java实现的，而是由C语言实现的，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。</p>\n<p style=\"color:red\">&emsp;为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p>\n\n<h3 id=\"2-3-堆\"><a href=\"#2-3-堆\" class=\"headerlink\" title=\"2.3 堆\"></a>2.3 堆</h3><h4 id=\"2-3-1-什么是堆\"><a href=\"#2-3-1-什么是堆\" class=\"headerlink\" title=\"2.3.1 什么是堆\"></a>2.3.1 什么是堆</h4><p>&emsp;堆是用于存放对象的内存区域。因此，他是垃圾收集器（GC）管理的主要目标。</p>\n<h4 id=\"2-3-2-特点\"><a href=\"#2-3-2-特点\" class=\"headerlink\" title=\"2.3.2 特点\"></a>2.3.2 特点</h4><ol>\n<li>堆在逻辑上划分为<strong>新生代</strong>和<strong>老年代</strong>。由于JAVA中的对象大部分是朝生夕灭，还有一小部分能够长期的驻留在内存中，为了对这两种对象进行最有效的回收，将堆划分为新生代和老年代，并且执行不同的回收策略。不同的垃圾收集器对这2个逻辑区域的回收机制不尽相同，</li>\n<li>堆占用的内存并不要求物理连续，只需要逻辑连续即可。</li>\n<li>堆一般实现成可扩展内存大小，使用“-Xms”与“-Xmx”控制堆的最小与最大内存，扩展动作交由虚拟机执行。但由于该行为比较消耗性能，因此一般将堆的最大最小内存设为相等。</li>\n<li>堆是所有线程共享的内存区域，因此每个线程都可以拿到堆上的同一个对象。</li>\n<li>堆的生命周期是随着虚拟机的启动而创建。</li>\n</ol>\n<h4 id=\"2-3-3-堆异常\"><a href=\"#2-3-3-堆异常\" class=\"headerlink\" title=\"2.3.3 堆异常\"></a>2.3.3 堆异常</h4><p>&emsp;当堆无法分配对象内存且无法再扩展时，会抛出OutOfMemoryError异常。</p>\n<pre><code>public class HeapOOM &#123;\n\n    static class OOMObject &#123;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;();\n        //不断创建新对象，使得Heap溢出\n        while (true) &#123;\n            list.add(new OOMObject());\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n<p>&emsp;述代码中对象不断的被创建而不进行引用释放，导致GC无法回收堆内存，最终OutOfMemoryError，错误信息：</p>\n<pre><code>java.lang.OutOfMemoryError: Java heap space</code></pre>\n<h3 id=\"2-4-方法区\"><a href=\"#2-4-方法区\" class=\"headerlink\" title=\"2.4 方法区\"></a>2.4 方法区</h3><h4 id=\"2-4-1-方法区定义\"><a href=\"#2-4-1-方法区定义\" class=\"headerlink\" title=\"2.4.1 方法区定义\"></a>2.4.1 方法区定义</h4><p>&emsp;方法区，也称非堆（Non-Heap），是一个被线程共享的内存区域。其中主要存储加载的类字节码、class/method/field等元数据对象、static-final常量、static变量、jit编译器编译后的代码等数据。</p>\n<p>&emsp;如果系统定义太多的类，导致方法区溢出。虚拟机同样会抛出内存溢出的错误。方法区可以理解为永久区。</p>\n<h3 id=\"2-5-上下文切换\"><a href=\"#2-5-上下文切换\" class=\"headerlink\" title=\"2.5 上下文切换\"></a>2.5 上下文切换</h3><blockquote>\n<p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>\n</blockquote>\n<p>&emsp;多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>\n<p>&emsp;上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>\n<p>&emsp;Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>\n<h3 id=\"2-6-死锁\"><a href=\"#2-6-死锁\" class=\"headerlink\" title=\"2.6 死锁\"></a>2.6 死锁</h3><h4 id=\"2-6-1-死锁的定义\"><a href=\"#2-6-1-死锁的定义\" class=\"headerlink\" title=\"2.6.1 死锁的定义\"></a>2.6.1 死锁的定义</h4><p>&emsp;多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/2019-4%E6%AD%BB%E9%94%811.png\" alt=\"线程死锁示意图 \"></p>\n<h4 id=\"2-6-2-死锁的条件\"><a href=\"#2-6-2-死锁的条件\" class=\"headerlink\" title=\"2.6.2 死锁的条件\"></a>2.6.2 死锁的条件</h4><ol>\n<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>\n<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>\n</ol>\n<h4 id=\"2-6-3-如何避免死锁\"><a href=\"#2-6-3-如何避免死锁\" class=\"headerlink\" title=\"2.6.3 如何避免死锁\"></a>2.6.3 如何避免死锁</h4><p>&emsp;为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>\n<ol>\n<li><strong>破坏互斥条件</strong> ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li>\n<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>\n<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>\n<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>\n</ol>\n<h2 id=\"3-角料\"><a href=\"#3-角料\" class=\"headerlink\" title=\"3 角料\"></a>3 角料</h2><h3 id=\"3-1-start-和run-方法\"><a href=\"#3-1-start-和run-方法\" class=\"headerlink\" title=\"3.1  start() 和run() 方法\"></a>3.1  start() 和run() 方法</h3><p>&emsp;<strong>调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p>\n<h3 id=\"3-2-wait-方法和sleep-方法\"><a href=\"#3-2-wait-方法和sleep-方法\" class=\"headerlink\" title=\"3.2 wait()方法和sleep()方法\"></a>3.2 wait()方法和sleep()方法</h3><table>\n<thead>\n<tr>\n<th></th>\n<th><strong>sleep 方法</strong></th>\n<th><strong>wait 方法</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td><strong>没有释放锁</strong></td>\n<td><strong>释放了锁</strong></td>\n</tr>\n<tr>\n<td>2</td>\n<td>用于暂停执行</td>\n<td>用于线程间交互/通信</td>\n</tr>\n<tr>\n<td>3</td>\n<td>被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法</td>\n<td>sleep() 方法执行完成后，线程会自动苏醒。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>两者都可以暂停线程的执行。</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p>- <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=java-%e5%b9%b6%e5%8f%91%e5%9f%ba%e7%a1%80%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98%e6%80%bb%e7%bb%93\">Java 并发基础常见面试题总结</a></p>\n<p>- <a href=\"https://www.cnblogs.com/manayi/p/9293302.html\">02-JVM内存模型：虚拟机栈与本地方法栈</a></p>\n<p>- <a href=\"https://www.cnblogs.com/manayi/p/9651500.html\">03-JVM内存模型：堆与方法区</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"并发基础\"><a href=\"#并发基础\" class=\"headerlink\" title=\"并发基础\"></a>并发基础</h1><p>[TOC]</p>\n<h2 id=\"1-什么是线程和进程？\"><a href=\"#1-什么是线程和进程？\" class=\"headerlink\" title=\"1. 什么是线程和进程？\"></a>1. 什么是线程和进程？</h2><h3 id=\"1-1-进程\"><a href=\"#1-1-进程\" class=\"headerlink\" title=\"1.1 进程\"></a>1.1 进程</h3><p>&emsp;进程是程序的一次执行过程，<strong>是操作系统分配资源的最小单位</strong>，因此进程是动态的。</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/%E8%BF%9B%E7%A8%8B.png\" alt=\"进程展示图\"></p>\n<h3 id=\"1-2-线程\"><a href=\"#1-2-线程\" class=\"headerlink\" title=\"1.2 线程\"></a>1.2 线程</h3><p>&emsp;线程是程序执行的最小单位，一个进程在其执行的过程中可以产生多个线程。每个线程有自己的<span style=\"font-size:20px;color:red;weight:bold;\"><strong>程序计数器、虚拟机栈、本地方法栈</strong></span>，多个线程共享进程的<span style=\"font-size:20px;color:red;weight:bold;\"><strong>堆</strong>、<strong>方法区资源</strong></span>。</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png\" alt=\"img\"></p>\n<h3 id=\"1-3-区别\"><a href=\"#1-3-区别\" class=\"headerlink\" title=\"1.3 区别\"></a>1.3 区别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>进程</th>\n<th align=\"left\">线程</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>概念</td>\n<td>是操作系统分配资源的最小单位</td>\n<td align=\"left\">线程是程序执行的最小单位</td>\n</tr>\n<tr>\n<td>组成</td>\n<td>由一个或多个线程组成</td>\n<td align=\"left\">仅是线程下的一条执行线路</td>\n</tr>\n<tr>\n<td>资源</td>\n<td>进程之间相互独立</td>\n<td align=\"left\">同一进程下，各个线程之前共享程序的内存空间（代码段、数据集、堆等）及一些进程级的资源。执行开销小，不利于资源管理及保护</td>\n</tr>\n<tr>\n<td>调度与切换</td>\n<td>慢</td>\n<td align=\"left\">线程上下文切换快</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-线程详解\"><a href=\"#2-线程详解\" class=\"headerlink\" title=\"2. 线程详解\"></a>2. 线程详解</h2><h3 id=\"2-1-程序计数器为什么是私有的\"><a href=\"#2-1-程序计数器为什么是私有的\" class=\"headerlink\" title=\"2.1 程序计数器为什么是私有的\"></a>2.1 程序计数器为什么是私有的</h3><p>&emsp;程序计数器作用：</p>\n<ol>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、异常处理</li>\n<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了</li>\n</ol>\n<p>&emsp;所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>\n<h3 id=\"2-2-虚拟机栈和本地方法栈\"><a href=\"#2-2-虚拟机栈和本地方法栈\" class=\"headerlink\" title=\"2.2 虚拟机栈和本地方法栈\"></a>2.2 虚拟机栈和本地方法栈</h3><p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/aa18972bd40735fa901e88768e0966b60d2408f4.jpeg\" alt=\"img\"></p>\n<h4 id=\"2-2-1-虚拟机栈\"><a href=\"#2-2-1-虚拟机栈\" class=\"headerlink\" title=\"2.2.1 虚拟机栈\"></a>2.2.1 虚拟机栈</h4><h5 id=\"2-2-1-1-虚拟机栈讲解\"><a href=\"#2-2-1-1-虚拟机栈讲解\" class=\"headerlink\" title=\"2.2.1.1 虚拟机栈讲解\"></a>2.2.1.1 虚拟机栈讲解</h5><p>　<strong>虚拟机栈是用于描述java方法执行的内存模型。</strong></p>\n<p>&emsp;每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“局部变量表、操作数栈、动态链接、方法出口”几个部分。我们常说的“堆内存、栈内存”中的<strong>“栈内存”指的便是虚拟机栈</strong>，确切地说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。</p>\n<p>&emsp;方法调用时，创建栈帧，并压入虚拟机栈；方法执行完毕，栈帧出栈并被销毁，如下图所示：</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/1266638-20180711104523327-1846448145.png\" alt=\"img\"></p>\n<h5 id=\"2-2-1-2-虚拟机栈特点\"><a href=\"#2-2-1-2-虚拟机栈特点\" class=\"headerlink\" title=\"2.2.1.2 虚拟机栈特点\"></a>2.2.1.2 虚拟机栈特点</h5><p>&emsp;虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈。</p>\n<h5 id=\"2-2-1-3-虚拟机栈的StackOverflowError\"><a href=\"#2-2-1-3-虚拟机栈的StackOverflowError\" class=\"headerlink\" title=\"2.2.1.3 虚拟机栈的StackOverflowError\"></a>2.2.1.3 虚拟机栈的StackOverflowError</h5><p>&emsp;<strong>单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）。</strong></p>\n<p>&emsp;JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用，代码见下：</p>\n<pre><code>public class JavaVMStackSOF &#123;\n\n    private void add(int c)&#123;\n        add(c++);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        try &#123;\n            new JavaVMStackSOF().add(0);\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n<p>&emsp;在不断的循环调用，最终超出虚拟机允许的深度，抛出栈溢出错误。</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20201104094518290.png\" alt=\"image-20201104094518290\"></p>\n<h5 id=\"2-2-1-4-虚拟机栈的OutOfMemoryError\"><a href=\"#2-2-1-4-虚拟机栈的OutOfMemoryError\" class=\"headerlink\" title=\"2.2.1.4 虚拟机栈的OutOfMemoryError\"></a>2.2.1.4 虚拟机栈的OutOfMemoryError</h5><p>&emsp;<strong>OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。</strong></p>\n<p>&emsp;JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常（建议不要尝试，容易把电脑跑蹦）</p>\n<pre><code>public class JavaVMStackOOM &#123;\n\n    public static void main(String[] args) &#123;\n        while(true)&#123;\n            new Thread(() -&gt; &#123;\n                while (true)&#123;\n\n                &#125;\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;</code></pre>\n<h4 id=\"2-2-2-本地方法栈\"><a href=\"#2-2-2-本地方法栈\" class=\"headerlink\" title=\"2.2.2 本地方法栈\"></a>2.2.2 本地方法栈</h4><p>&emsp;和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务（例如Thread.start0()）。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。由于native方法不是用Java实现的，而是由C语言实现的，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。</p>\n<p style=\"color:red\">&emsp;为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p>\n\n<h3 id=\"2-3-堆\"><a href=\"#2-3-堆\" class=\"headerlink\" title=\"2.3 堆\"></a>2.3 堆</h3><h4 id=\"2-3-1-什么是堆\"><a href=\"#2-3-1-什么是堆\" class=\"headerlink\" title=\"2.3.1 什么是堆\"></a>2.3.1 什么是堆</h4><p>&emsp;堆是用于存放对象的内存区域。因此，他是垃圾收集器（GC）管理的主要目标。</p>\n<h4 id=\"2-3-2-特点\"><a href=\"#2-3-2-特点\" class=\"headerlink\" title=\"2.3.2 特点\"></a>2.3.2 特点</h4><ol>\n<li>堆在逻辑上划分为<strong>新生代</strong>和<strong>老年代</strong>。由于JAVA中的对象大部分是朝生夕灭，还有一小部分能够长期的驻留在内存中，为了对这两种对象进行最有效的回收，将堆划分为新生代和老年代，并且执行不同的回收策略。不同的垃圾收集器对这2个逻辑区域的回收机制不尽相同，</li>\n<li>堆占用的内存并不要求物理连续，只需要逻辑连续即可。</li>\n<li>堆一般实现成可扩展内存大小，使用“-Xms”与“-Xmx”控制堆的最小与最大内存，扩展动作交由虚拟机执行。但由于该行为比较消耗性能，因此一般将堆的最大最小内存设为相等。</li>\n<li>堆是所有线程共享的内存区域，因此每个线程都可以拿到堆上的同一个对象。</li>\n<li>堆的生命周期是随着虚拟机的启动而创建。</li>\n</ol>\n<h4 id=\"2-3-3-堆异常\"><a href=\"#2-3-3-堆异常\" class=\"headerlink\" title=\"2.3.3 堆异常\"></a>2.3.3 堆异常</h4><p>&emsp;当堆无法分配对象内存且无法再扩展时，会抛出OutOfMemoryError异常。</p>\n<pre><code>public class HeapOOM &#123;\n\n    static class OOMObject &#123;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;();\n        //不断创建新对象，使得Heap溢出\n        while (true) &#123;\n            list.add(new OOMObject());\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n<p>&emsp;述代码中对象不断的被创建而不进行引用释放，导致GC无法回收堆内存，最终OutOfMemoryError，错误信息：</p>\n<pre><code>java.lang.OutOfMemoryError: Java heap space</code></pre>\n<h3 id=\"2-4-方法区\"><a href=\"#2-4-方法区\" class=\"headerlink\" title=\"2.4 方法区\"></a>2.4 方法区</h3><h4 id=\"2-4-1-方法区定义\"><a href=\"#2-4-1-方法区定义\" class=\"headerlink\" title=\"2.4.1 方法区定义\"></a>2.4.1 方法区定义</h4><p>&emsp;方法区，也称非堆（Non-Heap），是一个被线程共享的内存区域。其中主要存储加载的类字节码、class/method/field等元数据对象、static-final常量、static变量、jit编译器编译后的代码等数据。</p>\n<p>&emsp;如果系统定义太多的类，导致方法区溢出。虚拟机同样会抛出内存溢出的错误。方法区可以理解为永久区。</p>\n<h3 id=\"2-5-上下文切换\"><a href=\"#2-5-上下文切换\" class=\"headerlink\" title=\"2.5 上下文切换\"></a>2.5 上下文切换</h3><blockquote>\n<p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>\n</blockquote>\n<p>&emsp;多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>\n<p>&emsp;上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>\n<p>&emsp;Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>\n<h3 id=\"2-6-死锁\"><a href=\"#2-6-死锁\" class=\"headerlink\" title=\"2.6 死锁\"></a>2.6 死锁</h3><h4 id=\"2-6-1-死锁的定义\"><a href=\"#2-6-1-死锁的定义\" class=\"headerlink\" title=\"2.6.1 死锁的定义\"></a>2.6.1 死锁的定义</h4><p>&emsp;多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。</p>\n<p><img src=\"/2020/11/03/%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/2019-4%E6%AD%BB%E9%94%811.png\" alt=\"线程死锁示意图 \"></p>\n<h4 id=\"2-6-2-死锁的条件\"><a href=\"#2-6-2-死锁的条件\" class=\"headerlink\" title=\"2.6.2 死锁的条件\"></a>2.6.2 死锁的条件</h4><ol>\n<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>\n<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>\n</ol>\n<h4 id=\"2-6-3-如何避免死锁\"><a href=\"#2-6-3-如何避免死锁\" class=\"headerlink\" title=\"2.6.3 如何避免死锁\"></a>2.6.3 如何避免死锁</h4><p>&emsp;为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>\n<ol>\n<li><strong>破坏互斥条件</strong> ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li>\n<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>\n<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>\n<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>\n</ol>\n<h2 id=\"3-角料\"><a href=\"#3-角料\" class=\"headerlink\" title=\"3 角料\"></a>3 角料</h2><h3 id=\"3-1-start-和run-方法\"><a href=\"#3-1-start-和run-方法\" class=\"headerlink\" title=\"3.1  start() 和run() 方法\"></a>3.1  start() 和run() 方法</h3><p>&emsp;<strong>调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p>\n<h3 id=\"3-2-wait-方法和sleep-方法\"><a href=\"#3-2-wait-方法和sleep-方法\" class=\"headerlink\" title=\"3.2 wait()方法和sleep()方法\"></a>3.2 wait()方法和sleep()方法</h3><table>\n<thead>\n<tr>\n<th></th>\n<th><strong>sleep 方法</strong></th>\n<th><strong>wait 方法</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td><strong>没有释放锁</strong></td>\n<td><strong>释放了锁</strong></td>\n</tr>\n<tr>\n<td>2</td>\n<td>用于暂停执行</td>\n<td>用于线程间交互/通信</td>\n</tr>\n<tr>\n<td>3</td>\n<td>被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法</td>\n<td>sleep() 方法执行完成后，线程会自动苏醒。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>两者都可以暂停线程的执行。</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p>- <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93?id=java-%e5%b9%b6%e5%8f%91%e5%9f%ba%e7%a1%80%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98%e6%80%bb%e7%bb%93\">Java 并发基础常见面试题总结</a></p>\n<p>- <a href=\"https://www.cnblogs.com/manayi/p/9293302.html\">02-JVM内存模型：虚拟机栈与本地方法栈</a></p>\n<p>- <a href=\"https://www.cnblogs.com/manayi/p/9651500.html\">03-JVM内存模型：堆与方法区</a></p>\n"},{"title":"悲观锁与乐观锁","date":"2020-10-21T06:16:33.000Z","description":"乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。","typora-copy-images-to":"upload","_content":"\n## 悲观锁\n\n[TOC]\n\n### 1. 悲观锁定义\n\n在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。\n\n**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。**\n\n悲观锁，具有强烈的独占和排他特性。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。\n\n### 2. 种类\n\n1. <font color = \"red\"> 共享锁【shared locks】又称为读锁，简称S锁。</font>多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。\n2. <font color = \"red\"> 排他锁【exclusive locks】又称为写锁，简称X锁。</font>排他锁就是不能与其他锁（共享锁、排他锁）并存，获取排他锁的事务是可以对数据行读取和修改。\n\n### 3. 说明\n\n悲观并发控制实际上是“先取锁再访问”的保守策略。\n\n- **处理加锁的机制会让数据库产生额外的开销，增加产生死锁的机会**\n- ***降低并行性***（一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。）\n\n### 4. 实现方式\n\n1. 修改之前，先加上排它锁(exclusive locks)\n\n2. 加锁失败，说明该记录正在修改，线程陷入等待或者抛出异常\n\n3. 加锁成功，修改，事务结束之后解锁\n\n   ![](悲观锁与乐观锁/1.jpg)\n\n[^ ]:注：mysql设置非立马提交（set autocommit=0）MySQL InnoDB 默认行级锁。行级锁都是基于索引的，如果一条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住。\n\n\n\n## 乐观锁\n\n### 1. 乐观锁定义\n\n**乐观锁一般会使用版本号机制或CAS算法实现。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**，像数据库提供的类似于write_condition机制**，其实都是提供的乐观锁。在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式**CAS**实现的。\n\n### 2. 两种实现方式\n\n#### 2.1 **CAS 实现**(compare and swap[比较与交换])\n\nJava 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。\n\n![img](悲观锁与乐观锁/2.jpg)\n\n#### 2.2 版本号机制\n\n##### 2.2.1 ABA 问题\n\n![](悲观锁与乐观锁/3.png)\n\n如图流程可以看出，当线程一读取变量v=1，这时线程二读取的变量v=1，并且线程二对变量v=1 进行了修改操作。使v=2，之后又使v=1。这时，线程一进行了CAS操作，发现变量v=1,这时线程一也成功了，但是过程是存在ABA问题的。\n\n##### 2.2.2 版本号\n\n乐观锁每次操作时都带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。除了 version 以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。\n\n### 3. **CAS与synchronized的使用情景**\n\n> **简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）**\n\n1. 对于资源竞争较少（线程冲突较轻）的情况，使用`synchronized`同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。\n2. 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。\n\n补充： Java并发编程这个领域中`synchronized`关键字一直都是元老级的角色，很久之前很多人都会称它为 **“重量级锁”** 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 **偏向锁** 和 **轻量级锁** 以及其它**各种优化**之后变得在某些情况下并不是那么重了。`synchronized`的底层实现主要依靠 **Lock-Free** 的队列，基本思路是 **自旋后阻塞**，**竞争切换后继续竞争锁**，**稍微牺牲了公平性，但获得了高吞吐量**。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。\n\n### 4. 两者比较\n\n|          | 乐观锁                                                       | 悲观锁                                                       |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 适用场景 | **适用于写比较少的情况下（多读场景）**                       | **多写的场景下用悲观锁就比较合适**                           |\n| 实现     | 1. CAS<br /> 2. 版本号机制                                   | 1. 传统的关系型数据库的行锁，表锁等，读锁，写锁等<br />2. [synchronized](https://www.jianshu.com/p/c8f997e7f75c) 关键字 |\n| 缺点     | 1. ABA问题<br />2. 循环时间长开销大（自旋CAS（也就是不成功就一直循环执行直到成功））<br />3. 只能保证一个共享变量的原子操作 | 1.效率低<br />2.容易产生死锁                                 |\n\n\\- [什么是乐观锁，什么是悲观锁](https://www.jianshu.com/p/d2ac26ca6525)\n\n\\- [何谓悲观锁与乐观锁](https://snailclimb.gitee.io/javaguide/#/docs/essential-content-for-interview/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E4%B9%8B%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81?id=_1-%e7%89%88%e6%9c%ac%e5%8f%b7%e6%9c%ba%e5%88%b6)","source":"_posts/并发/悲观锁与乐观锁.md","raw":"---\ntitle: 悲观锁与乐观锁 #文章页面上的显示名称，一般是中文\ndate: 2020-10-21 14:16:33 #文章生成时间，一般不改，当然也可以任意修改\ncategories: 并发 #分类\ntags: [锁机制,并发] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: 乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。\ntypora-copy-images-to: upload\n---\n\n## 悲观锁\n\n[TOC]\n\n### 1. 悲观锁定义\n\n在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。\n\n**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。**\n\n悲观锁，具有强烈的独占和排他特性。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。\n\n### 2. 种类\n\n1. <font color = \"red\"> 共享锁【shared locks】又称为读锁，简称S锁。</font>多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。\n2. <font color = \"red\"> 排他锁【exclusive locks】又称为写锁，简称X锁。</font>排他锁就是不能与其他锁（共享锁、排他锁）并存，获取排他锁的事务是可以对数据行读取和修改。\n\n### 3. 说明\n\n悲观并发控制实际上是“先取锁再访问”的保守策略。\n\n- **处理加锁的机制会让数据库产生额外的开销，增加产生死锁的机会**\n- ***降低并行性***（一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。）\n\n### 4. 实现方式\n\n1. 修改之前，先加上排它锁(exclusive locks)\n\n2. 加锁失败，说明该记录正在修改，线程陷入等待或者抛出异常\n\n3. 加锁成功，修改，事务结束之后解锁\n\n   ![](悲观锁与乐观锁/1.jpg)\n\n[^ ]:注：mysql设置非立马提交（set autocommit=0）MySQL InnoDB 默认行级锁。行级锁都是基于索引的，如果一条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住。\n\n\n\n## 乐观锁\n\n### 1. 乐观锁定义\n\n**乐观锁一般会使用版本号机制或CAS算法实现。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**，像数据库提供的类似于write_condition机制**，其实都是提供的乐观锁。在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式**CAS**实现的。\n\n### 2. 两种实现方式\n\n#### 2.1 **CAS 实现**(compare and swap[比较与交换])\n\nJava 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。\n\n![img](悲观锁与乐观锁/2.jpg)\n\n#### 2.2 版本号机制\n\n##### 2.2.1 ABA 问题\n\n![](悲观锁与乐观锁/3.png)\n\n如图流程可以看出，当线程一读取变量v=1，这时线程二读取的变量v=1，并且线程二对变量v=1 进行了修改操作。使v=2，之后又使v=1。这时，线程一进行了CAS操作，发现变量v=1,这时线程一也成功了，但是过程是存在ABA问题的。\n\n##### 2.2.2 版本号\n\n乐观锁每次操作时都带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。除了 version 以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。\n\n### 3. **CAS与synchronized的使用情景**\n\n> **简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）**\n\n1. 对于资源竞争较少（线程冲突较轻）的情况，使用`synchronized`同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。\n2. 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。\n\n补充： Java并发编程这个领域中`synchronized`关键字一直都是元老级的角色，很久之前很多人都会称它为 **“重量级锁”** 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 **偏向锁** 和 **轻量级锁** 以及其它**各种优化**之后变得在某些情况下并不是那么重了。`synchronized`的底层实现主要依靠 **Lock-Free** 的队列，基本思路是 **自旋后阻塞**，**竞争切换后继续竞争锁**，**稍微牺牲了公平性，但获得了高吞吐量**。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。\n\n### 4. 两者比较\n\n|          | 乐观锁                                                       | 悲观锁                                                       |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 适用场景 | **适用于写比较少的情况下（多读场景）**                       | **多写的场景下用悲观锁就比较合适**                           |\n| 实现     | 1. CAS<br /> 2. 版本号机制                                   | 1. 传统的关系型数据库的行锁，表锁等，读锁，写锁等<br />2. [synchronized](https://www.jianshu.com/p/c8f997e7f75c) 关键字 |\n| 缺点     | 1. ABA问题<br />2. 循环时间长开销大（自旋CAS（也就是不成功就一直循环执行直到成功））<br />3. 只能保证一个共享变量的原子操作 | 1.效率低<br />2.容易产生死锁                                 |\n\n\\- [什么是乐观锁，什么是悲观锁](https://www.jianshu.com/p/d2ac26ca6525)\n\n\\- [何谓悲观锁与乐观锁](https://snailclimb.gitee.io/javaguide/#/docs/essential-content-for-interview/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E4%B9%8B%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81?id=_1-%e7%89%88%e6%9c%ac%e5%8f%b7%e6%9c%ba%e5%88%b6)","slug":"并发/悲观锁与乐观锁","published":1,"updated":"2021-03-25T06:54:04.608Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknqx8kes0001botk4j9mhgzo","content":"<h2 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h2><p>[TOC]</p>\n<h3 id=\"1-悲观锁定义\"><a href=\"#1-悲观锁定义\" class=\"headerlink\" title=\"1. 悲观锁定义\"></a>1. 悲观锁定义</h3><p>在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。</p>\n<p><strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</strong></p>\n<p>悲观锁，具有强烈的独占和排他特性。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>\n<h3 id=\"2-种类\"><a href=\"#2-种类\" class=\"headerlink\" title=\"2. 种类\"></a>2. 种类</h3><ol>\n<li><font color=\"red\"> 共享锁【shared locks】又称为读锁，简称S锁。</font>多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li>\n<li><font color=\"red\"> 排他锁【exclusive locks】又称为写锁，简称X锁。</font>排他锁就是不能与其他锁（共享锁、排他锁）并存，获取排他锁的事务是可以对数据行读取和修改。</li>\n</ol>\n<h3 id=\"3-说明\"><a href=\"#3-说明\" class=\"headerlink\" title=\"3. 说明\"></a>3. 说明</h3><p>悲观并发控制实际上是“先取锁再访问”的保守策略。</p>\n<ul>\n<li><strong>处理加锁的机制会让数据库产生额外的开销，增加产生死锁的机会</strong></li>\n<li><strong><em>降低并行性</em></strong>（一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。）</li>\n</ul>\n<h3 id=\"4-实现方式\"><a href=\"#4-实现方式\" class=\"headerlink\" title=\"4. 实现方式\"></a>4. 实现方式</h3><ol>\n<li><p>修改之前，先加上排它锁(exclusive locks)</p>\n</li>\n<li><p>加锁失败，说明该记录正在修改，线程陷入等待或者抛出异常</p>\n</li>\n<li><p>加锁成功，修改，事务结束之后解锁</p>\n<p><img src=\"/2020/10/21/%E5%B9%B6%E5%8F%91/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/1.jpg\"></p>\n</li>\n</ol>\n<p>[^ ]:注：mysql设置非立马提交（set autocommit=0）MySQL InnoDB 默认行级锁。行级锁都是基于索引的，如果一条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住。</p>\n<h2 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h2><h3 id=\"1-乐观锁定义\"><a href=\"#1-乐观锁定义\" class=\"headerlink\" title=\"1. 乐观锁定义\"></a>1. 乐观锁定义</h3><p><strong>乐观锁一般会使用版本号机制或CAS算法实现。</strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量<strong>，像数据库提供的类似于write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p>\n<h3 id=\"2-两种实现方式\"><a href=\"#2-两种实现方式\" class=\"headerlink\" title=\"2. 两种实现方式\"></a>2. 两种实现方式</h3><h4 id=\"2-1-CAS-实现-compare-and-swap-比较与交换\"><a href=\"#2-1-CAS-实现-compare-and-swap-比较与交换\" class=\"headerlink\" title=\"2.1 CAS 实现(compare and swap[比较与交换])\"></a>2.1 <strong>CAS 实现</strong>(compare and swap[比较与交换])</h4><p>Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>\n<p><img src=\"/2020/10/21/%E5%B9%B6%E5%8F%91/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/2.jpg\" alt=\"img\"></p>\n<h4 id=\"2-2-版本号机制\"><a href=\"#2-2-版本号机制\" class=\"headerlink\" title=\"2.2 版本号机制\"></a>2.2 版本号机制</h4><h5 id=\"2-2-1-ABA-问题\"><a href=\"#2-2-1-ABA-问题\" class=\"headerlink\" title=\"2.2.1 ABA 问题\"></a>2.2.1 ABA 问题</h5><p><img src=\"/2020/10/21/%E5%B9%B6%E5%8F%91/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/3.png\"></p>\n<p>如图流程可以看出，当线程一读取变量v=1，这时线程二读取的变量v=1，并且线程二对变量v=1 进行了修改操作。使v=2，之后又使v=1。这时，线程一进行了CAS操作，发现变量v=1,这时线程一也成功了，但是过程是存在ABA问题的。</p>\n<h5 id=\"2-2-2-版本号\"><a href=\"#2-2-2-版本号\" class=\"headerlink\" title=\"2.2.2 版本号\"></a>2.2.2 版本号</h5><p>乐观锁每次操作时都带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。除了 version 以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。</p>\n<h3 id=\"3-CAS与synchronized的使用情景\"><a href=\"#3-CAS与synchronized的使用情景\" class=\"headerlink\" title=\"3. CAS与synchronized的使用情景\"></a>3. <strong>CAS与synchronized的使用情景</strong></h3><blockquote>\n<p><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></p>\n</blockquote>\n<ol>\n<li>对于资源竞争较少（线程冲突较轻）的情况，使用<code>synchronized</code>同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>\n<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>\n</ol>\n<p>补充： Java并发编程这个领域中<code>synchronized</code>关键字一直都是元老级的角色，很久之前很多人都会称它为 <strong>“重量级锁”</strong> 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它<strong>各种优化</strong>之后变得在某些情况下并不是那么重了。<code>synchronized</code>的底层实现主要依靠 <strong>Lock-Free</strong> 的队列，基本思路是 <strong>自旋后阻塞</strong>，<strong>竞争切换后继续竞争锁</strong>，<strong>稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>\n<h3 id=\"4-两者比较\"><a href=\"#4-两者比较\" class=\"headerlink\" title=\"4. 两者比较\"></a>4. 两者比较</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>乐观锁</th>\n<th>悲观锁</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>适用场景</td>\n<td><strong>适用于写比较少的情况下（多读场景）</strong></td>\n<td><strong>多写的场景下用悲观锁就比较合适</strong></td>\n</tr>\n<tr>\n<td>实现</td>\n<td>1. CAS<br> 2. 版本号机制</td>\n<td>1. 传统的关系型数据库的行锁，表锁等，读锁，写锁等<br>2. <a href=\"https://www.jianshu.com/p/c8f997e7f75c\">synchronized</a> 关键字</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>1. ABA问题<br>2. 循环时间长开销大（自旋CAS（也就是不成功就一直循环执行直到成功））<br>3. 只能保证一个共享变量的原子操作</td>\n<td>1.效率低<br>2.容易产生死锁</td>\n</tr>\n</tbody></table>\n<p>- <a href=\"https://www.jianshu.com/p/d2ac26ca6525\">什么是乐观锁，什么是悲观锁</a></p>\n<p>- <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/essential-content-for-interview/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E4%B9%8B%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81?id=_1-%e7%89%88%e6%9c%ac%e5%8f%b7%e6%9c%ba%e5%88%b6\">何谓悲观锁与乐观锁</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h2><p>[TOC]</p>\n<h3 id=\"1-悲观锁定义\"><a href=\"#1-悲观锁定义\" class=\"headerlink\" title=\"1. 悲观锁定义\"></a>1. 悲观锁定义</h3><p>在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。</p>\n<p><strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</strong></p>\n<p>悲观锁，具有强烈的独占和排他特性。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>\n<h3 id=\"2-种类\"><a href=\"#2-种类\" class=\"headerlink\" title=\"2. 种类\"></a>2. 种类</h3><ol>\n<li><font color=\"red\"> 共享锁【shared locks】又称为读锁，简称S锁。</font>多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li>\n<li><font color=\"red\"> 排他锁【exclusive locks】又称为写锁，简称X锁。</font>排他锁就是不能与其他锁（共享锁、排他锁）并存，获取排他锁的事务是可以对数据行读取和修改。</li>\n</ol>\n<h3 id=\"3-说明\"><a href=\"#3-说明\" class=\"headerlink\" title=\"3. 说明\"></a>3. 说明</h3><p>悲观并发控制实际上是“先取锁再访问”的保守策略。</p>\n<ul>\n<li><strong>处理加锁的机制会让数据库产生额外的开销，增加产生死锁的机会</strong></li>\n<li><strong><em>降低并行性</em></strong>（一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。）</li>\n</ul>\n<h3 id=\"4-实现方式\"><a href=\"#4-实现方式\" class=\"headerlink\" title=\"4. 实现方式\"></a>4. 实现方式</h3><ol>\n<li><p>修改之前，先加上排它锁(exclusive locks)</p>\n</li>\n<li><p>加锁失败，说明该记录正在修改，线程陷入等待或者抛出异常</p>\n</li>\n<li><p>加锁成功，修改，事务结束之后解锁</p>\n<p><img src=\"/2020/10/21/%E5%B9%B6%E5%8F%91/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/1.jpg\"></p>\n</li>\n</ol>\n<p>[^ ]:注：mysql设置非立马提交（set autocommit=0）MySQL InnoDB 默认行级锁。行级锁都是基于索引的，如果一条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住。</p>\n<h2 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h2><h3 id=\"1-乐观锁定义\"><a href=\"#1-乐观锁定义\" class=\"headerlink\" title=\"1. 乐观锁定义\"></a>1. 乐观锁定义</h3><p><strong>乐观锁一般会使用版本号机制或CAS算法实现。</strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量<strong>，像数据库提供的类似于write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p>\n<h3 id=\"2-两种实现方式\"><a href=\"#2-两种实现方式\" class=\"headerlink\" title=\"2. 两种实现方式\"></a>2. 两种实现方式</h3><h4 id=\"2-1-CAS-实现-compare-and-swap-比较与交换\"><a href=\"#2-1-CAS-实现-compare-and-swap-比较与交换\" class=\"headerlink\" title=\"2.1 CAS 实现(compare and swap[比较与交换])\"></a>2.1 <strong>CAS 实现</strong>(compare and swap[比较与交换])</h4><p>Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>\n<p><img src=\"/2020/10/21/%E5%B9%B6%E5%8F%91/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/2.jpg\" alt=\"img\"></p>\n<h4 id=\"2-2-版本号机制\"><a href=\"#2-2-版本号机制\" class=\"headerlink\" title=\"2.2 版本号机制\"></a>2.2 版本号机制</h4><h5 id=\"2-2-1-ABA-问题\"><a href=\"#2-2-1-ABA-问题\" class=\"headerlink\" title=\"2.2.1 ABA 问题\"></a>2.2.1 ABA 问题</h5><p><img src=\"/2020/10/21/%E5%B9%B6%E5%8F%91/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/3.png\"></p>\n<p>如图流程可以看出，当线程一读取变量v=1，这时线程二读取的变量v=1，并且线程二对变量v=1 进行了修改操作。使v=2，之后又使v=1。这时，线程一进行了CAS操作，发现变量v=1,这时线程一也成功了，但是过程是存在ABA问题的。</p>\n<h5 id=\"2-2-2-版本号\"><a href=\"#2-2-2-版本号\" class=\"headerlink\" title=\"2.2.2 版本号\"></a>2.2.2 版本号</h5><p>乐观锁每次操作时都带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。除了 version 以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。</p>\n<h3 id=\"3-CAS与synchronized的使用情景\"><a href=\"#3-CAS与synchronized的使用情景\" class=\"headerlink\" title=\"3. CAS与synchronized的使用情景\"></a>3. <strong>CAS与synchronized的使用情景</strong></h3><blockquote>\n<p><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></p>\n</blockquote>\n<ol>\n<li>对于资源竞争较少（线程冲突较轻）的情况，使用<code>synchronized</code>同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>\n<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>\n</ol>\n<p>补充： Java并发编程这个领域中<code>synchronized</code>关键字一直都是元老级的角色，很久之前很多人都会称它为 <strong>“重量级锁”</strong> 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它<strong>各种优化</strong>之后变得在某些情况下并不是那么重了。<code>synchronized</code>的底层实现主要依靠 <strong>Lock-Free</strong> 的队列，基本思路是 <strong>自旋后阻塞</strong>，<strong>竞争切换后继续竞争锁</strong>，<strong>稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>\n<h3 id=\"4-两者比较\"><a href=\"#4-两者比较\" class=\"headerlink\" title=\"4. 两者比较\"></a>4. 两者比较</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>乐观锁</th>\n<th>悲观锁</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>适用场景</td>\n<td><strong>适用于写比较少的情况下（多读场景）</strong></td>\n<td><strong>多写的场景下用悲观锁就比较合适</strong></td>\n</tr>\n<tr>\n<td>实现</td>\n<td>1. CAS<br> 2. 版本号机制</td>\n<td>1. 传统的关系型数据库的行锁，表锁等，读锁，写锁等<br>2. <a href=\"https://www.jianshu.com/p/c8f997e7f75c\">synchronized</a> 关键字</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>1. ABA问题<br>2. 循环时间长开销大（自旋CAS（也就是不成功就一直循环执行直到成功））<br>3. 只能保证一个共享变量的原子操作</td>\n<td>1.效率低<br>2.容易产生死锁</td>\n</tr>\n</tbody></table>\n<p>- <a href=\"https://www.jianshu.com/p/d2ac26ca6525\">什么是乐观锁，什么是悲观锁</a></p>\n<p>- <a href=\"https://snailclimb.gitee.io/javaguide/#/docs/essential-content-for-interview/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E4%B9%8B%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81?id=_1-%e7%89%88%e6%9c%ac%e5%8f%b7%e6%9c%ba%e5%88%b6\">何谓悲观锁与乐观锁</a></p>\n"},{"title":"动态规划","date":"2021-04-14T06:16:33.000Z","description":"动态规划算法详细及应用场景相关介绍。","_content":"\n[TOC]\n\n# 动态规划算法\n\n## 动态规划特点\n\n1. 计数\n   1. 有多少种方式走到右下角\n   2. 有多少种方法选出k个数，使得和为sum\n2. 求最大最小值\n   1. 从左上角走到右下角路径的最大数字和\n   2. 最长上升子序列长度\n3. 求存在性\n   1. 取石子游戏，先手是否必胜\n   2. 能不能选出k个数，使得和为sum\n\n\n\n## 解题步骤\n\n### 1. 确定状态\n\n\n\n1. 确定状态\n2. \n\n\n\n## 题目\n\n\n\n\n\n\n\n\n\n## 参考\n\n\\- [位运算 之（1） 按位与（AND）& 操作](https://www.cnblogs.com/roamman/archive/2010/08/17/1801392.html)","source":"_posts/算法学习/动态规划.md","raw":"---\ntitle: 动态规划 \ndate: 2021-04-14 14:16:33 #文章生成时间，一般不改，当然也可以任意修改\ncategories: 算法 #分类\ntags: [动态规划,java] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: 动态规划算法详细及应用场景相关介绍。\n---\n\n[TOC]\n\n# 动态规划算法\n\n## 动态规划特点\n\n1. 计数\n   1. 有多少种方式走到右下角\n   2. 有多少种方法选出k个数，使得和为sum\n2. 求最大最小值\n   1. 从左上角走到右下角路径的最大数字和\n   2. 最长上升子序列长度\n3. 求存在性\n   1. 取石子游戏，先手是否必胜\n   2. 能不能选出k个数，使得和为sum\n\n\n\n## 解题步骤\n\n### 1. 确定状态\n\n\n\n1. 确定状态\n2. \n\n\n\n## 题目\n\n\n\n\n\n\n\n\n\n## 参考\n\n\\- [位运算 之（1） 按位与（AND）& 操作](https://www.cnblogs.com/roamman/archive/2010/08/17/1801392.html)","slug":"算法学习/动态规划","published":1,"updated":"2021-04-14T08:04:28.961Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknqx8keu0004botkewv2ertp","content":"<p>[TOC]</p>\n<h1 id=\"动态规划算法\"><a href=\"#动态规划算法\" class=\"headerlink\" title=\"动态规划算法\"></a>动态规划算法</h1><h2 id=\"动态规划特点\"><a href=\"#动态规划特点\" class=\"headerlink\" title=\"动态规划特点\"></a>动态规划特点</h2><ol>\n<li>计数<ol>\n<li>有多少种方式走到右下角</li>\n<li>有多少种方法选出k个数，使得和为sum</li>\n</ol>\n</li>\n<li>求最大最小值<ol>\n<li>从左上角走到右下角路径的最大数字和</li>\n<li>最长上升子序列长度</li>\n</ol>\n</li>\n<li>求存在性<ol>\n<li>取石子游戏，先手是否必胜</li>\n<li>能不能选出k个数，使得和为sum</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"解题步骤\"><a href=\"#解题步骤\" class=\"headerlink\" title=\"解题步骤\"></a>解题步骤</h2><h3 id=\"1-确定状态\"><a href=\"#1-确定状态\" class=\"headerlink\" title=\"1. 确定状态\"></a>1. 确定状态</h3><ol>\n<li>确定状态</li>\n<li></li>\n</ol>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>- <a href=\"https://www.cnblogs.com/roamman/archive/2010/08/17/1801392.html\">位运算 之（1） 按位与（AND）&amp; 操作</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"动态规划算法\"><a href=\"#动态规划算法\" class=\"headerlink\" title=\"动态规划算法\"></a>动态规划算法</h1><h2 id=\"动态规划特点\"><a href=\"#动态规划特点\" class=\"headerlink\" title=\"动态规划特点\"></a>动态规划特点</h2><ol>\n<li>计数<ol>\n<li>有多少种方式走到右下角</li>\n<li>有多少种方法选出k个数，使得和为sum</li>\n</ol>\n</li>\n<li>求最大最小值<ol>\n<li>从左上角走到右下角路径的最大数字和</li>\n<li>最长上升子序列长度</li>\n</ol>\n</li>\n<li>求存在性<ol>\n<li>取石子游戏，先手是否必胜</li>\n<li>能不能选出k个数，使得和为sum</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"解题步骤\"><a href=\"#解题步骤\" class=\"headerlink\" title=\"解题步骤\"></a>解题步骤</h2><h3 id=\"1-确定状态\"><a href=\"#1-确定状态\" class=\"headerlink\" title=\"1. 确定状态\"></a>1. 确定状态</h3><ol>\n<li>确定状态</li>\n<li></li>\n</ol>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>- <a href=\"https://www.cnblogs.com/roamman/archive/2010/08/17/1801392.html\">位运算 之（1） 按位与（AND）&amp; 操作</a></p>\n"},{"title":"面试题","date":"2021-04-21T06:16:33.000Z","description":"java中位运算的使用及相关应用场景。","_content":"\n[TOC]\n\n# 面试题\n\n## java相关\n\n### 设计层面问题\n\n1. java 为什么一定要去掉多继承\n\n\n\n2. 抽象类和接口设计层面上的区别\n\n   \n\n3. \n\n### 技术层面\n\n1. java中动态代理有几种，并详细介绍下\n2. 说下几种集合及集合的特性\n3. ConcurrentHashMap 实现原理\n4. \n\n### springboot 框架相关\n\n1. main方法启动原理\n2. 在配置文件加载之后执行的几种方式\n3. 简单聊下AOP\n4. 在一个Bean中调用AOP方法，会被切面捕获到吗？为什么\n5. spring 信号机\n6. spring security\n\n### Netty\n\n1. boss线程组与worker线程组工作原理\n2. 分包粘包处理方式\n3. 几种编码协议\n4. ","source":"_posts/面试相关/面试题总结.md","raw":"---\ntitle: 面试题 #文章页面上的显示名称，一般是中文\ndate: 2021-04-21 14:16:33 #文章生成时间，一般不改，当然也可以任意修改\ncategories: JAVA #分类\ntags: [面试] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: java中位运算的使用及相关应用场景。\n---\n\n[TOC]\n\n# 面试题\n\n## java相关\n\n### 设计层面问题\n\n1. java 为什么一定要去掉多继承\n\n\n\n2. 抽象类和接口设计层面上的区别\n\n   \n\n3. \n\n### 技术层面\n\n1. java中动态代理有几种，并详细介绍下\n2. 说下几种集合及集合的特性\n3. ConcurrentHashMap 实现原理\n4. \n\n### springboot 框架相关\n\n1. main方法启动原理\n2. 在配置文件加载之后执行的几种方式\n3. 简单聊下AOP\n4. 在一个Bean中调用AOP方法，会被切面捕获到吗？为什么\n5. spring 信号机\n6. spring security\n\n### Netty\n\n1. boss线程组与worker线程组工作原理\n2. 分包粘包处理方式\n3. 几种编码协议\n4. ","slug":"面试相关/面试题总结","published":1,"updated":"2021-04-21T06:35:23.654Z","_id":"cknqx8kev0005botkfu4bdu3x","comments":1,"layout":"post","photos":[],"link":"","content":"<p>[TOC]</p>\n<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h2 id=\"java相关\"><a href=\"#java相关\" class=\"headerlink\" title=\"java相关\"></a>java相关</h2><h3 id=\"设计层面问题\"><a href=\"#设计层面问题\" class=\"headerlink\" title=\"设计层面问题\"></a>设计层面问题</h3><ol>\n<li>java 为什么一定要去掉多继承</li>\n</ol>\n<ol start=\"2\">\n<li>抽象类和接口设计层面上的区别</li>\n</ol>\n<ol start=\"3\">\n<li><h3 id=\"技术层面\"><a href=\"#技术层面\" class=\"headerlink\" title=\"技术层面\"></a>技术层面</h3></li>\n<li><p>java中动态代理有几种，并详细介绍下</p>\n</li>\n<li><p>说下几种集合及集合的特性</p>\n</li>\n<li><p>ConcurrentHashMap 实现原理</p>\n</li>\n<li></li>\n</ol>\n<h3 id=\"springboot-框架相关\"><a href=\"#springboot-框架相关\" class=\"headerlink\" title=\"springboot 框架相关\"></a>springboot 框架相关</h3><ol>\n<li>main方法启动原理</li>\n<li>在配置文件加载之后执行的几种方式</li>\n<li>简单聊下AOP</li>\n<li>在一个Bean中调用AOP方法，会被切面捕获到吗？为什么</li>\n<li>spring 信号机</li>\n<li>spring security</li>\n</ol>\n<h3 id=\"Netty\"><a href=\"#Netty\" class=\"headerlink\" title=\"Netty\"></a>Netty</h3><ol>\n<li>boss线程组与worker线程组工作原理</li>\n<li>分包粘包处理方式</li>\n<li>几种编码协议</li>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h2 id=\"java相关\"><a href=\"#java相关\" class=\"headerlink\" title=\"java相关\"></a>java相关</h2><h3 id=\"设计层面问题\"><a href=\"#设计层面问题\" class=\"headerlink\" title=\"设计层面问题\"></a>设计层面问题</h3><ol>\n<li>java 为什么一定要去掉多继承</li>\n</ol>\n<ol start=\"2\">\n<li>抽象类和接口设计层面上的区别</li>\n</ol>\n<ol start=\"3\">\n<li><h3 id=\"技术层面\"><a href=\"#技术层面\" class=\"headerlink\" title=\"技术层面\"></a>技术层面</h3></li>\n<li><p>java中动态代理有几种，并详细介绍下</p>\n</li>\n<li><p>说下几种集合及集合的特性</p>\n</li>\n<li><p>ConcurrentHashMap 实现原理</p>\n</li>\n<li></li>\n</ol>\n<h3 id=\"springboot-框架相关\"><a href=\"#springboot-框架相关\" class=\"headerlink\" title=\"springboot 框架相关\"></a>springboot 框架相关</h3><ol>\n<li>main方法启动原理</li>\n<li>在配置文件加载之后执行的几种方式</li>\n<li>简单聊下AOP</li>\n<li>在一个Bean中调用AOP方法，会被切面捕获到吗？为什么</li>\n<li>spring 信号机</li>\n<li>spring security</li>\n</ol>\n<h3 id=\"Netty\"><a href=\"#Netty\" class=\"headerlink\" title=\"Netty\"></a>Netty</h3><ol>\n<li>boss线程组与worker线程组工作原理</li>\n<li>分包粘包处理方式</li>\n<li>几种编码协议</li>\n<li></li>\n</ol>\n"},{"title":"JNA的使用","date":"2021-04-09T06:16:33.000Z","description":"java中使用dll类库中c、c++方法。","_content":"\n[TOC]\n\n## 一、JNA (Java Native Access)\n\nJNA(Java Native Access)框架是一个开源的Java框架，建立在经典的JNI的基础之上的一个框架。\n\n\n\n## 二、使用步骤\n\n>1. 需配置VM options: -Djava.library.path=**_[类库所在位置]_**\n>2. jdk 需要根据dll环境进行配置是64位还是32位\n\n### 1. 引入依赖\n\n```xml\n            <dependency>\n                <groupId>net.java.dev.jna</groupId>\n                <artifactId>jna</artifactId>\n                <version>5.5.0</version>\n            </dependency>\n```\n\n### 2. 设置启动环境及参数\n\n2.1 启动时设置java类库地址（or 把dll文件直接放在java类库路径下 or 使用System.load() 绝对路径加载）\n\n> VM options: -Djava.library.path=**_[类库所在位置]_**\n\n![image-20210409173144363](使用c、c++方法/image-20210409173144363.png)\n\n2.2 根据dll文件属性，配置对应的jre环境，64位 or 32位。\n\n### 3. 系统引用\n\n3.1 根据dll名称，把dll文件内容加载至内存（注：不能有文件名后缀，且该dll文件必须在文件类库目录下）\n\n```java\nSystem.loadLibrary(\"TestJNI\"); // 从java类库中加载\nSystem.load(\"C://Documents and Settings//TestJNI.dll\"); //or 从绝对路径中直接下载\n```\n\n### 4. 创建接口，通过接口引用\n\n```java\n// 继承Library or StdCallLibrary\npublic interface ZT_DEV extends Library {\n    // 通过反射加载对象\n        ZT_DEV lib = Native.load(\"ZT_DEV\", ZT_DEV.class);\n\n        // ZT_DEV_OpenDevice为ZT_DEV.dll中的一个方法.(注意类型转换)\n        int ZT_DEV_OpenDevice(int nDeviceType, String strComm, IntByReference nHandle);\n    \n    // c++ 中原生方法参数\n    // int ZT_DEV_OpenDevice(int nDeviceType,const char *strComm,int *nHandle)\n    }\n\npublic static void main(String[] args) throws Exception {\n\n        System.load(\"D:\\\\code\\\\study\\\\my-study\\\\my-java\\\\src\\\\main\\\\resources\\\\DeviceDll\\\\ZT_DEV.dll\");\n        System.out.println(System.getProperty(\"java.library.path\"));\n\n//        System.loadLibrary(\"ZT_DEV\");\n\n        IntByReference intByReference = new IntByReference();\n        String msg = \"COM1:9600:E:8:1\";\n        System.out.println(ZT_DEV.lib.ZT_DEV_OpenDevice(1,msg,intByReference));\n        System.out.println(intByReference.getValue());\n\n    }\n```\n\n\n\n\n\n## 三、关系映射\n\n### 1. java与C++关系映射\n\n| C++     | Java           |\n| ------- | -------------- |\n| char *  | String         |\n| word    | short          |\n| byte    | byte           |\n| byte[]  | byte[]         |\n| dword   | int            |\n| long    | NativeLong     |\n| Void *  | Pointer        |\n| lpvoid  | Pointer        |\n| lpDword | IntByReference |\n| HWND    | HWND           |\n| char[]  | byte[]         |\n| byte *  | Pointer        |\n\n### 2. java 与 c 语言关系映射\n\n| Java           | 类型           | C类型原生表现                                                |\n| -------------- | -------------- | ------------------------------------------------------------ |\n| boolean        | int            | 32位整数(可定制)                                             |\n| byte           | char           | 8位整数                                                      |\n| char           | wchar_t        | 平台依赖                                                     |\n| short          | short          | 16位整数                                                     |\n| int            | int            | 32位整数                                                     |\n| long           | long,__int64   | 64位整数                                                     |\n| float          | float          | 32位浮点数                                                   |\n| double         | double         | 64位浮点数                                                   |\n| Buffer/Pointer | pointer        | 平台依赖(32或64位指针)                                       |\n| <T>            | pointer/array  | 32或64位指针(参数/返回值)邻接内存(结构体成员)                |\n| String         | char*          | /0结束的数组(nativeencodingorjna.encoding)                   |\n| WString        | wchar_t*       | /0结束的数组(unicode)                                        |\n| String[]       | char**         | /0结束的数组的数组                                           |\n| WString[]      | wchar_t**      | /0结束的宽字符数组的数组                                     |\n| Structure      | struct*/struct | 指向结构体的指针(参数或返回值)<br>(或者明确指定是结构体指针)结构体(结构体的成员)<br>(或者明确指定是结构体) |\n| Union          | union          | 等同于结构体                                                 |\n| Structure[]    | struct[]       | 结构体的数组，邻接内存                                       |\n| Callback       | <T>(*fp)()     | Java函数指针或原生函数指针                                   |\n| NativeMapped   | varies         | 依赖于定义                                                   |\n| NativeLong     | long           | 平台依赖(32或64位整数)                                       |\n| PointerType    | pointer        | 和Pointer相同                                                |\n\n## 四、类库地址\n\n### 4.1 windows\n\n```java\nSystem.getProperty(\"java.library.path\");\n```\n\n1. 和jre相关的目录\n2. 程序当前目录\n3. Windows目录\n4. 系统目录(system32)\n5. 系统环境变量path指定的目录\n\n### 4.2 linux 地址 及 jar启动\n\n> 在/etc/profile 后面加上一行 export LB_LIBRARY_PATH=[新加类库地址]\n>\n> ```java\n> java -jar -Djava.library.path=[新类库地址] XXX.jar\n> ```\n\n\n\n## 五、出现错误及解决\n\n1. **java.lang.UnsatisfiedLinkError: no dcrf32 in java.library.path ：系统没找到对应的dll文件**\n\n解决：\n\n- 项目启动时设置 java库地址\n\n![image-20210409171943084](\\使用c、c++方法\\image-20210409171943084.png)\n\n- 把dll文件，放置到java库中。具体地址为：System.getProperty(\"java.library.path\")\n\n- ```java\n  System.load(\"C://Documents and Settings//TestJNI.dll\"); //绝对路径\n  ```\n\n2. **java.lang.UnsatisfiedLinkError: XXX\\dcrf32.dll: Can't load IA 32-bit .dll on a AMD 64-bit platform：dll环境和当前环境不匹配**\n\n解决：把当前jdk环境改成32位\n\n\n\n3. **java.lang.Error: Invalid memory access**\n\n   类型映射错误，java接口继承Library中的方法，必须和dll文件中的方法一致，且类型能相互映射上。如：dll中 **_int*_** 必须映射为  **IntByReference**\n\n   \n\n4. **Error looking up function 'sum': 找不到指定的程序。**\n\n   java接口方法和dll方法未匹配\n\n   \n\n## 六、参考链接\n\n[1. Java加载dll或so库文件的路径 java.library.path](https://www.cnblogs.com/ylz8401/p/9605498.html)\n\n[2. JNA实战笔记汇总（二）——JNA和C / C ++的数据类型映射（dll函数回调、结构体、指针)](https://blog.csdn.net/hjing123/article/details/89709845)\n\n\n\n\n\n","source":"_posts/java学习/JNA/使用c、c++方法.md","raw":"---\ntitle: JNA的使用 \ndate: 2021-04-09 14:16:33 \ncategories: JAVA #分类\ntags: [java调用c++方法,JNA] \ndescription: java中使用dll类库中c、c++方法。\n---\n\n[TOC]\n\n## 一、JNA (Java Native Access)\n\nJNA(Java Native Access)框架是一个开源的Java框架，建立在经典的JNI的基础之上的一个框架。\n\n\n\n## 二、使用步骤\n\n>1. 需配置VM options: -Djava.library.path=**_[类库所在位置]_**\n>2. jdk 需要根据dll环境进行配置是64位还是32位\n\n### 1. 引入依赖\n\n```xml\n            <dependency>\n                <groupId>net.java.dev.jna</groupId>\n                <artifactId>jna</artifactId>\n                <version>5.5.0</version>\n            </dependency>\n```\n\n### 2. 设置启动环境及参数\n\n2.1 启动时设置java类库地址（or 把dll文件直接放在java类库路径下 or 使用System.load() 绝对路径加载）\n\n> VM options: -Djava.library.path=**_[类库所在位置]_**\n\n![image-20210409173144363](使用c、c++方法/image-20210409173144363.png)\n\n2.2 根据dll文件属性，配置对应的jre环境，64位 or 32位。\n\n### 3. 系统引用\n\n3.1 根据dll名称，把dll文件内容加载至内存（注：不能有文件名后缀，且该dll文件必须在文件类库目录下）\n\n```java\nSystem.loadLibrary(\"TestJNI\"); // 从java类库中加载\nSystem.load(\"C://Documents and Settings//TestJNI.dll\"); //or 从绝对路径中直接下载\n```\n\n### 4. 创建接口，通过接口引用\n\n```java\n// 继承Library or StdCallLibrary\npublic interface ZT_DEV extends Library {\n    // 通过反射加载对象\n        ZT_DEV lib = Native.load(\"ZT_DEV\", ZT_DEV.class);\n\n        // ZT_DEV_OpenDevice为ZT_DEV.dll中的一个方法.(注意类型转换)\n        int ZT_DEV_OpenDevice(int nDeviceType, String strComm, IntByReference nHandle);\n    \n    // c++ 中原生方法参数\n    // int ZT_DEV_OpenDevice(int nDeviceType,const char *strComm,int *nHandle)\n    }\n\npublic static void main(String[] args) throws Exception {\n\n        System.load(\"D:\\\\code\\\\study\\\\my-study\\\\my-java\\\\src\\\\main\\\\resources\\\\DeviceDll\\\\ZT_DEV.dll\");\n        System.out.println(System.getProperty(\"java.library.path\"));\n\n//        System.loadLibrary(\"ZT_DEV\");\n\n        IntByReference intByReference = new IntByReference();\n        String msg = \"COM1:9600:E:8:1\";\n        System.out.println(ZT_DEV.lib.ZT_DEV_OpenDevice(1,msg,intByReference));\n        System.out.println(intByReference.getValue());\n\n    }\n```\n\n\n\n\n\n## 三、关系映射\n\n### 1. java与C++关系映射\n\n| C++     | Java           |\n| ------- | -------------- |\n| char *  | String         |\n| word    | short          |\n| byte    | byte           |\n| byte[]  | byte[]         |\n| dword   | int            |\n| long    | NativeLong     |\n| Void *  | Pointer        |\n| lpvoid  | Pointer        |\n| lpDword | IntByReference |\n| HWND    | HWND           |\n| char[]  | byte[]         |\n| byte *  | Pointer        |\n\n### 2. java 与 c 语言关系映射\n\n| Java           | 类型           | C类型原生表现                                                |\n| -------------- | -------------- | ------------------------------------------------------------ |\n| boolean        | int            | 32位整数(可定制)                                             |\n| byte           | char           | 8位整数                                                      |\n| char           | wchar_t        | 平台依赖                                                     |\n| short          | short          | 16位整数                                                     |\n| int            | int            | 32位整数                                                     |\n| long           | long,__int64   | 64位整数                                                     |\n| float          | float          | 32位浮点数                                                   |\n| double         | double         | 64位浮点数                                                   |\n| Buffer/Pointer | pointer        | 平台依赖(32或64位指针)                                       |\n| <T>            | pointer/array  | 32或64位指针(参数/返回值)邻接内存(结构体成员)                |\n| String         | char*          | /0结束的数组(nativeencodingorjna.encoding)                   |\n| WString        | wchar_t*       | /0结束的数组(unicode)                                        |\n| String[]       | char**         | /0结束的数组的数组                                           |\n| WString[]      | wchar_t**      | /0结束的宽字符数组的数组                                     |\n| Structure      | struct*/struct | 指向结构体的指针(参数或返回值)<br>(或者明确指定是结构体指针)结构体(结构体的成员)<br>(或者明确指定是结构体) |\n| Union          | union          | 等同于结构体                                                 |\n| Structure[]    | struct[]       | 结构体的数组，邻接内存                                       |\n| Callback       | <T>(*fp)()     | Java函数指针或原生函数指针                                   |\n| NativeMapped   | varies         | 依赖于定义                                                   |\n| NativeLong     | long           | 平台依赖(32或64位整数)                                       |\n| PointerType    | pointer        | 和Pointer相同                                                |\n\n## 四、类库地址\n\n### 4.1 windows\n\n```java\nSystem.getProperty(\"java.library.path\");\n```\n\n1. 和jre相关的目录\n2. 程序当前目录\n3. Windows目录\n4. 系统目录(system32)\n5. 系统环境变量path指定的目录\n\n### 4.2 linux 地址 及 jar启动\n\n> 在/etc/profile 后面加上一行 export LB_LIBRARY_PATH=[新加类库地址]\n>\n> ```java\n> java -jar -Djava.library.path=[新类库地址] XXX.jar\n> ```\n\n\n\n## 五、出现错误及解决\n\n1. **java.lang.UnsatisfiedLinkError: no dcrf32 in java.library.path ：系统没找到对应的dll文件**\n\n解决：\n\n- 项目启动时设置 java库地址\n\n![image-20210409171943084](\\使用c、c++方法\\image-20210409171943084.png)\n\n- 把dll文件，放置到java库中。具体地址为：System.getProperty(\"java.library.path\")\n\n- ```java\n  System.load(\"C://Documents and Settings//TestJNI.dll\"); //绝对路径\n  ```\n\n2. **java.lang.UnsatisfiedLinkError: XXX\\dcrf32.dll: Can't load IA 32-bit .dll on a AMD 64-bit platform：dll环境和当前环境不匹配**\n\n解决：把当前jdk环境改成32位\n\n\n\n3. **java.lang.Error: Invalid memory access**\n\n   类型映射错误，java接口继承Library中的方法，必须和dll文件中的方法一致，且类型能相互映射上。如：dll中 **_int*_** 必须映射为  **IntByReference**\n\n   \n\n4. **Error looking up function 'sum': 找不到指定的程序。**\n\n   java接口方法和dll方法未匹配\n\n   \n\n## 六、参考链接\n\n[1. Java加载dll或so库文件的路径 java.library.path](https://www.cnblogs.com/ylz8401/p/9605498.html)\n\n[2. JNA实战笔记汇总（二）——JNA和C / C ++的数据类型映射（dll函数回调、结构体、指针)](https://blog.csdn.net/hjing123/article/details/89709845)\n\n\n\n\n\n","slug":"java学习/JNA/使用c、c++方法","published":1,"updated":"2021-04-21T03:32:16.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknqx8kew0006botkecw174w7","content":"<p>[TOC]</p>\n<h2 id=\"一、JNA-Java-Native-Access\"><a href=\"#一、JNA-Java-Native-Access\" class=\"headerlink\" title=\"一、JNA (Java Native Access)\"></a>一、JNA (Java Native Access)</h2><p>JNA(Java Native Access)框架是一个开源的Java框架，建立在经典的JNI的基础之上的一个框架。</p>\n<h2 id=\"二、使用步骤\"><a href=\"#二、使用步骤\" class=\"headerlink\" title=\"二、使用步骤\"></a>二、使用步骤</h2><blockquote>\n<ol>\n<li>需配置VM options: -Djava.library.path=<strong><em>[类库所在位置]</em></strong></li>\n<li>jdk 需要根据dll环境进行配置是64位还是32位</li>\n</ol>\n</blockquote>\n<h3 id=\"1-引入依赖\"><a href=\"#1-引入依赖\" class=\"headerlink\" title=\"1. 引入依赖\"></a>1. 引入依赖</h3><pre><code class=\"xml\">            &lt;dependency&gt;\n                &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt;\n                &lt;artifactId&gt;jna&lt;/artifactId&gt;\n                &lt;version&gt;5.5.0&lt;/version&gt;\n            &lt;/dependency&gt;</code></pre>\n<h3 id=\"2-设置启动环境及参数\"><a href=\"#2-设置启动环境及参数\" class=\"headerlink\" title=\"2. 设置启动环境及参数\"></a>2. 设置启动环境及参数</h3><p>2.1 启动时设置java类库地址（or 把dll文件直接放在java类库路径下 or 使用System.load() 绝对路径加载）</p>\n<blockquote>\n<p>VM options: -Djava.library.path=<strong><em>[类库所在位置]</em></strong></p>\n</blockquote>\n<p><img src=\"/2021/04/09/java%E5%AD%A6%E4%B9%A0/JNA/%E4%BD%BF%E7%94%A8c%E3%80%81c++%E6%96%B9%E6%B3%95/image-20210409173144363.png\" alt=\"image-20210409173144363\"></p>\n<p>2.2 根据dll文件属性，配置对应的jre环境，64位 or 32位。</p>\n<h3 id=\"3-系统引用\"><a href=\"#3-系统引用\" class=\"headerlink\" title=\"3. 系统引用\"></a>3. 系统引用</h3><p>3.1 根据dll名称，把dll文件内容加载至内存（注：不能有文件名后缀，且该dll文件必须在文件类库目录下）</p>\n<pre><code class=\"java\">System.loadLibrary(&quot;TestJNI&quot;); // 从java类库中加载\nSystem.load(&quot;C://Documents and Settings//TestJNI.dll&quot;); //or 从绝对路径中直接下载</code></pre>\n<h3 id=\"4-创建接口，通过接口引用\"><a href=\"#4-创建接口，通过接口引用\" class=\"headerlink\" title=\"4. 创建接口，通过接口引用\"></a>4. 创建接口，通过接口引用</h3><pre><code class=\"java\">// 继承Library or StdCallLibrary\npublic interface ZT_DEV extends Library &#123;\n    // 通过反射加载对象\n        ZT_DEV lib = Native.load(&quot;ZT_DEV&quot;, ZT_DEV.class);\n\n        // ZT_DEV_OpenDevice为ZT_DEV.dll中的一个方法.(注意类型转换)\n        int ZT_DEV_OpenDevice(int nDeviceType, String strComm, IntByReference nHandle);\n\n    // c++ 中原生方法参数\n    // int ZT_DEV_OpenDevice(int nDeviceType,const char *strComm,int *nHandle)\n    &#125;\n\npublic static void main(String[] args) throws Exception &#123;\n\n        System.load(&quot;D:\\\\code\\\\study\\\\my-study\\\\my-java\\\\src\\\\main\\\\resources\\\\DeviceDll\\\\ZT_DEV.dll&quot;);\n        System.out.println(System.getProperty(&quot;java.library.path&quot;));\n\n//        System.loadLibrary(&quot;ZT_DEV&quot;);\n\n        IntByReference intByReference = new IntByReference();\n        String msg = &quot;COM1:9600:E:8:1&quot;;\n        System.out.println(ZT_DEV.lib.ZT_DEV_OpenDevice(1,msg,intByReference));\n        System.out.println(intByReference.getValue());\n\n    &#125;</code></pre>\n<h2 id=\"三、关系映射\"><a href=\"#三、关系映射\" class=\"headerlink\" title=\"三、关系映射\"></a>三、关系映射</h2><h3 id=\"1-java与C-关系映射\"><a href=\"#1-java与C-关系映射\" class=\"headerlink\" title=\"1. java与C++关系映射\"></a>1. java与C++关系映射</h3><table>\n<thead>\n<tr>\n<th>C++</th>\n<th>Java</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>char *</td>\n<td>String</td>\n</tr>\n<tr>\n<td>word</td>\n<td>short</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>byte</td>\n</tr>\n<tr>\n<td>byte[]</td>\n<td>byte[]</td>\n</tr>\n<tr>\n<td>dword</td>\n<td>int</td>\n</tr>\n<tr>\n<td>long</td>\n<td>NativeLong</td>\n</tr>\n<tr>\n<td>Void *</td>\n<td>Pointer</td>\n</tr>\n<tr>\n<td>lpvoid</td>\n<td>Pointer</td>\n</tr>\n<tr>\n<td>lpDword</td>\n<td>IntByReference</td>\n</tr>\n<tr>\n<td>HWND</td>\n<td>HWND</td>\n</tr>\n<tr>\n<td>char[]</td>\n<td>byte[]</td>\n</tr>\n<tr>\n<td>byte *</td>\n<td>Pointer</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-java-与-c-语言关系映射\"><a href=\"#2-java-与-c-语言关系映射\" class=\"headerlink\" title=\"2. java 与 c 语言关系映射\"></a>2. java 与 c 语言关系映射</h3><table>\n<thead>\n<tr>\n<th>Java</th>\n<th>类型</th>\n<th>C类型原生表现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean</td>\n<td>int</td>\n<td>32位整数(可定制)</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>char</td>\n<td>8位整数</td>\n</tr>\n<tr>\n<td>char</td>\n<td>wchar_t</td>\n<td>平台依赖</td>\n</tr>\n<tr>\n<td>short</td>\n<td>short</td>\n<td>16位整数</td>\n</tr>\n<tr>\n<td>int</td>\n<td>int</td>\n<td>32位整数</td>\n</tr>\n<tr>\n<td>long</td>\n<td>long,__int64</td>\n<td>64位整数</td>\n</tr>\n<tr>\n<td>float</td>\n<td>float</td>\n<td>32位浮点数</td>\n</tr>\n<tr>\n<td>double</td>\n<td>double</td>\n<td>64位浮点数</td>\n</tr>\n<tr>\n<td>Buffer/Pointer</td>\n<td>pointer</td>\n<td>平台依赖(32或64位指针)</td>\n</tr>\n<tr>\n<td><T></T></td>\n<td>pointer/array</td>\n<td>32或64位指针(参数/返回值)邻接内存(结构体成员)</td>\n</tr>\n<tr>\n<td>String</td>\n<td>char*</td>\n<td>/0结束的数组(nativeencodingorjna.encoding)</td>\n</tr>\n<tr>\n<td>WString</td>\n<td>wchar_t*</td>\n<td>/0结束的数组(unicode)</td>\n</tr>\n<tr>\n<td>String[]</td>\n<td>char**</td>\n<td>/0结束的数组的数组</td>\n</tr>\n<tr>\n<td>WString[]</td>\n<td>wchar_t**</td>\n<td>/0结束的宽字符数组的数组</td>\n</tr>\n<tr>\n<td>Structure</td>\n<td>struct*/struct</td>\n<td>指向结构体的指针(参数或返回值)<br>(或者明确指定是结构体指针)结构体(结构体的成员)<br>(或者明确指定是结构体)</td>\n</tr>\n<tr>\n<td>Union</td>\n<td>union</td>\n<td>等同于结构体</td>\n</tr>\n<tr>\n<td>Structure[]</td>\n<td>struct[]</td>\n<td>结构体的数组，邻接内存</td>\n</tr>\n<tr>\n<td>Callback</td>\n<td><T>(*fp)()</T></td>\n<td>Java函数指针或原生函数指针</td>\n</tr>\n<tr>\n<td>NativeMapped</td>\n<td>varies</td>\n<td>依赖于定义</td>\n</tr>\n<tr>\n<td>NativeLong</td>\n<td>long</td>\n<td>平台依赖(32或64位整数)</td>\n</tr>\n<tr>\n<td>PointerType</td>\n<td>pointer</td>\n<td>和Pointer相同</td>\n</tr>\n</tbody></table>\n<h2 id=\"四、类库地址\"><a href=\"#四、类库地址\" class=\"headerlink\" title=\"四、类库地址\"></a>四、类库地址</h2><h3 id=\"4-1-windows\"><a href=\"#4-1-windows\" class=\"headerlink\" title=\"4.1 windows\"></a>4.1 windows</h3><pre><code class=\"java\">System.getProperty(&quot;java.library.path&quot;);</code></pre>\n<ol>\n<li>和jre相关的目录</li>\n<li>程序当前目录</li>\n<li>Windows目录</li>\n<li>系统目录(system32)</li>\n<li>系统环境变量path指定的目录</li>\n</ol>\n<h3 id=\"4-2-linux-地址-及-jar启动\"><a href=\"#4-2-linux-地址-及-jar启动\" class=\"headerlink\" title=\"4.2 linux 地址 及 jar启动\"></a>4.2 linux 地址 及 jar启动</h3><blockquote>\n<p>在/etc/profile 后面加上一行 export LB_LIBRARY_PATH=[新加类库地址]</p>\n<pre><code class=\"java\">java -jar -Djava.library.path=[新类库地址] XXX.jar</code></pre>\n</blockquote>\n<h2 id=\"五、出现错误及解决\"><a href=\"#五、出现错误及解决\" class=\"headerlink\" title=\"五、出现错误及解决\"></a>五、出现错误及解决</h2><ol>\n<li><strong>java.lang.UnsatisfiedLinkError: no dcrf32 in java.library.path ：系统没找到对应的dll文件</strong></li>\n</ol>\n<p>解决：</p>\n<ul>\n<li>项目启动时设置 java库地址</li>\n</ul>\n<p><img src=\"/2021/04/09/java%E5%AD%A6%E4%B9%A0/JNA/%E4%BD%BF%E7%94%A8c%E3%80%81c++%E6%96%B9%E6%B3%95/%5C%E4%BD%BF%E7%94%A8c%E3%80%81c++%E6%96%B9%E6%B3%95%5Cimage-20210409171943084.png\" alt=\"image-20210409171943084\"></p>\n<ul>\n<li><p>把dll文件，放置到java库中。具体地址为：System.getProperty(“java.library.path”)</p>\n</li>\n<li><pre><code class=\"java\">System.load(&quot;C://Documents and Settings//TestJNI.dll&quot;); //绝对路径</code></pre>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>java.lang.UnsatisfiedLinkError: XXX\\dcrf32.dll: Can’t load IA 32-bit .dll on a AMD 64-bit platform：dll环境和当前环境不匹配</strong></li>\n</ol>\n<p>解决：把当前jdk环境改成32位</p>\n<ol start=\"3\">\n<li><p><strong>java.lang.Error: Invalid memory access</strong></p>\n<p>类型映射错误，java接口继承Library中的方法，必须和dll文件中的方法一致，且类型能相互映射上。如：dll中 *<em>_int</em>_** 必须映射为  <strong>IntByReference</strong></p>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p><strong>Error looking up function ‘sum’: 找不到指定的程序。</strong></p>\n<p>java接口方法和dll方法未匹配</p>\n</li>\n</ol>\n<h2 id=\"六、参考链接\"><a href=\"#六、参考链接\" class=\"headerlink\" title=\"六、参考链接\"></a>六、参考链接</h2><p><a href=\"https://www.cnblogs.com/ylz8401/p/9605498.html\">1. Java加载dll或so库文件的路径 java.library.path</a></p>\n<p><a href=\"https://blog.csdn.net/hjing123/article/details/89709845\">2. JNA实战笔记汇总（二）——JNA和C / C ++的数据类型映射（dll函数回调、结构体、指针)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h2 id=\"一、JNA-Java-Native-Access\"><a href=\"#一、JNA-Java-Native-Access\" class=\"headerlink\" title=\"一、JNA (Java Native Access)\"></a>一、JNA (Java Native Access)</h2><p>JNA(Java Native Access)框架是一个开源的Java框架，建立在经典的JNI的基础之上的一个框架。</p>\n<h2 id=\"二、使用步骤\"><a href=\"#二、使用步骤\" class=\"headerlink\" title=\"二、使用步骤\"></a>二、使用步骤</h2><blockquote>\n<ol>\n<li>需配置VM options: -Djava.library.path=<strong><em>[类库所在位置]</em></strong></li>\n<li>jdk 需要根据dll环境进行配置是64位还是32位</li>\n</ol>\n</blockquote>\n<h3 id=\"1-引入依赖\"><a href=\"#1-引入依赖\" class=\"headerlink\" title=\"1. 引入依赖\"></a>1. 引入依赖</h3><pre><code class=\"xml\">            &lt;dependency&gt;\n                &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt;\n                &lt;artifactId&gt;jna&lt;/artifactId&gt;\n                &lt;version&gt;5.5.0&lt;/version&gt;\n            &lt;/dependency&gt;</code></pre>\n<h3 id=\"2-设置启动环境及参数\"><a href=\"#2-设置启动环境及参数\" class=\"headerlink\" title=\"2. 设置启动环境及参数\"></a>2. 设置启动环境及参数</h3><p>2.1 启动时设置java类库地址（or 把dll文件直接放在java类库路径下 or 使用System.load() 绝对路径加载）</p>\n<blockquote>\n<p>VM options: -Djava.library.path=<strong><em>[类库所在位置]</em></strong></p>\n</blockquote>\n<p><img src=\"/2021/04/09/java%E5%AD%A6%E4%B9%A0/JNA/%E4%BD%BF%E7%94%A8c%E3%80%81c++%E6%96%B9%E6%B3%95/image-20210409173144363.png\" alt=\"image-20210409173144363\"></p>\n<p>2.2 根据dll文件属性，配置对应的jre环境，64位 or 32位。</p>\n<h3 id=\"3-系统引用\"><a href=\"#3-系统引用\" class=\"headerlink\" title=\"3. 系统引用\"></a>3. 系统引用</h3><p>3.1 根据dll名称，把dll文件内容加载至内存（注：不能有文件名后缀，且该dll文件必须在文件类库目录下）</p>\n<pre><code class=\"java\">System.loadLibrary(&quot;TestJNI&quot;); // 从java类库中加载\nSystem.load(&quot;C://Documents and Settings//TestJNI.dll&quot;); //or 从绝对路径中直接下载</code></pre>\n<h3 id=\"4-创建接口，通过接口引用\"><a href=\"#4-创建接口，通过接口引用\" class=\"headerlink\" title=\"4. 创建接口，通过接口引用\"></a>4. 创建接口，通过接口引用</h3><pre><code class=\"java\">// 继承Library or StdCallLibrary\npublic interface ZT_DEV extends Library &#123;\n    // 通过反射加载对象\n        ZT_DEV lib = Native.load(&quot;ZT_DEV&quot;, ZT_DEV.class);\n\n        // ZT_DEV_OpenDevice为ZT_DEV.dll中的一个方法.(注意类型转换)\n        int ZT_DEV_OpenDevice(int nDeviceType, String strComm, IntByReference nHandle);\n\n    // c++ 中原生方法参数\n    // int ZT_DEV_OpenDevice(int nDeviceType,const char *strComm,int *nHandle)\n    &#125;\n\npublic static void main(String[] args) throws Exception &#123;\n\n        System.load(&quot;D:\\\\code\\\\study\\\\my-study\\\\my-java\\\\src\\\\main\\\\resources\\\\DeviceDll\\\\ZT_DEV.dll&quot;);\n        System.out.println(System.getProperty(&quot;java.library.path&quot;));\n\n//        System.loadLibrary(&quot;ZT_DEV&quot;);\n\n        IntByReference intByReference = new IntByReference();\n        String msg = &quot;COM1:9600:E:8:1&quot;;\n        System.out.println(ZT_DEV.lib.ZT_DEV_OpenDevice(1,msg,intByReference));\n        System.out.println(intByReference.getValue());\n\n    &#125;</code></pre>\n<h2 id=\"三、关系映射\"><a href=\"#三、关系映射\" class=\"headerlink\" title=\"三、关系映射\"></a>三、关系映射</h2><h3 id=\"1-java与C-关系映射\"><a href=\"#1-java与C-关系映射\" class=\"headerlink\" title=\"1. java与C++关系映射\"></a>1. java与C++关系映射</h3><table>\n<thead>\n<tr>\n<th>C++</th>\n<th>Java</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>char *</td>\n<td>String</td>\n</tr>\n<tr>\n<td>word</td>\n<td>short</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>byte</td>\n</tr>\n<tr>\n<td>byte[]</td>\n<td>byte[]</td>\n</tr>\n<tr>\n<td>dword</td>\n<td>int</td>\n</tr>\n<tr>\n<td>long</td>\n<td>NativeLong</td>\n</tr>\n<tr>\n<td>Void *</td>\n<td>Pointer</td>\n</tr>\n<tr>\n<td>lpvoid</td>\n<td>Pointer</td>\n</tr>\n<tr>\n<td>lpDword</td>\n<td>IntByReference</td>\n</tr>\n<tr>\n<td>HWND</td>\n<td>HWND</td>\n</tr>\n<tr>\n<td>char[]</td>\n<td>byte[]</td>\n</tr>\n<tr>\n<td>byte *</td>\n<td>Pointer</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-java-与-c-语言关系映射\"><a href=\"#2-java-与-c-语言关系映射\" class=\"headerlink\" title=\"2. java 与 c 语言关系映射\"></a>2. java 与 c 语言关系映射</h3><table>\n<thead>\n<tr>\n<th>Java</th>\n<th>类型</th>\n<th>C类型原生表现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean</td>\n<td>int</td>\n<td>32位整数(可定制)</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>char</td>\n<td>8位整数</td>\n</tr>\n<tr>\n<td>char</td>\n<td>wchar_t</td>\n<td>平台依赖</td>\n</tr>\n<tr>\n<td>short</td>\n<td>short</td>\n<td>16位整数</td>\n</tr>\n<tr>\n<td>int</td>\n<td>int</td>\n<td>32位整数</td>\n</tr>\n<tr>\n<td>long</td>\n<td>long,__int64</td>\n<td>64位整数</td>\n</tr>\n<tr>\n<td>float</td>\n<td>float</td>\n<td>32位浮点数</td>\n</tr>\n<tr>\n<td>double</td>\n<td>double</td>\n<td>64位浮点数</td>\n</tr>\n<tr>\n<td>Buffer/Pointer</td>\n<td>pointer</td>\n<td>平台依赖(32或64位指针)</td>\n</tr>\n<tr>\n<td><T></T></td>\n<td>pointer/array</td>\n<td>32或64位指针(参数/返回值)邻接内存(结构体成员)</td>\n</tr>\n<tr>\n<td>String</td>\n<td>char*</td>\n<td>/0结束的数组(nativeencodingorjna.encoding)</td>\n</tr>\n<tr>\n<td>WString</td>\n<td>wchar_t*</td>\n<td>/0结束的数组(unicode)</td>\n</tr>\n<tr>\n<td>String[]</td>\n<td>char**</td>\n<td>/0结束的数组的数组</td>\n</tr>\n<tr>\n<td>WString[]</td>\n<td>wchar_t**</td>\n<td>/0结束的宽字符数组的数组</td>\n</tr>\n<tr>\n<td>Structure</td>\n<td>struct*/struct</td>\n<td>指向结构体的指针(参数或返回值)<br>(或者明确指定是结构体指针)结构体(结构体的成员)<br>(或者明确指定是结构体)</td>\n</tr>\n<tr>\n<td>Union</td>\n<td>union</td>\n<td>等同于结构体</td>\n</tr>\n<tr>\n<td>Structure[]</td>\n<td>struct[]</td>\n<td>结构体的数组，邻接内存</td>\n</tr>\n<tr>\n<td>Callback</td>\n<td><T>(*fp)()</T></td>\n<td>Java函数指针或原生函数指针</td>\n</tr>\n<tr>\n<td>NativeMapped</td>\n<td>varies</td>\n<td>依赖于定义</td>\n</tr>\n<tr>\n<td>NativeLong</td>\n<td>long</td>\n<td>平台依赖(32或64位整数)</td>\n</tr>\n<tr>\n<td>PointerType</td>\n<td>pointer</td>\n<td>和Pointer相同</td>\n</tr>\n</tbody></table>\n<h2 id=\"四、类库地址\"><a href=\"#四、类库地址\" class=\"headerlink\" title=\"四、类库地址\"></a>四、类库地址</h2><h3 id=\"4-1-windows\"><a href=\"#4-1-windows\" class=\"headerlink\" title=\"4.1 windows\"></a>4.1 windows</h3><pre><code class=\"java\">System.getProperty(&quot;java.library.path&quot;);</code></pre>\n<ol>\n<li>和jre相关的目录</li>\n<li>程序当前目录</li>\n<li>Windows目录</li>\n<li>系统目录(system32)</li>\n<li>系统环境变量path指定的目录</li>\n</ol>\n<h3 id=\"4-2-linux-地址-及-jar启动\"><a href=\"#4-2-linux-地址-及-jar启动\" class=\"headerlink\" title=\"4.2 linux 地址 及 jar启动\"></a>4.2 linux 地址 及 jar启动</h3><blockquote>\n<p>在/etc/profile 后面加上一行 export LB_LIBRARY_PATH=[新加类库地址]</p>\n<pre><code class=\"java\">java -jar -Djava.library.path=[新类库地址] XXX.jar</code></pre>\n</blockquote>\n<h2 id=\"五、出现错误及解决\"><a href=\"#五、出现错误及解决\" class=\"headerlink\" title=\"五、出现错误及解决\"></a>五、出现错误及解决</h2><ol>\n<li><strong>java.lang.UnsatisfiedLinkError: no dcrf32 in java.library.path ：系统没找到对应的dll文件</strong></li>\n</ol>\n<p>解决：</p>\n<ul>\n<li>项目启动时设置 java库地址</li>\n</ul>\n<p><img src=\"/2021/04/09/java%E5%AD%A6%E4%B9%A0/JNA/%E4%BD%BF%E7%94%A8c%E3%80%81c++%E6%96%B9%E6%B3%95/%5C%E4%BD%BF%E7%94%A8c%E3%80%81c++%E6%96%B9%E6%B3%95%5Cimage-20210409171943084.png\" alt=\"image-20210409171943084\"></p>\n<ul>\n<li><p>把dll文件，放置到java库中。具体地址为：System.getProperty(“java.library.path”)</p>\n</li>\n<li><pre><code class=\"java\">System.load(&quot;C://Documents and Settings//TestJNI.dll&quot;); //绝对路径</code></pre>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>java.lang.UnsatisfiedLinkError: XXX\\dcrf32.dll: Can’t load IA 32-bit .dll on a AMD 64-bit platform：dll环境和当前环境不匹配</strong></li>\n</ol>\n<p>解决：把当前jdk环境改成32位</p>\n<ol start=\"3\">\n<li><p><strong>java.lang.Error: Invalid memory access</strong></p>\n<p>类型映射错误，java接口继承Library中的方法，必须和dll文件中的方法一致，且类型能相互映射上。如：dll中 *<em>_int</em>_** 必须映射为  <strong>IntByReference</strong></p>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p><strong>Error looking up function ‘sum’: 找不到指定的程序。</strong></p>\n<p>java接口方法和dll方法未匹配</p>\n</li>\n</ol>\n<h2 id=\"六、参考链接\"><a href=\"#六、参考链接\" class=\"headerlink\" title=\"六、参考链接\"></a>六、参考链接</h2><p><a href=\"https://www.cnblogs.com/ylz8401/p/9605498.html\">1. Java加载dll或so库文件的路径 java.library.path</a></p>\n<p><a href=\"https://blog.csdn.net/hjing123/article/details/89709845\">2. JNA实战笔记汇总（二）——JNA和C / C ++的数据类型映射（dll函数回调、结构体、指针)</a></p>\n"},{"title":"位运算","date":"2021-03-08T06:16:33.000Z","description":"java中位运算的使用及相关应用场景。","_content":"\n##  一、按位与&操作\n\n[TOC]\n\n### 1. 定义\n\n​\t& 与运算 两个位都是 1 时，结果才为 1，否则为 0。\n\n```java\n  1 0 0 1 1\n& 1 1 0 0 1\n------------------------------\n  1 0 0 0 1\n```\n\n### 2. 应用场景\n\n#### 2.1 奇偶性判断\n\n```java\nn&1 == 0 则为偶数\n```\n\n#### 2.2 判断n是否是2的正整数幂\n\n​\t原理：2的正整数幂始终比 前一个数字 多一个0\n\n```java\nn&(n-1) == 0 为2的正整数幂\neg:\n    n  = 16 = 1 0 0 0 0\n & n-1 = 15 = 0 1 1 1 1\n------------------------------ \n              0\n```\n\n#### 2.3 统计n中1的个数\n\n1. 判断奇偶，计数器+1，右移（只能正整数，负数死循环）\n\n   ```java\n   int count1(int n){\n       // 负数取绝对值\n       n = n < 0 ? Math.abs(n) : n;\n       int count = 0;\n       while (n!=0){\n           if((n&1) != 0){\n               count++;\n           }\n           n>>=1;\n       }\n       return count;\n   }\n   ```\n\n2. 根据最大正整数幂\n\n    ```java\n    int count1(int n){\n        // 负数取绝对值\n        n = n < 0 ? Math.abs(n) : n;\n        int count = 0;\n        while (n!=0){\n            n = (n - 1) & n;\n            count++;\n        }\n        return count;\n    }\n    ```\n\n## 二、 按位或运算 |\n\n### 1. 定义\n\n​\t\t| 或运算 两个位都是 0 时，结果才为 0，否则为 1。\n\n```java\n  1 0 0 1 1\n| 1 1 0 0 1\n------------------------------\n  1 1 0 1 1\n```\n\n\n\n## 三、异或运算 ^ \n\n### 1. 定义\n\n​\t\t^ 异或运算，两个位相同则为 0，不同则为 1。\n\n```java\n  1 0 0 1 1\n^ 1 1 0 0 1\n-----------------------------\n  0 1 0 1 0\n```\n\n## 四、取反运算 ~\n\n### 1. 定义\n\n​\t~ 取反运算，0 则变为 1，1 则变为 0。\n\n```java\n~ 1 0 0 1 1\n-----------------------------\n  0 1 1 0 0\n```\n\n## 五、左移运算 << \n\n### 1. 定义\t\n\n​\t<< 左移运算，向左进行移位操作，高位丢弃，低位补 0。\n\n```java\nint a = 8;\na << 3;\n移位前：0000 0000 0000 0000 0000 0000 0000 1000\n移位后：0000 0000 0000 0000 0000 0000 0100 0000\n```\n\n### 2. 应用场景\n\n1. 实现2的幂次方乘法   \n\n```java\nint a = 2;\na << 1; ---> a*2 = 4\na << 3; ---> a*2³ = 16\n```\n\n2. \n\n\n\n\n\n\n## 六、右移运算 >>\n\n### 1. 定义\n\n​\t\\>> 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位。\n\n```\nint a = 8;\na >> 3;\n移位前：0000 0000 0000 0000 0000 0000 0000 1000\n移位后：0000 0000 0000 0000 0000 0000 0000 0001\n\nint a = -8;\na >> 3;\n移位前：1111 1111 1111 1111 1111 1111 1111 1000\n移位前：1111 1111 1111 1111 1111 1111 1111 1111\n```\n\n\n\n\n\n## 参考\n\n\\- [位运算 之（1） 按位与（AND）& 操作](https://www.cnblogs.com/roamman/archive/2010/08/17/1801392.html)","source":"_posts/java学习/位运算/位运算.md","raw":"---\ntitle: 位运算 #文章页面上的显示名称，一般是中文\ndate: 2021-03-08 14:16:33 #文章生成时间，一般不改，当然也可以任意修改\ncategories: JAVA #分类\ntags: [按位与,位运算] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: java中位运算的使用及相关应用场景。\n---\n\n##  一、按位与&操作\n\n[TOC]\n\n### 1. 定义\n\n​\t& 与运算 两个位都是 1 时，结果才为 1，否则为 0。\n\n```java\n  1 0 0 1 1\n& 1 1 0 0 1\n------------------------------\n  1 0 0 0 1\n```\n\n### 2. 应用场景\n\n#### 2.1 奇偶性判断\n\n```java\nn&1 == 0 则为偶数\n```\n\n#### 2.2 判断n是否是2的正整数幂\n\n​\t原理：2的正整数幂始终比 前一个数字 多一个0\n\n```java\nn&(n-1) == 0 为2的正整数幂\neg:\n    n  = 16 = 1 0 0 0 0\n & n-1 = 15 = 0 1 1 1 1\n------------------------------ \n              0\n```\n\n#### 2.3 统计n中1的个数\n\n1. 判断奇偶，计数器+1，右移（只能正整数，负数死循环）\n\n   ```java\n   int count1(int n){\n       // 负数取绝对值\n       n = n < 0 ? Math.abs(n) : n;\n       int count = 0;\n       while (n!=0){\n           if((n&1) != 0){\n               count++;\n           }\n           n>>=1;\n       }\n       return count;\n   }\n   ```\n\n2. 根据最大正整数幂\n\n    ```java\n    int count1(int n){\n        // 负数取绝对值\n        n = n < 0 ? Math.abs(n) : n;\n        int count = 0;\n        while (n!=0){\n            n = (n - 1) & n;\n            count++;\n        }\n        return count;\n    }\n    ```\n\n## 二、 按位或运算 |\n\n### 1. 定义\n\n​\t\t| 或运算 两个位都是 0 时，结果才为 0，否则为 1。\n\n```java\n  1 0 0 1 1\n| 1 1 0 0 1\n------------------------------\n  1 1 0 1 1\n```\n\n\n\n## 三、异或运算 ^ \n\n### 1. 定义\n\n​\t\t^ 异或运算，两个位相同则为 0，不同则为 1。\n\n```java\n  1 0 0 1 1\n^ 1 1 0 0 1\n-----------------------------\n  0 1 0 1 0\n```\n\n## 四、取反运算 ~\n\n### 1. 定义\n\n​\t~ 取反运算，0 则变为 1，1 则变为 0。\n\n```java\n~ 1 0 0 1 1\n-----------------------------\n  0 1 1 0 0\n```\n\n## 五、左移运算 << \n\n### 1. 定义\t\n\n​\t<< 左移运算，向左进行移位操作，高位丢弃，低位补 0。\n\n```java\nint a = 8;\na << 3;\n移位前：0000 0000 0000 0000 0000 0000 0000 1000\n移位后：0000 0000 0000 0000 0000 0000 0100 0000\n```\n\n### 2. 应用场景\n\n1. 实现2的幂次方乘法   \n\n```java\nint a = 2;\na << 1; ---> a*2 = 4\na << 3; ---> a*2³ = 16\n```\n\n2. \n\n\n\n\n\n\n## 六、右移运算 >>\n\n### 1. 定义\n\n​\t\\>> 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位。\n\n```\nint a = 8;\na >> 3;\n移位前：0000 0000 0000 0000 0000 0000 0000 1000\n移位后：0000 0000 0000 0000 0000 0000 0000 0001\n\nint a = -8;\na >> 3;\n移位前：1111 1111 1111 1111 1111 1111 1111 1000\n移位前：1111 1111 1111 1111 1111 1111 1111 1111\n```\n\n\n\n\n\n## 参考\n\n\\- [位运算 之（1） 按位与（AND）& 操作](https://www.cnblogs.com/roamman/archive/2010/08/17/1801392.html)","slug":"java学习/位运算/位运算","published":1,"updated":"2021-03-25T06:56:08.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknqx8kf5000zbotk0oxy9ubm","content":"<h2 id=\"一、按位与-amp-操作\"><a href=\"#一、按位与-amp-操作\" class=\"headerlink\" title=\"一、按位与&amp;操作\"></a>一、按位与&amp;操作</h2><p>[TOC]</p>\n<h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​    &amp; 与运算 两个位都是 1 时，结果才为 1，否则为 0。</p>\n<pre><code class=\"java\">  1 0 0 1 1\n&amp; 1 1 0 0 1\n------------------------------\n  1 0 0 0 1</code></pre>\n<h3 id=\"2-应用场景\"><a href=\"#2-应用场景\" class=\"headerlink\" title=\"2. 应用场景\"></a>2. 应用场景</h3><h4 id=\"2-1-奇偶性判断\"><a href=\"#2-1-奇偶性判断\" class=\"headerlink\" title=\"2.1 奇偶性判断\"></a>2.1 奇偶性判断</h4><pre><code class=\"java\">n&amp;1 == 0 则为偶数</code></pre>\n<h4 id=\"2-2-判断n是否是2的正整数幂\"><a href=\"#2-2-判断n是否是2的正整数幂\" class=\"headerlink\" title=\"2.2 判断n是否是2的正整数幂\"></a>2.2 判断n是否是2的正整数幂</h4><p>​    原理：2的正整数幂始终比 前一个数字 多一个0</p>\n<pre><code class=\"java\">n&amp;(n-1) == 0 为2的正整数幂\neg:\n    n  = 16 = 1 0 0 0 0\n &amp; n-1 = 15 = 0 1 1 1 1\n------------------------------ \n              0</code></pre>\n<h4 id=\"2-3-统计n中1的个数\"><a href=\"#2-3-统计n中1的个数\" class=\"headerlink\" title=\"2.3 统计n中1的个数\"></a>2.3 统计n中1的个数</h4><ol>\n<li><p>判断奇偶，计数器+1，右移（只能正整数，负数死循环）</p>\n<pre><code class=\"java\">int count1(int n)&#123;\n    // 负数取绝对值\n    n = n &lt; 0 ? Math.abs(n) : n;\n    int count = 0;\n    while (n!=0)&#123;\n        if((n&amp;1) != 0)&#123;\n            count++;\n        &#125;\n        n&gt;&gt;=1;\n    &#125;\n    return count;\n&#125;</code></pre>\n</li>\n<li><p>根据最大正整数幂</p>\n<pre><code class=\"java\">int count1(int n)&#123;\n    // 负数取绝对值\n    n = n &lt; 0 ? Math.abs(n) : n;\n    int count = 0;\n    while (n!=0)&#123;\n        n = (n - 1) &amp; n;\n        count++;\n    &#125;\n    return count;\n&#125;</code></pre>\n</li>\n</ol>\n<h2 id=\"二、-按位或运算\"><a href=\"#二、-按位或运算\" class=\"headerlink\" title=\"二、 按位或运算 |\"></a>二、 按位或运算 |</h2><h3 id=\"1-定义-1\"><a href=\"#1-定义-1\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​        | 或运算 两个位都是 0 时，结果才为 0，否则为 1。</p>\n<pre><code class=\"java\">  1 0 0 1 1\n| 1 1 0 0 1\n------------------------------\n  1 1 0 1 1</code></pre>\n<h2 id=\"三、异或运算\"><a href=\"#三、异或运算\" class=\"headerlink\" title=\"三、异或运算 ^\"></a>三、异或运算 ^</h2><h3 id=\"1-定义-2\"><a href=\"#1-定义-2\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​        ^ 异或运算，两个位相同则为 0，不同则为 1。</p>\n<pre><code class=\"java\">  1 0 0 1 1\n^ 1 1 0 0 1\n-----------------------------\n  0 1 0 1 0</code></pre>\n<h2 id=\"四、取反运算\"><a href=\"#四、取反运算\" class=\"headerlink\" title=\"四、取反运算 ~\"></a>四、取反运算 ~</h2><h3 id=\"1-定义-3\"><a href=\"#1-定义-3\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​    ~ 取反运算，0 则变为 1，1 则变为 0。</p>\n<pre><code class=\"java\">~ 1 0 0 1 1\n-----------------------------\n  0 1 1 0 0</code></pre>\n<h2 id=\"五、左移运算-lt-lt\"><a href=\"#五、左移运算-lt-lt\" class=\"headerlink\" title=\"五、左移运算 &lt;&lt;\"></a>五、左移运算 &lt;&lt;</h2><h3 id=\"1-定义-4\"><a href=\"#1-定义-4\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​    &lt;&lt; 左移运算，向左进行移位操作，高位丢弃，低位补 0。</p>\n<pre><code class=\"java\">int a = 8;\na &lt;&lt; 3;\n移位前：0000 0000 0000 0000 0000 0000 0000 1000\n移位后：0000 0000 0000 0000 0000 0000 0100 0000</code></pre>\n<h3 id=\"2-应用场景-1\"><a href=\"#2-应用场景-1\" class=\"headerlink\" title=\"2. 应用场景\"></a>2. 应用场景</h3><ol>\n<li>实现2的幂次方乘法   </li>\n</ol>\n<pre><code class=\"java\">int a = 2;\na &lt;&lt; 1; ---&gt; a*2 = 4\na &lt;&lt; 3; ---&gt; a*2³ = 16</code></pre>\n<ol start=\"2\">\n<li></li>\n</ol>\n<h2 id=\"六、右移运算-gt-gt\"><a href=\"#六、右移运算-gt-gt\" class=\"headerlink\" title=\"六、右移运算 &gt;&gt;\"></a>六、右移运算 &gt;&gt;</h2><h3 id=\"1-定义-5\"><a href=\"#1-定义-5\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​    &gt;&gt; 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位。</p>\n<pre><code>int a = 8;\na &gt;&gt; 3;\n移位前：0000 0000 0000 0000 0000 0000 0000 1000\n移位后：0000 0000 0000 0000 0000 0000 0000 0001\n\nint a = -8;\na &gt;&gt; 3;\n移位前：1111 1111 1111 1111 1111 1111 1111 1000\n移位前：1111 1111 1111 1111 1111 1111 1111 1111</code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>- <a href=\"https://www.cnblogs.com/roamman/archive/2010/08/17/1801392.html\">位运算 之（1） 按位与（AND）&amp; 操作</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、按位与-amp-操作\"><a href=\"#一、按位与-amp-操作\" class=\"headerlink\" title=\"一、按位与&amp;操作\"></a>一、按位与&amp;操作</h2><p>[TOC]</p>\n<h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​    &amp; 与运算 两个位都是 1 时，结果才为 1，否则为 0。</p>\n<pre><code class=\"java\">  1 0 0 1 1\n&amp; 1 1 0 0 1\n------------------------------\n  1 0 0 0 1</code></pre>\n<h3 id=\"2-应用场景\"><a href=\"#2-应用场景\" class=\"headerlink\" title=\"2. 应用场景\"></a>2. 应用场景</h3><h4 id=\"2-1-奇偶性判断\"><a href=\"#2-1-奇偶性判断\" class=\"headerlink\" title=\"2.1 奇偶性判断\"></a>2.1 奇偶性判断</h4><pre><code class=\"java\">n&amp;1 == 0 则为偶数</code></pre>\n<h4 id=\"2-2-判断n是否是2的正整数幂\"><a href=\"#2-2-判断n是否是2的正整数幂\" class=\"headerlink\" title=\"2.2 判断n是否是2的正整数幂\"></a>2.2 判断n是否是2的正整数幂</h4><p>​    原理：2的正整数幂始终比 前一个数字 多一个0</p>\n<pre><code class=\"java\">n&amp;(n-1) == 0 为2的正整数幂\neg:\n    n  = 16 = 1 0 0 0 0\n &amp; n-1 = 15 = 0 1 1 1 1\n------------------------------ \n              0</code></pre>\n<h4 id=\"2-3-统计n中1的个数\"><a href=\"#2-3-统计n中1的个数\" class=\"headerlink\" title=\"2.3 统计n中1的个数\"></a>2.3 统计n中1的个数</h4><ol>\n<li><p>判断奇偶，计数器+1，右移（只能正整数，负数死循环）</p>\n<pre><code class=\"java\">int count1(int n)&#123;\n    // 负数取绝对值\n    n = n &lt; 0 ? Math.abs(n) : n;\n    int count = 0;\n    while (n!=0)&#123;\n        if((n&amp;1) != 0)&#123;\n            count++;\n        &#125;\n        n&gt;&gt;=1;\n    &#125;\n    return count;\n&#125;</code></pre>\n</li>\n<li><p>根据最大正整数幂</p>\n<pre><code class=\"java\">int count1(int n)&#123;\n    // 负数取绝对值\n    n = n &lt; 0 ? Math.abs(n) : n;\n    int count = 0;\n    while (n!=0)&#123;\n        n = (n - 1) &amp; n;\n        count++;\n    &#125;\n    return count;\n&#125;</code></pre>\n</li>\n</ol>\n<h2 id=\"二、-按位或运算\"><a href=\"#二、-按位或运算\" class=\"headerlink\" title=\"二、 按位或运算 |\"></a>二、 按位或运算 |</h2><h3 id=\"1-定义-1\"><a href=\"#1-定义-1\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​        | 或运算 两个位都是 0 时，结果才为 0，否则为 1。</p>\n<pre><code class=\"java\">  1 0 0 1 1\n| 1 1 0 0 1\n------------------------------\n  1 1 0 1 1</code></pre>\n<h2 id=\"三、异或运算\"><a href=\"#三、异或运算\" class=\"headerlink\" title=\"三、异或运算 ^\"></a>三、异或运算 ^</h2><h3 id=\"1-定义-2\"><a href=\"#1-定义-2\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​        ^ 异或运算，两个位相同则为 0，不同则为 1。</p>\n<pre><code class=\"java\">  1 0 0 1 1\n^ 1 1 0 0 1\n-----------------------------\n  0 1 0 1 0</code></pre>\n<h2 id=\"四、取反运算\"><a href=\"#四、取反运算\" class=\"headerlink\" title=\"四、取反运算 ~\"></a>四、取反运算 ~</h2><h3 id=\"1-定义-3\"><a href=\"#1-定义-3\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​    ~ 取反运算，0 则变为 1，1 则变为 0。</p>\n<pre><code class=\"java\">~ 1 0 0 1 1\n-----------------------------\n  0 1 1 0 0</code></pre>\n<h2 id=\"五、左移运算-lt-lt\"><a href=\"#五、左移运算-lt-lt\" class=\"headerlink\" title=\"五、左移运算 &lt;&lt;\"></a>五、左移运算 &lt;&lt;</h2><h3 id=\"1-定义-4\"><a href=\"#1-定义-4\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​    &lt;&lt; 左移运算，向左进行移位操作，高位丢弃，低位补 0。</p>\n<pre><code class=\"java\">int a = 8;\na &lt;&lt; 3;\n移位前：0000 0000 0000 0000 0000 0000 0000 1000\n移位后：0000 0000 0000 0000 0000 0000 0100 0000</code></pre>\n<h3 id=\"2-应用场景-1\"><a href=\"#2-应用场景-1\" class=\"headerlink\" title=\"2. 应用场景\"></a>2. 应用场景</h3><ol>\n<li>实现2的幂次方乘法   </li>\n</ol>\n<pre><code class=\"java\">int a = 2;\na &lt;&lt; 1; ---&gt; a*2 = 4\na &lt;&lt; 3; ---&gt; a*2³ = 16</code></pre>\n<ol start=\"2\">\n<li></li>\n</ol>\n<h2 id=\"六、右移运算-gt-gt\"><a href=\"#六、右移运算-gt-gt\" class=\"headerlink\" title=\"六、右移运算 &gt;&gt;\"></a>六、右移运算 &gt;&gt;</h2><h3 id=\"1-定义-5\"><a href=\"#1-定义-5\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>​    &gt;&gt; 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位。</p>\n<pre><code>int a = 8;\na &gt;&gt; 3;\n移位前：0000 0000 0000 0000 0000 0000 0000 1000\n移位后：0000 0000 0000 0000 0000 0000 0000 0001\n\nint a = -8;\na &gt;&gt; 3;\n移位前：1111 1111 1111 1111 1111 1111 1111 1000\n移位前：1111 1111 1111 1111 1111 1111 1111 1111</code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>- <a href=\"https://www.cnblogs.com/roamman/archive/2010/08/17/1801392.html\">位运算 之（1） 按位与（AND）&amp; 操作</a></p>\n"},{"title":"Comparable与Comparator","date":"2020-10-27T06:16:33.000Z","description":"详细讲解comparable及comparator的使用及用法。","_content":"\n## Comparable\n\n[TOC]\n\n```\nimport java.util.Objects;\n\n/**\n * 实现Comparator接口的类可以方便的排序， 覆写compareTo接口\n * @author zxl\n * @date 2020/10/27 18:00\n */\npublic class Student implements Comparable<Student>{\n\n    /*** 名字 */\n    private String name;\n\n    /*** 年龄 */\n    private int age;\n\n    /*** 分数 */\n    private float score;\n\n    /**\n     * 排序规则：以分数降序排序，若分数一致，则根据年龄升序排序\n     * @param o 比较参数\n     * @return 比较结果 -1大于   0等于   1小于\n     */\n    @Override\n    public int compareTo(Student o) {\n        /*\n         * this.age - o.age 升序\n         * o.score - this.score 降序\n         */\n        return Objects.equals(o.score,this.score) ? this.age - o.age : (int) (o.score - this.score);\n    }\n\n    public Student(String name, int age, float score) {\n        this.name = name;\n        this.age = age;\n        this.score = score;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", score=\" + score +\n                '}';\n    }\n}\n\n\npublic class Comparable01 {\n\n    public static void main(String args[]){\n        Student stu[] = {\n                new Student(\"张三\",20,90.0f),\n                new Student(\"李四\",22,90.0f),\n                new Student(\"王五\",20,99.0f),\n                new Student(\"赵六\",20,70.0f),\n                new Student(\"孙七\",22,100.0f)} ;\n        java.util.Arrays.sort(stu) ;    // 进行排序操作\n        for(int i=0;i<stu.length;i++){    // 循环输出数组中的内容\n            System.out.println(stu[i]) ;\n        }\n    }\n\n}\n\n```\n\n\n\n## Comparator\n\n```\npublic class Student {\n    /*** 名字 */\n    private String name;\n\n    /*** 年龄 */\n    private int age;\n\n    /*** 分数 */\n    private float score;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public float getScore() {\n        return score;\n    }\n\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    public Student(String name, int age, float score) {\n        this.name = name;\n        this.age = age;\n        this.score = score;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", score=\" + score +\n                '}';\n    }\n\n}\n\npublic class ComparatorTest {\n\n    public static void main(String[] args) {\n        Student stu[] = {\n                new Student(\"张三\",20,90.0f),\n                new Student(\"李四\",22,90.0f),\n                new Student(\"王五\",20,99.0f),\n                new Student(\"赵六\",20,70.0f),\n                new Student(\"孙七\",22,100.0f)} ;\n\n        // 排序方法一\n        java.util.Arrays.sort(stu, new Comparator<Student>() {\n            @Override\n            public int compare(Student o1, Student o2) {\n                /*\n                 * o1.param - o2.param 升序\n                 * o2.param - o1.param 降序\n                 */\n                return Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore());\n            }\n        }) ;\n\n        // 排序方法二 lambda方法\n        java.util.Arrays.sort(stu, (o1, o2) -> Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore())) ;\n\n\n        for(int i=0;i<stu.length;i++){    // 循环输出数组中的内容\n            System.out.println(stu[i]) ;\n        }\n    }\n\n    /**\n     * 排序方法三：该方法需新建一个java类使用，\n     * java.util.Arrays.sort(stu, new MyComparator());\n     */\n    class MyComparator implements Comparator<Student>{\n        @Override\n        public int compare(Student o1, Student o2) {\n            return Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore());\n        }\n    }\n\n}\n```\n\n## 两者比较\n\n<table>\n\t<tr>\n\t\t<th>属性</th>\n\t    <th>Comparable</th>\n\t    <th>Comparator</th>\n\t</tr >\n\t<tr>\n\t\t<td>适用场景</td>\n\t\t<td>集合内部定义实现</td>\n\t\t<td>集合外部实现排序</td>\n\t</tr>\n    <tr>\n\t\t<td>区别</td>\n\t\t<td>1. java.lang 包<br/>\n        \t2. 方法：int compareTo(Object o)\n        </td>\n\t\t<td>1. java.util 包<br/>\n        \t2. 方法：int compare(T o1, To2)\n        </td>\n\t</tr>\n    <tr>\n\t\t<td>原理</td>\n\t\t<td colspan=\"2\">基于红黑二叉树原理实现的</td>\n\t</tr>\n</table>\n\n| 返回值 | 含义 |\n| ------ | ---- |\n| -1     | 大于 |\n| 0      | 等于 |\n| 1      | 小于 |\n\n## 参考\n\n\\- [java中compareable和comparator的区别，比较器实现的原理！](https://blog.csdn.net/wilson27/article/details/90339765)","source":"_posts/java学习/工具包学习/Comparable与Comparator.md","raw":"---\ntitle: Comparable与Comparator #文章页面上的显示名称，一般是中文\ndate: 2020-10-27 14:16:33 #文章生成时间，一般不改，当然也可以任意修改\ncategories: JAVA #分类\ntags: [Comparable,Comparator,排序] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: 详细讲解comparable及comparator的使用及用法。\n---\n\n## Comparable\n\n[TOC]\n\n```\nimport java.util.Objects;\n\n/**\n * 实现Comparator接口的类可以方便的排序， 覆写compareTo接口\n * @author zxl\n * @date 2020/10/27 18:00\n */\npublic class Student implements Comparable<Student>{\n\n    /*** 名字 */\n    private String name;\n\n    /*** 年龄 */\n    private int age;\n\n    /*** 分数 */\n    private float score;\n\n    /**\n     * 排序规则：以分数降序排序，若分数一致，则根据年龄升序排序\n     * @param o 比较参数\n     * @return 比较结果 -1大于   0等于   1小于\n     */\n    @Override\n    public int compareTo(Student o) {\n        /*\n         * this.age - o.age 升序\n         * o.score - this.score 降序\n         */\n        return Objects.equals(o.score,this.score) ? this.age - o.age : (int) (o.score - this.score);\n    }\n\n    public Student(String name, int age, float score) {\n        this.name = name;\n        this.age = age;\n        this.score = score;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", score=\" + score +\n                '}';\n    }\n}\n\n\npublic class Comparable01 {\n\n    public static void main(String args[]){\n        Student stu[] = {\n                new Student(\"张三\",20,90.0f),\n                new Student(\"李四\",22,90.0f),\n                new Student(\"王五\",20,99.0f),\n                new Student(\"赵六\",20,70.0f),\n                new Student(\"孙七\",22,100.0f)} ;\n        java.util.Arrays.sort(stu) ;    // 进行排序操作\n        for(int i=0;i<stu.length;i++){    // 循环输出数组中的内容\n            System.out.println(stu[i]) ;\n        }\n    }\n\n}\n\n```\n\n\n\n## Comparator\n\n```\npublic class Student {\n    /*** 名字 */\n    private String name;\n\n    /*** 年龄 */\n    private int age;\n\n    /*** 分数 */\n    private float score;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public float getScore() {\n        return score;\n    }\n\n    public void setScore(float score) {\n        this.score = score;\n    }\n\n    public Student(String name, int age, float score) {\n        this.name = name;\n        this.age = age;\n        this.score = score;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", score=\" + score +\n                '}';\n    }\n\n}\n\npublic class ComparatorTest {\n\n    public static void main(String[] args) {\n        Student stu[] = {\n                new Student(\"张三\",20,90.0f),\n                new Student(\"李四\",22,90.0f),\n                new Student(\"王五\",20,99.0f),\n                new Student(\"赵六\",20,70.0f),\n                new Student(\"孙七\",22,100.0f)} ;\n\n        // 排序方法一\n        java.util.Arrays.sort(stu, new Comparator<Student>() {\n            @Override\n            public int compare(Student o1, Student o2) {\n                /*\n                 * o1.param - o2.param 升序\n                 * o2.param - o1.param 降序\n                 */\n                return Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore());\n            }\n        }) ;\n\n        // 排序方法二 lambda方法\n        java.util.Arrays.sort(stu, (o1, o2) -> Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore())) ;\n\n\n        for(int i=0;i<stu.length;i++){    // 循环输出数组中的内容\n            System.out.println(stu[i]) ;\n        }\n    }\n\n    /**\n     * 排序方法三：该方法需新建一个java类使用，\n     * java.util.Arrays.sort(stu, new MyComparator());\n     */\n    class MyComparator implements Comparator<Student>{\n        @Override\n        public int compare(Student o1, Student o2) {\n            return Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore());\n        }\n    }\n\n}\n```\n\n## 两者比较\n\n<table>\n\t<tr>\n\t\t<th>属性</th>\n\t    <th>Comparable</th>\n\t    <th>Comparator</th>\n\t</tr >\n\t<tr>\n\t\t<td>适用场景</td>\n\t\t<td>集合内部定义实现</td>\n\t\t<td>集合外部实现排序</td>\n\t</tr>\n    <tr>\n\t\t<td>区别</td>\n\t\t<td>1. java.lang 包<br/>\n        \t2. 方法：int compareTo(Object o)\n        </td>\n\t\t<td>1. java.util 包<br/>\n        \t2. 方法：int compare(T o1, To2)\n        </td>\n\t</tr>\n    <tr>\n\t\t<td>原理</td>\n\t\t<td colspan=\"2\">基于红黑二叉树原理实现的</td>\n\t</tr>\n</table>\n\n| 返回值 | 含义 |\n| ------ | ---- |\n| -1     | 大于 |\n| 0      | 等于 |\n| 1      | 小于 |\n\n## 参考\n\n\\- [java中compareable和comparator的区别，比较器实现的原理！](https://blog.csdn.net/wilson27/article/details/90339765)","slug":"java学习/工具包学习/Comparable与Comparator","published":1,"updated":"2021-03-31T02:38:37.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknqx8kf60010botkgp56c6v5","content":"<h2 id=\"Comparable\"><a href=\"#Comparable\" class=\"headerlink\" title=\"Comparable\"></a>Comparable</h2><p>[TOC]</p>\n<pre><code>import java.util.Objects;\n\n/**\n * 实现Comparator接口的类可以方便的排序， 覆写compareTo接口\n * @author zxl\n * @date 2020/10/27 18:00\n */\npublic class Student implements Comparable&lt;Student&gt;&#123;\n\n    /*** 名字 */\n    private String name;\n\n    /*** 年龄 */\n    private int age;\n\n    /*** 分数 */\n    private float score;\n\n    /**\n     * 排序规则：以分数降序排序，若分数一致，则根据年龄升序排序\n     * @param o 比较参数\n     * @return 比较结果 -1大于   0等于   1小于\n     */\n    @Override\n    public int compareTo(Student o) &#123;\n        /*\n         * this.age - o.age 升序\n         * o.score - this.score 降序\n         */\n        return Objects.equals(o.score,this.score) ? this.age - o.age : (int) (o.score - this.score);\n    &#125;\n\n    public Student(String name, int age, float score) &#123;\n        this.name = name;\n        this.age = age;\n        this.score = score;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &quot;, score=&quot; + score +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\n\npublic class Comparable01 &#123;\n\n    public static void main(String args[])&#123;\n        Student stu[] = &#123;\n                new Student(&quot;张三&quot;,20,90.0f),\n                new Student(&quot;李四&quot;,22,90.0f),\n                new Student(&quot;王五&quot;,20,99.0f),\n                new Student(&quot;赵六&quot;,20,70.0f),\n                new Student(&quot;孙七&quot;,22,100.0f)&#125; ;\n        java.util.Arrays.sort(stu) ;    // 进行排序操作\n        for(int i=0;i&lt;stu.length;i++)&#123;    // 循环输出数组中的内容\n            System.out.println(stu[i]) ;\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<h2 id=\"Comparator\"><a href=\"#Comparator\" class=\"headerlink\" title=\"Comparator\"></a>Comparator</h2><pre><code>public class Student &#123;\n    /*** 名字 */\n    private String name;\n\n    /*** 年龄 */\n    private int age;\n\n    /*** 分数 */\n    private float score;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public float getScore() &#123;\n        return score;\n    &#125;\n\n    public void setScore(float score) &#123;\n        this.score = score;\n    &#125;\n\n    public Student(String name, int age, float score) &#123;\n        this.name = name;\n        this.age = age;\n        this.score = score;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &quot;, score=&quot; + score +\n                &#39;&#125;&#39;;\n    &#125;\n\n&#125;\n\npublic class ComparatorTest &#123;\n\n    public static void main(String[] args) &#123;\n        Student stu[] = &#123;\n                new Student(&quot;张三&quot;,20,90.0f),\n                new Student(&quot;李四&quot;,22,90.0f),\n                new Student(&quot;王五&quot;,20,99.0f),\n                new Student(&quot;赵六&quot;,20,70.0f),\n                new Student(&quot;孙七&quot;,22,100.0f)&#125; ;\n\n        // 排序方法一\n        java.util.Arrays.sort(stu, new Comparator&lt;Student&gt;() &#123;\n            @Override\n            public int compare(Student o1, Student o2) &#123;\n                /*\n                 * o1.param - o2.param 升序\n                 * o2.param - o1.param 降序\n                 */\n                return Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore());\n            &#125;\n        &#125;) ;\n\n        // 排序方法二 lambda方法\n        java.util.Arrays.sort(stu, (o1, o2) -&gt; Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore())) ;\n\n\n        for(int i=0;i&lt;stu.length;i++)&#123;    // 循环输出数组中的内容\n            System.out.println(stu[i]) ;\n        &#125;\n    &#125;\n\n    /**\n     * 排序方法三：该方法需新建一个java类使用，\n     * java.util.Arrays.sort(stu, new MyComparator());\n     */\n    class MyComparator implements Comparator&lt;Student&gt;&#123;\n        @Override\n        public int compare(Student o1, Student o2) &#123;\n            return Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore());\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n<h2 id=\"两者比较\"><a href=\"#两者比较\" class=\"headerlink\" title=\"两者比较\"></a>两者比较</h2><table>\n    <tr>\n        <th>属性</th>\n        <th>Comparable</th>\n        <th>Comparator</th>\n    </tr>\n    <tr>\n        <td>适用场景</td>\n        <td>集合内部定义实现</td>\n        <td>集合外部实现排序</td>\n    </tr>\n    <tr>\n        <td>区别</td>\n        <td>1. java.lang 包<br>\n            2. 方法：int compareTo(Object o)\n        </td>\n        <td>1. java.util 包<br>\n            2. 方法：int compare(T o1, To2)\n        </td>\n    </tr>\n    <tr>\n        <td>原理</td>\n        <td colspan=\"2\">基于红黑二叉树原理实现的</td>\n    </tr>\n</table>\n\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-1</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>0</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>1</td>\n<td>小于</td>\n</tr>\n</tbody></table>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>- <a href=\"https://blog.csdn.net/wilson27/article/details/90339765\">java中compareable和comparator的区别，比较器实现的原理！</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Comparable\"><a href=\"#Comparable\" class=\"headerlink\" title=\"Comparable\"></a>Comparable</h2><p>[TOC]</p>\n<pre><code>import java.util.Objects;\n\n/**\n * 实现Comparator接口的类可以方便的排序， 覆写compareTo接口\n * @author zxl\n * @date 2020/10/27 18:00\n */\npublic class Student implements Comparable&lt;Student&gt;&#123;\n\n    /*** 名字 */\n    private String name;\n\n    /*** 年龄 */\n    private int age;\n\n    /*** 分数 */\n    private float score;\n\n    /**\n     * 排序规则：以分数降序排序，若分数一致，则根据年龄升序排序\n     * @param o 比较参数\n     * @return 比较结果 -1大于   0等于   1小于\n     */\n    @Override\n    public int compareTo(Student o) &#123;\n        /*\n         * this.age - o.age 升序\n         * o.score - this.score 降序\n         */\n        return Objects.equals(o.score,this.score) ? this.age - o.age : (int) (o.score - this.score);\n    &#125;\n\n    public Student(String name, int age, float score) &#123;\n        this.name = name;\n        this.age = age;\n        this.score = score;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &quot;, score=&quot; + score +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\n\npublic class Comparable01 &#123;\n\n    public static void main(String args[])&#123;\n        Student stu[] = &#123;\n                new Student(&quot;张三&quot;,20,90.0f),\n                new Student(&quot;李四&quot;,22,90.0f),\n                new Student(&quot;王五&quot;,20,99.0f),\n                new Student(&quot;赵六&quot;,20,70.0f),\n                new Student(&quot;孙七&quot;,22,100.0f)&#125; ;\n        java.util.Arrays.sort(stu) ;    // 进行排序操作\n        for(int i=0;i&lt;stu.length;i++)&#123;    // 循环输出数组中的内容\n            System.out.println(stu[i]) ;\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<h2 id=\"Comparator\"><a href=\"#Comparator\" class=\"headerlink\" title=\"Comparator\"></a>Comparator</h2><pre><code>public class Student &#123;\n    /*** 名字 */\n    private String name;\n\n    /*** 年龄 */\n    private int age;\n\n    /*** 分数 */\n    private float score;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public float getScore() &#123;\n        return score;\n    &#125;\n\n    public void setScore(float score) &#123;\n        this.score = score;\n    &#125;\n\n    public Student(String name, int age, float score) &#123;\n        this.name = name;\n        this.age = age;\n        this.score = score;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &quot;, score=&quot; + score +\n                &#39;&#125;&#39;;\n    &#125;\n\n&#125;\n\npublic class ComparatorTest &#123;\n\n    public static void main(String[] args) &#123;\n        Student stu[] = &#123;\n                new Student(&quot;张三&quot;,20,90.0f),\n                new Student(&quot;李四&quot;,22,90.0f),\n                new Student(&quot;王五&quot;,20,99.0f),\n                new Student(&quot;赵六&quot;,20,70.0f),\n                new Student(&quot;孙七&quot;,22,100.0f)&#125; ;\n\n        // 排序方法一\n        java.util.Arrays.sort(stu, new Comparator&lt;Student&gt;() &#123;\n            @Override\n            public int compare(Student o1, Student o2) &#123;\n                /*\n                 * o1.param - o2.param 升序\n                 * o2.param - o1.param 降序\n                 */\n                return Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore());\n            &#125;\n        &#125;) ;\n\n        // 排序方法二 lambda方法\n        java.util.Arrays.sort(stu, (o1, o2) -&gt; Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore())) ;\n\n\n        for(int i=0;i&lt;stu.length;i++)&#123;    // 循环输出数组中的内容\n            System.out.println(stu[i]) ;\n        &#125;\n    &#125;\n\n    /**\n     * 排序方法三：该方法需新建一个java类使用，\n     * java.util.Arrays.sort(stu, new MyComparator());\n     */\n    class MyComparator implements Comparator&lt;Student&gt;&#123;\n        @Override\n        public int compare(Student o1, Student o2) &#123;\n            return Objects.equals(o1.getScore(),o2.getScore()) ? o1.getAge() - o2.getAge() : (int) (o2.getScore() - o1.getScore());\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n<h2 id=\"两者比较\"><a href=\"#两者比较\" class=\"headerlink\" title=\"两者比较\"></a>两者比较</h2><table>\n    <tr>\n        <th>属性</th>\n        <th>Comparable</th>\n        <th>Comparator</th>\n    </tr>\n    <tr>\n        <td>适用场景</td>\n        <td>集合内部定义实现</td>\n        <td>集合外部实现排序</td>\n    </tr>\n    <tr>\n        <td>区别</td>\n        <td>1. java.lang 包<br>\n            2. 方法：int compareTo(Object o)\n        </td>\n        <td>1. java.util 包<br>\n            2. 方法：int compare(T o1, To2)\n        </td>\n    </tr>\n    <tr>\n        <td>原理</td>\n        <td colspan=\"2\">基于红黑二叉树原理实现的</td>\n    </tr>\n</table>\n\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-1</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>0</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>1</td>\n<td>小于</td>\n</tr>\n</tbody></table>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>- <a href=\"https://blog.csdn.net/wilson27/article/details/90339765\">java中compareable和comparator的区别，比较器实现的原理！</a></p>\n"},{"title":"并发编程实战","date":"2021-04-18T16:00:00.000Z","description":"关于java的并发编程实战书本笔记。","_content":"\n[TOC]\n\n# JAVA并发编程实战\n\n## 第1章 简介\n\n### 1.1 并发简史\n\n#### 1.1.1 操作系统实现多程序同时执行原因\n\n1. **资源利用率**：在某些情况下，程序必须等某个外部操作完成后才能执行，而等待过程中无法执行其他工作。因此，等待过程中，可以执行其他程序，会提高资源利用率。\n2. **公平性**：不同用户和程序对计算机资源有同等的使用权。一种高效的运行方式是通过粗粒度的时机分片（Time Slicing）是用户和程序共享计算机资源。\n3. **便利性**：计算多个任务时，编写多个程序，每个程序执行一个任务，并在必要时相互通信。这比只一个程序计算所有任务更容易实现。\n\n#### 1.1.2 线程\n\n​\t**线程**被称为轻量级进程，线程是操作系统基本的调度单位。如果没有明确的同步机制，线程是彼此独立执行的。同一个进程中的所有线程都共享进程的内存地址，因此线程都能访问到相同变量并在同一个堆上分配对象，                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n\n​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \n\n\n\n\n\n## 参考\n\n\\- [java中compareable和comparator的区别，比较器实现的原理！](https://blog.csdn.net/wilson27/article/details/90339765)","source":"_posts/java学习/并发编程实战/并发编程实战.md","raw":"---\ntitle: 并发编程实战 #文章页面上的显示名称，一般是中文\ndate: 2021-04-19 #文章生成时间，一般不改，当然也可以任意修改\ncategories: JAVA #分类\ntags: [并发,java] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: 关于java的并发编程实战书本笔记。\n---\n\n[TOC]\n\n# JAVA并发编程实战\n\n## 第1章 简介\n\n### 1.1 并发简史\n\n#### 1.1.1 操作系统实现多程序同时执行原因\n\n1. **资源利用率**：在某些情况下，程序必须等某个外部操作完成后才能执行，而等待过程中无法执行其他工作。因此，等待过程中，可以执行其他程序，会提高资源利用率。\n2. **公平性**：不同用户和程序对计算机资源有同等的使用权。一种高效的运行方式是通过粗粒度的时机分片（Time Slicing）是用户和程序共享计算机资源。\n3. **便利性**：计算多个任务时，编写多个程序，每个程序执行一个任务，并在必要时相互通信。这比只一个程序计算所有任务更容易实现。\n\n#### 1.1.2 线程\n\n​\t**线程**被称为轻量级进程，线程是操作系统基本的调度单位。如果没有明确的同步机制，线程是彼此独立执行的。同一个进程中的所有线程都共享进程的内存地址，因此线程都能访问到相同变量并在同一个堆上分配对象，                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n\n​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \n\n\n\n\n\n## 参考\n\n\\- [java中compareable和comparator的区别，比较器实现的原理！](https://blog.csdn.net/wilson27/article/details/90339765)","slug":"java学习/并发编程实战/并发编程实战","published":1,"updated":"2021-04-21T03:31:29.599Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknqx8kf70012botkgzfw9t22","content":"<p>[TOC]</p>\n<h1 id=\"JAVA并发编程实战\"><a href=\"#JAVA并发编程实战\" class=\"headerlink\" title=\"JAVA并发编程实战\"></a>JAVA并发编程实战</h1><h2 id=\"第1章-简介\"><a href=\"#第1章-简介\" class=\"headerlink\" title=\"第1章 简介\"></a>第1章 简介</h2><h3 id=\"1-1-并发简史\"><a href=\"#1-1-并发简史\" class=\"headerlink\" title=\"1.1 并发简史\"></a>1.1 并发简史</h3><h4 id=\"1-1-1-操作系统实现多程序同时执行原因\"><a href=\"#1-1-1-操作系统实现多程序同时执行原因\" class=\"headerlink\" title=\"1.1.1 操作系统实现多程序同时执行原因\"></a>1.1.1 操作系统实现多程序同时执行原因</h4><ol>\n<li><strong>资源利用率</strong>：在某些情况下，程序必须等某个外部操作完成后才能执行，而等待过程中无法执行其他工作。因此，等待过程中，可以执行其他程序，会提高资源利用率。</li>\n<li><strong>公平性</strong>：不同用户和程序对计算机资源有同等的使用权。一种高效的运行方式是通过粗粒度的时机分片（Time Slicing）是用户和程序共享计算机资源。</li>\n<li><strong>便利性</strong>：计算多个任务时，编写多个程序，每个程序执行一个任务，并在必要时相互通信。这比只一个程序计算所有任务更容易实现。</li>\n</ol>\n<h4 id=\"1-1-2-线程\"><a href=\"#1-1-2-线程\" class=\"headerlink\" title=\"1.1.2 线程\"></a>1.1.2 线程</h4><p>​    <strong>线程</strong>被称为轻量级进程，线程是操作系统基本的调度单位。如果没有明确的同步机制，线程是彼此独立执行的。同一个进程中的所有线程都共享进程的内存地址，因此线程都能访问到相同变量并在同一个堆上分配对象，                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p>\n<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>- <a href=\"https://blog.csdn.net/wilson27/article/details/90339765\">java中compareable和comparator的区别，比较器实现的原理！</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"JAVA并发编程实战\"><a href=\"#JAVA并发编程实战\" class=\"headerlink\" title=\"JAVA并发编程实战\"></a>JAVA并发编程实战</h1><h2 id=\"第1章-简介\"><a href=\"#第1章-简介\" class=\"headerlink\" title=\"第1章 简介\"></a>第1章 简介</h2><h3 id=\"1-1-并发简史\"><a href=\"#1-1-并发简史\" class=\"headerlink\" title=\"1.1 并发简史\"></a>1.1 并发简史</h3><h4 id=\"1-1-1-操作系统实现多程序同时执行原因\"><a href=\"#1-1-1-操作系统实现多程序同时执行原因\" class=\"headerlink\" title=\"1.1.1 操作系统实现多程序同时执行原因\"></a>1.1.1 操作系统实现多程序同时执行原因</h4><ol>\n<li><strong>资源利用率</strong>：在某些情况下，程序必须等某个外部操作完成后才能执行，而等待过程中无法执行其他工作。因此，等待过程中，可以执行其他程序，会提高资源利用率。</li>\n<li><strong>公平性</strong>：不同用户和程序对计算机资源有同等的使用权。一种高效的运行方式是通过粗粒度的时机分片（Time Slicing）是用户和程序共享计算机资源。</li>\n<li><strong>便利性</strong>：计算多个任务时，编写多个程序，每个程序执行一个任务，并在必要时相互通信。这比只一个程序计算所有任务更容易实现。</li>\n</ol>\n<h4 id=\"1-1-2-线程\"><a href=\"#1-1-2-线程\" class=\"headerlink\" title=\"1.1.2 线程\"></a>1.1.2 线程</h4><p>​    <strong>线程</strong>被称为轻量级进程，线程是操作系统基本的调度单位。如果没有明确的同步机制，线程是彼此独立执行的。同一个进程中的所有线程都共享进程的内存地址，因此线程都能访问到相同变量并在同一个堆上分配对象，                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p>\n<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>- <a href=\"https://blog.csdn.net/wilson27/article/details/90339765\">java中compareable和comparator的区别，比较器实现的原理！</a></p>\n"},{"title":"证书转换","date":"2020-10-28T06:16:33.000Z","description":"详细讲解pfx、cer证书关系间相互转换。","_content":"\n安装好OpenSSL，然后到bin目录下，执行以下命令即可完成转换：\n\nopenssl pkcs12 -nodes -nokeys -in 1.pfx -passin pass:证书密码 -out 1.cer\n\n如无需加密pem中私钥，可以添加选项-nodes；\n\n\\1. 点击1.cer，安装cer证书\n\n2.从pfx提取密钥信息，并转换为key格式（pfx使用pkcs12模式补足）\n\n  （1）提取密钥对\n\n​    openssl pkcs12 -in 1.pfx -nocerts -nodes -out 1.key\n\n​    //如果pfx证书已加密，会提示输入密码。如果cer证书没有安装，则密码没法验证\n\n  （2）从密钥对提取私钥\n\n​    openssl rsa -in  1.key -out 1_pri.key\n\n  （3）从密钥对提取公钥\n\n​    openssl rsa -in 1.key -pubout -out 1_pub.key\n\n  （4）因为RSA算法使用的是pkcs8模式补足，需要对提取的私钥进一步处理\n\n​    openssl pkcs8 -topk8 -inform PEM -in 1_pri.key -outform PEM -nocrypt\n\n​     复制窗口中生成的密钥，保存为1_pri_pkcs8.key\n\n  （5）得到密钥对1_pri_pkcs8.key和1_pub.key\n\n\n\n\n\n\n\n\\- [openssl 安装参考链接](https://blog.csdn.net/qq_39081974/article/details/81059022)\n\n\n\n\n\n","source":"_posts/工具安装使用/证书/证书转换.md","raw":"---\ntitle: 证书转换 \ndate: 2020-10-28 14:16:33 \ncategories: 工具 \ntags: [pfx,cer] \ndescription: 详细讲解pfx、cer证书关系间相互转换。\n---\n\n安装好OpenSSL，然后到bin目录下，执行以下命令即可完成转换：\n\nopenssl pkcs12 -nodes -nokeys -in 1.pfx -passin pass:证书密码 -out 1.cer\n\n如无需加密pem中私钥，可以添加选项-nodes；\n\n\\1. 点击1.cer，安装cer证书\n\n2.从pfx提取密钥信息，并转换为key格式（pfx使用pkcs12模式补足）\n\n  （1）提取密钥对\n\n​    openssl pkcs12 -in 1.pfx -nocerts -nodes -out 1.key\n\n​    //如果pfx证书已加密，会提示输入密码。如果cer证书没有安装，则密码没法验证\n\n  （2）从密钥对提取私钥\n\n​    openssl rsa -in  1.key -out 1_pri.key\n\n  （3）从密钥对提取公钥\n\n​    openssl rsa -in 1.key -pubout -out 1_pub.key\n\n  （4）因为RSA算法使用的是pkcs8模式补足，需要对提取的私钥进一步处理\n\n​    openssl pkcs8 -topk8 -inform PEM -in 1_pri.key -outform PEM -nocrypt\n\n​     复制窗口中生成的密钥，保存为1_pri_pkcs8.key\n\n  （5）得到密钥对1_pri_pkcs8.key和1_pub.key\n\n\n\n\n\n\n\n\\- [openssl 安装参考链接](https://blog.csdn.net/qq_39081974/article/details/81059022)\n\n\n\n\n\n","slug":"工具安装使用/证书/证书转换","published":1,"updated":"2021-03-04T08:06:57.269Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknqx8kf70013botkhhp38s99","content":"<p>安装好OpenSSL，然后到bin目录下，执行以下命令即可完成转换：</p>\n<p>openssl pkcs12 -nodes -nokeys -in 1.pfx -passin pass:证书密码 -out 1.cer</p>\n<p>如无需加密pem中私钥，可以添加选项-nodes；</p>\n<p>\\1. 点击1.cer，安装cer证书</p>\n<p>2.从pfx提取密钥信息，并转换为key格式（pfx使用pkcs12模式补足）</p>\n<p>  （1）提取密钥对</p>\n<p>​    openssl pkcs12 -in 1.pfx -nocerts -nodes -out 1.key</p>\n<p>​    //如果pfx证书已加密，会提示输入密码。如果cer证书没有安装，则密码没法验证</p>\n<p>  （2）从密钥对提取私钥</p>\n<p>​    openssl rsa -in  1.key -out 1_pri.key</p>\n<p>  （3）从密钥对提取公钥</p>\n<p>​    openssl rsa -in 1.key -pubout -out 1_pub.key</p>\n<p>  （4）因为RSA算法使用的是pkcs8模式补足，需要对提取的私钥进一步处理</p>\n<p>​    openssl pkcs8 -topk8 -inform PEM -in 1_pri.key -outform PEM -nocrypt</p>\n<p>​     复制窗口中生成的密钥，保存为1_pri_pkcs8.key</p>\n<p>  （5）得到密钥对1_pri_pkcs8.key和1_pub.key</p>\n<p>- <a href=\"https://blog.csdn.net/qq_39081974/article/details/81059022\">openssl 安装参考链接</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>安装好OpenSSL，然后到bin目录下，执行以下命令即可完成转换：</p>\n<p>openssl pkcs12 -nodes -nokeys -in 1.pfx -passin pass:证书密码 -out 1.cer</p>\n<p>如无需加密pem中私钥，可以添加选项-nodes；</p>\n<p>\\1. 点击1.cer，安装cer证书</p>\n<p>2.从pfx提取密钥信息，并转换为key格式（pfx使用pkcs12模式补足）</p>\n<p>  （1）提取密钥对</p>\n<p>​    openssl pkcs12 -in 1.pfx -nocerts -nodes -out 1.key</p>\n<p>​    //如果pfx证书已加密，会提示输入密码。如果cer证书没有安装，则密码没法验证</p>\n<p>  （2）从密钥对提取私钥</p>\n<p>​    openssl rsa -in  1.key -out 1_pri.key</p>\n<p>  （3）从密钥对提取公钥</p>\n<p>​    openssl rsa -in 1.key -pubout -out 1_pub.key</p>\n<p>  （4）因为RSA算法使用的是pkcs8模式补足，需要对提取的私钥进一步处理</p>\n<p>​    openssl pkcs8 -topk8 -inform PEM -in 1_pri.key -outform PEM -nocrypt</p>\n<p>​     复制窗口中生成的密钥，保存为1_pri_pkcs8.key</p>\n<p>  （5）得到密钥对1_pri_pkcs8.key和1_pub.key</p>\n<p>- <a href=\"https://blog.csdn.net/qq_39081974/article/details/81059022\">openssl 安装参考链接</a></p>\n"},{"title":"hexo搭建静态博客","date":"2020-10-28T06:16:33.000Z","description":"详细讲解hexo的搭建过程及基础用法。","_content":"\n# hexo\n\n\n\n## hexo 安装步骤\n\n## 常用指令\n\n>1. hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹\n>2. hexo server (hexo s) 启动本地web服务，用于博客的预览\n>3. hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）\n>4. hexo new “postName” 新建文章\n>5. hexo new page “pageName” 新建页面\n>\n>6. **hexo clean** 清除缓存文件\n\n","source":"_posts/工具安装使用/hexo/hexo搭建静态博客.md","raw":"---\ntitle: hexo搭建静态博客 \ndate: 2020-10-28 14:16:33 \ncategories: 工具 \ntags: [hexo,博客] \ndescription: 详细讲解hexo的搭建过程及基础用法。\n---\n\n# hexo\n\n\n\n## hexo 安装步骤\n\n## 常用指令\n\n>1. hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹\n>2. hexo server (hexo s) 启动本地web服务，用于博客的预览\n>3. hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）\n>4. hexo new “postName” 新建文章\n>5. hexo new page “pageName” 新建页面\n>\n>6. **hexo clean** 清除缓存文件\n\n","slug":"工具安装使用/hexo/hexo搭建静态博客","published":1,"updated":"2021-04-21T02:53:02.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknqx8kf90016botk9vqa549l","content":"<h1 id=\"hexo\"><a href=\"#hexo\" class=\"headerlink\" title=\"hexo\"></a>hexo</h1><h2 id=\"hexo-安装步骤\"><a href=\"#hexo-安装步骤\" class=\"headerlink\" title=\"hexo 安装步骤\"></a>hexo 安装步骤</h2><h2 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h2><blockquote>\n<ol>\n<li><p>hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹</p>\n</li>\n<li><p>hexo server (hexo s) 启动本地web服务，用于博客的预览</p>\n</li>\n<li><p>hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）</p>\n</li>\n<li><p>hexo new “postName” 新建文章</p>\n</li>\n<li><p>hexo new page “pageName” 新建页面</p>\n</li>\n<li><p><strong>hexo clean</strong> 清除缓存文件</p>\n</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"hexo\"><a href=\"#hexo\" class=\"headerlink\" title=\"hexo\"></a>hexo</h1><h2 id=\"hexo-安装步骤\"><a href=\"#hexo-安装步骤\" class=\"headerlink\" title=\"hexo 安装步骤\"></a>hexo 安装步骤</h2><h2 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h2><blockquote>\n<ol>\n<li><p>hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹</p>\n</li>\n<li><p>hexo server (hexo s) 启动本地web服务，用于博客的预览</p>\n</li>\n<li><p>hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）</p>\n</li>\n<li><p>hexo new “postName” 新建文章</p>\n</li>\n<li><p>hexo new page “pageName” 新建页面</p>\n</li>\n<li><p><strong>hexo clean</strong> 清除缓存文件</p>\n</li>\n</ol>\n</blockquote>\n"},{"title":"聚合支付","date":"2020-03-25T06:16:33.000Z","description":"使用微信、支付宝做聚合支付产品。","_content":"\n## 微信jsapi支付\n\n### 1. 微信获取openid所需配置信息\n\n1. 进入地址：[微信公众号平台](https://mp.weixin.qq.com/cgi-bin/home?t=home/index&token=1709035801&lang=zh_CN)\n\n2. 进入**【开发】**—**【基本设置】**，配置 **开发者密码**、**服务器地址**、**令牌**、**消费加解密秘钥** 相关信息，开发者密码需要自己保存。\n\n   ![image-20210203152515345](聚合支付流程/image-20210203152515345.png)![image-20210203152440553](聚合支付流程/image-20210203152440553.png)\n\n4. 进入 **【设置】**—**【公众号设置】**，点击**【功能设置】**，配置**网页授权域名**，用于获取**code**和**openid**选项\n\n    ![image-20210203153111406](聚合支付流程/image-20210203153111406.png)![image-20210203153129592](聚合支付流程/image-20210203153129592.png)\n\n5. 参考代码如下\n\n    ```java\n    public static void main(String[] args) {\n            \n            //获取微信code\n            String REDIRECT_URI=\"http://yangsongxiao.cn/Web/Web\";\n            String APPID=\"wxafb534aced348cf5\";\n            String SECRET=\"1c9d8089a89893fa077a597ef5d35055\";\n            String ACCESS_TOKEN_URL = \"https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=snsapi_base&state=STATE#wechat_redirect\";\n            String url = ACCESS_TOKEN_URL.replace(\"APPID\", APPID).replace(\"STATE\",\"1\").replace(\"REDIRECT_URI\", REDIRECT_URI );\n            //微信访问这个页面  服务器可以获取到code \n            System.out.println(url);\n            \n            //获取openid\n            String CODE=\"051pqs100IRy8L10XF300vWp1u1pqs1m\";\n            String url2 = \"https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&secret=SECRET&code=CODE&grant_type=authorization_code\";\n            String Get_Openid = url2.replace(\"APPID\", APPID).replace(\"SECRET\", SECRET).replace(\"CODE\", CODE);\n            System.out.println(Get_Openid);\n            String resp = HttpUtil.doGetStr(Get_Openid);\n            JSONObject re = JSONObject.parseObject(resp);\n            String result = re.containsKey(InitConfig.OPEN_ID) ? re.getString(InitConfig.OPEN_ID) : InitConfig.ERR_START + re.getString(InitConfig.ERR_MSG);\n            System.out.println(result);\n    \n        }\n    ```\n\n6. [微信获取openid方式参考链接](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html)\n\n7. [微信商户平台地址](https://pay.weixin.qq.com/index.php)\n\n\n\n### 2. 前后端拉起\n\n1. [JSAPI 调起支付参考链接](https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_4.shtml)\n2. [微信JSAPI开发指引](https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_3.shtml)\n\n### 3. 注意\n\n​\t**需要配置支付授权目录!!!  由于目前使用钱宝appid下单，所用授权目录地址为钱宝配置。**\n\n## 微信小程序支付相关\n\n> 目前仅知，需要钱宝下单的appid登录小程序开发工具，或者把我方小程序开发人员，拉入到下单appid的项目组中，借用其资质开发一个小程序可用。\n\n### APP跳转小程序流程\n\n1. 登录[微信开放平台](https://open.weixin.qq.com/)，并创建相关应用申请相关权限\n\n   ![image-20210421105700214](聚合支付流程/image-20210421105700214.png)\n\n   ![image-20210421112632294](聚合支付流程/image-20210421112632294.png)\n\n2. 获取相关开发信息，APP包名及签名对应上\n\n   ![image-20210421112937615](聚合支付流程/image-20210421112937615.png)\n\n3. 根据微信官方开发文档，进行开发测试[APP 跳转小程序支付参考链接](https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Launching_a_Mini_Program/Android_Development_example.html)\n\n## 支付宝相关\n\n### 1. 支付宝获取userid方法\n\n1. 登录[支付宝开放平台](https://openhome.alipay.com/platform/home.htm)\n\n   ```\n   账号:  yhtdpay@163.com\n   密码:  chen1992*+\n   手机号绑定人：陈华材\n   ```\n\n2. 创建一个**【应用】**，进入**【应用】**![image-20210203162313099](聚合支付流程/image-20210203162313099.png)\n\n3.  点击**【设置】**按钮，配置**【接口加签方式】**（用于获取openid时加签验签操作）、**【授权回调地址】**（用来获取openid信息）\n\n   ![image-20210203162712582](聚合支付流程/image-20210203162712582.png)\n\n   ![image-20210203163036267](聚合支付流程/image-20210203163036267.png)\n\n4. [获取userid参考链接](https://opendocs.alipay.com/isv/10467/xldcyq)\n\n   [支付宝官方公私钥配置参考链接](https://opensupport.alipay.com/support/helpcenter/207/201602471154?ant_source=manual&recommend=ab2418594aa12994227b51f38a16d735)\n\n5. 参考代码\n\n   ```java\n   \t\t//获取zfb appid\n           String appid=\"2021001156603164\";\n           //进行url转码\n           String returnurl=\"http%3a%2f%2fyangsongxiao.cn%2fWeb%2fWeb\";\n           String url=\"https://openauth.alipay.com/oauth2/appToAppAuth.htm?app_id=\"+appid+\"&redirect_uri=\"+returnurl;\n           //支付宝访问这个地址，点击授权  服务器获取 app_id 和 app_auth_code\n           System.out.println(url);\n           String app_id=\"2021001156603164\";\n           String app_auth_code=\"06ff73b078c24a24bc720b038ec77B74\";\n   \n           //支付宝公钥\n           String alipay_public_key=\"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAshrxiMZappfjphxroVLUWNFErcuC22OlsWZdvgVCgDCJuvBO5ZPqZ4pWNeInWBAoCZiqElYPV+2Tt8vHOyeWpQiHTMOUm+FXOHCvRieyYiFtTCkn61E70ZWI6VAxsyYAbiqYJ48/LmooFAD27Qw5YgWDn2Zi5FEKjWpYtfxVz/QfDbpf85HjUdlmZQsU0fppXwCY38nGzzDZ2jG9sURlcwNgV7bxnYUirFNeEVssMqgQGOLMMvvx2Dm6CoZPpQ4/9ripMYGluHxHk0Open0Khg8M4X0VSfYopwJc4P6SQbKj1B0OdGinIPzyHqFoO3g083DjYYKtD5Cj3LmA+n5gPQIDAQAB\";\n   \n           String app_private_key=\"\";\n   \n           //获取AppAuthToken\n           AlipayClient alipayClient= new DefaultAlipayClient( \"https://openapi.alipay.com/gateway.do\" ,  app_id , app_private_key , \"json\" ,  \"GBK\" ,  alipay_public_key , \"RSA2\" );\n           AlipayOpenAuthTokenAppRequest request = new AlipayOpenAuthTokenAppRequest ();\n           request.setBizContent (\n                   \"{\"   + \"\\\"grant_type\\\":\\\"authorization_code\\\",\"   +\n                           \"\\\"code\\\":\\\"\"+app_auth_code+\"\\\"\" +\n                   \"}\"\n           );\n           AlipayOpenAuthTokenAppResponse response = alipayClient.execute ( request );\n           System.out.println(response.getAppAuthToken());\n   ```\n\n### 2. 支付宝拉起支付\n\n1. [支付宝老方式前端拉起支付链接](https://opendocs.alipay.com/open/common/105591)\n\n   ```html\n   <p id=\"result\">result: </p>\n   <script type=\"application/javascript\">\n       // 调试时可以通过在页面定义一个元素，打印信息，使用alert方法不够优雅\n       function log(obj) {\n           $(\"#result\").append(obj).append(\" \").append(\"<br />\");\n       }\n   \n       $(document).ready(function(){\n           // 页面载入完成后即唤起收银台\n           // 此处${tradeNO}为模板语言语法，实际调用样例类似为tradePpay(\"2016072621001004200000000752\")\n            tradePay(\"${tradeNO}\"); \n   \n            // 点击payButton按钮后唤起收银台\n            $(\"#payButton\").click(function() {\n               tradePay(\"${tradeNO}\");\n            });\n   \n            // 通过jsapi关闭当前窗口，仅供参考，更多jsapi请访问\n            // /aod/54/104510\n            $(\"#closeButton\").click(function() {\n               AlipayJSBridge.call('closeWebview');\n            });\n        });\n   \n       // 由于js的载入是异步的，所以可以通过该方法，当AlipayJSBridgeReady事件发生后，再执行callback方法\n        function ready(callback) {\n            if (window.AlipayJSBridge) {\n                callback && callback();\n            } else {\n                document.addEventListener('AlipayJSBridgeReady', callback, false);\n            }\n        }\n   \n        function tradePay(tradeNO) {\n           ready(function(){\n                // 通过传入交易号唤起快捷调用方式(注意tradeNO大小写严格)\n                AlipayJSBridge.call(\"tradePay\", {\n   tradeNO: tradeNO\n                }, function (data) {\n                    log(JSON.stringify(data));\n                    if (\"9000\" == data.resultCode) {\n                        log(\"支付成功\");\n                    }\n                });\n           });\n       }\n   </script>\n   ```\n\n2. [支付宝新版拉起支付参考链接](https://myjsapi.alipay.com/alipayjsapi/util/pay/tradePay.html)\n\n   ```js\n   <script src=\"https://gw.alipayobjects.com/as/g/h5-lib/alipayjsapi/3.1.1/alipayjsapi.inc.min.js\"></script>\n   <script type=\"text/javascript\">\n       window.onload = function () {\n       /* 支付宝 */\n       var btn = document.querySelector('#J_btn');\n       btn.addEventListener('click', function(){\n           alert(\"支付\")\n           ap.tradePay({\n               tradeNO: '2021020322001430791435578886',\n           }, function(res){\n               ap.alert(res.resultCode);\n           });\n       });\n   </script>\n   ```\n\n### 3. 支付宝秘钥相关\n\n1. 支付宝平台公钥\n\n```java\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAshrxiMZappfjphxroVLUWNFErcuC22OlsWZdvgVCgDCJuvBO5ZPqZ4pWNeInWBAoCZiqElYPV+2Tt8vHOyeWpQiHTMOUm+FXOHCvRieyYiFtTCkn61E70ZWI6VAxsyYAbiqYJ48/LmooFAD27Qw5YgWDn2Zi5FEKjWpYtfxVz/QfDbpf85HjUdlmZQsU0fppXwCY38nGzzDZ2jG9sURlcwNgV7bxnYUirFNeEVssMqgQGOLMMvvx2Dm6CoZPpQ4/9ripMYGluHxHk0Open0Khg8M4X0VSfYopwJc4P6SQbKj1B0OdGinIPzyHqFoO3g083DjYYKtD5Cj3LmA+n5gPQIDAQAB\n```\n\n2. 商户自己公私钥\n\n   2.1 公钥\n\n   ```java\n   MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAstPGBWAJfHmu3WXWnX2TRM8doL1oDmgmIc0mVLvJyjI937KpCXpE8STz5dWgIGnzuuvhx7iWWbRA33ItzwQD61aatGjWlUA9afyU6mqkWk8X2HogbfnLTo+X7DKVLk+v7fLXxc7PKP3albF9rNs3qdNbwe+6WoOLv6JXgBXgWxGeGNNWIMyI34+f1bnPhw5dhFKkVMBsVTmbI8CFlhUaBy1oW+lF2bviDPn4OPfuhizPg2DKaRKPv8ucnBWrYnSN2jQZWoK72lf8qxl8Musi4sOMzhXWN0mVA0DAr4v9MQccbsmjjm6agyHeYmC+dmP7C9dwjxwvQKfhSNNdAnWpTQIDAQAB\n   ```\n\n   2.2 私钥\n\n   ```java\n   MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCy08YFYAl8ea7dZdadfZNEzx2gvWgOaCYhzSZUu8nKMj3fsqkJekTxJPPl1aAgafO66+HHuJZZtEDfci3PBAPrVpq0aNaVQD1p/JTqaqRaTxfYeiBt+ctOj5fsMpUuT6/t8tfFzs8o/dqVsX2s2zep01vB77pag4u/oleAFeBbEZ4Y01YgzIjfj5/Vuc+HDl2EUqRUwGxVOZsjwIWWFRoHLWhb6UXZu+IM+fg49+6GLM+DYMppEo+/y5ycFatidI3aNBlagrvaV/yrGXwy6yLiw4zOFdY3SZUDQMCvi/0xBxxuyaOObpqDId5iYL52Y/sL13CPHC9Ap+FI010CdalNAgMBAAECggEAP+emEC2ttinV75CBDW7evew17kdBdESLu/CQDh+9kOA7dEFoXtau5G4MKsoYmvzB+L5qxPCV6iCcPj2TWTNaIzOjvWzpohR+3e1BWjQZ35v8LYQXKrXljYGLDQFWhmI7wJDTwwCQz1lIT85J1wfP8IRzee6tbcMsoaLmGgO3VVNwp9kkbwODG/d48P33joQ8MT0JUjZUDGQGaRhVLh1GOfJny9rT2CmNIrzNriovwb4Gz4+UFLGNhbPOHZPBS62mnEzm/0Yjhj4V9y9qxt6IygwAs08rjRRY1bwQf1WoHp3bT2k5ueB2QF9b2MXljzC3yloufGkzD/vASp+T6xK4AQKBgQDtZxxLZPzS5YDN18CX1efqkMZGS+ov4y+aXM6W34eRIYeN5PUIkCoRER+G6B47y0b498JYMqgSkDEzy+PfYTIE0evMSnbYpU62chqRQ0k5dOWTScJyuEDdPyQpRv4ECSEyVuV48i1AWTH8AH+PLFj5A55j05rsGNk+OR9PXCt9zQKBgQDA1fxXHdbyGh9hqWyvUE4p9gbwhA2Qq6pkrDM68JcxokNpw9WuGsU4hHeqx4+FvVOqPH9RrfAKHUTB6ADWz47Z5i7+LxPbue///TX81m76V/8soxCMVME1lDmOO6vBOxIvYYP2dVFPT7JGmECbcuY/bghrlWzknN4RewB0MgtZgQKBgFh6SlBLFfLfuA5/b3bnMOT6CftfBavNRwuHtTMDofnT/jpC75O+bv8nW5Gi5smwLAZUCGloj71DYiMExSuWhNbJCdF8myiJC3nxsrca1aqFR56KKd8pjnsmsip0G+2THX0uZ52Y3IaT944M/X11sL81uw1HawC9DhIjpeik2EytAoGAJ/Ir+7/qruxKY+i84vQ3vOmCNoCkbrug6Injcuoz58w9OsOemBpjkHmgcHg2evXlRvaRSVJGz1GQ1LpCsjz80pakVXNbIcE6vkSt0lp5UtK3wX9mBivoejjiU1x5D+Y0tiv1MjDLTyqrO4R+nbUHjUw14lNp41G7jtN0HJ3hTAECgYEAkgtwQMEydeqaJ5VV74B3xeQwa5jLUuoosbRg8qSD8UGHl1+i7k2ttumtv0t4NpMpVjmO/n9WOld3BAvrN3IuO1FVmc9JuNBP9s+vQxeD9wvx0XcB4RKlY7mNAi/J3WQkBJfj1q0hTGtB9ZxWLfqLIv9yDxYPkWoPyJwWxA0ohBA=\n   ```\n\n## QQ \n\n### 1. 获取sid流程\n\n### 2. 前端代码\n\n```js\n<script type=\"application/javascript\" src=\"https://open.mobile.qq.com/sdk/qqapi.js?_bid=152\"></script>\n<script type=\"text/javascript\">\n\tfunction pay(){\n            //验证是否是QQ\n            mqq.device.isMobileQQ(function(result){\n                if(result) {\n                    var isIos = mqq.iOS;\n                    //alert(\"是否是IOS:\" + isIos);\n                    var isAndroid = mqq.android;\n                    //alert(\"是否是Android:\" + isAndroid);\n                    var qqVersion = mqq.QQVersion;\n                    //alert(\"QQVersion:\" + qqVersion);\n                    //唤起QQ钱包\n                    this.callPay()\n                } else {\n                    alert(\"请在手机QQ中打开此页面\");\n                    return false;\n                }\n            });\n        }\n\n        function callPay(){\n            mqq.tenpay.pay({\n                tokenId: \"5Mfd2ffe642c61f498b8c03a4638a04e\",\n            }, function(result, resultCode){\n                if(result == \"Permission denied\") {\n                    alert(\"无权限 \");\n                } else {\n                    alert(result.resultCode);\n                    document.location.href = \"${redirectUrl}\";\n                }\n            });\n        }\n</script>\n```\n\n## 具体实现相关\n\n### 第一种方法（动态码）：\n\n>微信、支付宝 外包聚合支付页面，本质均使用 动态码下单 在浏览器中打开操作\n\n### 第二种方法（jsapi）：\n\n>微信支付宝使用先授权，外包聚合支付页面，再通过jsapi支付接口下单拉起支付。\n\n注：云闪付相关实现方式存疑。\n\n## 钱宝相关\n\n```\n测试商户号：848290972306000  \n测试终端号：29002210\n目前配置支付授权目录：http://yangsongxiao.cn/ysf/\n```\n\n![image-20210203155002102](聚合支付流程/image-20210203155002102.png)\n\n## 参考链接\n\n[jsapi 的微信githup](https://github.com/monk6658/unionpay-solidcode)","source":"_posts/工具安装使用/聚合支付拉起流程/聚合支付流程.md","raw":"---\ntitle: 聚合支付 \ndate: 2020-03-25 14:16:33 #文章生成时间，一般不改，当然也可以任意修改\ncategories: 工具 #分类\ntags: [微信支付,支付宝] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: 使用微信、支付宝做聚合支付产品。\n---\n\n## 微信jsapi支付\n\n### 1. 微信获取openid所需配置信息\n\n1. 进入地址：[微信公众号平台](https://mp.weixin.qq.com/cgi-bin/home?t=home/index&token=1709035801&lang=zh_CN)\n\n2. 进入**【开发】**—**【基本设置】**，配置 **开发者密码**、**服务器地址**、**令牌**、**消费加解密秘钥** 相关信息，开发者密码需要自己保存。\n\n   ![image-20210203152515345](聚合支付流程/image-20210203152515345.png)![image-20210203152440553](聚合支付流程/image-20210203152440553.png)\n\n4. 进入 **【设置】**—**【公众号设置】**，点击**【功能设置】**，配置**网页授权域名**，用于获取**code**和**openid**选项\n\n    ![image-20210203153111406](聚合支付流程/image-20210203153111406.png)![image-20210203153129592](聚合支付流程/image-20210203153129592.png)\n\n5. 参考代码如下\n\n    ```java\n    public static void main(String[] args) {\n            \n            //获取微信code\n            String REDIRECT_URI=\"http://yangsongxiao.cn/Web/Web\";\n            String APPID=\"wxafb534aced348cf5\";\n            String SECRET=\"1c9d8089a89893fa077a597ef5d35055\";\n            String ACCESS_TOKEN_URL = \"https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=snsapi_base&state=STATE#wechat_redirect\";\n            String url = ACCESS_TOKEN_URL.replace(\"APPID\", APPID).replace(\"STATE\",\"1\").replace(\"REDIRECT_URI\", REDIRECT_URI );\n            //微信访问这个页面  服务器可以获取到code \n            System.out.println(url);\n            \n            //获取openid\n            String CODE=\"051pqs100IRy8L10XF300vWp1u1pqs1m\";\n            String url2 = \"https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&secret=SECRET&code=CODE&grant_type=authorization_code\";\n            String Get_Openid = url2.replace(\"APPID\", APPID).replace(\"SECRET\", SECRET).replace(\"CODE\", CODE);\n            System.out.println(Get_Openid);\n            String resp = HttpUtil.doGetStr(Get_Openid);\n            JSONObject re = JSONObject.parseObject(resp);\n            String result = re.containsKey(InitConfig.OPEN_ID) ? re.getString(InitConfig.OPEN_ID) : InitConfig.ERR_START + re.getString(InitConfig.ERR_MSG);\n            System.out.println(result);\n    \n        }\n    ```\n\n6. [微信获取openid方式参考链接](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html)\n\n7. [微信商户平台地址](https://pay.weixin.qq.com/index.php)\n\n\n\n### 2. 前后端拉起\n\n1. [JSAPI 调起支付参考链接](https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_4.shtml)\n2. [微信JSAPI开发指引](https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_3.shtml)\n\n### 3. 注意\n\n​\t**需要配置支付授权目录!!!  由于目前使用钱宝appid下单，所用授权目录地址为钱宝配置。**\n\n## 微信小程序支付相关\n\n> 目前仅知，需要钱宝下单的appid登录小程序开发工具，或者把我方小程序开发人员，拉入到下单appid的项目组中，借用其资质开发一个小程序可用。\n\n### APP跳转小程序流程\n\n1. 登录[微信开放平台](https://open.weixin.qq.com/)，并创建相关应用申请相关权限\n\n   ![image-20210421105700214](聚合支付流程/image-20210421105700214.png)\n\n   ![image-20210421112632294](聚合支付流程/image-20210421112632294.png)\n\n2. 获取相关开发信息，APP包名及签名对应上\n\n   ![image-20210421112937615](聚合支付流程/image-20210421112937615.png)\n\n3. 根据微信官方开发文档，进行开发测试[APP 跳转小程序支付参考链接](https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Launching_a_Mini_Program/Android_Development_example.html)\n\n## 支付宝相关\n\n### 1. 支付宝获取userid方法\n\n1. 登录[支付宝开放平台](https://openhome.alipay.com/platform/home.htm)\n\n   ```\n   账号:  yhtdpay@163.com\n   密码:  chen1992*+\n   手机号绑定人：陈华材\n   ```\n\n2. 创建一个**【应用】**，进入**【应用】**![image-20210203162313099](聚合支付流程/image-20210203162313099.png)\n\n3.  点击**【设置】**按钮，配置**【接口加签方式】**（用于获取openid时加签验签操作）、**【授权回调地址】**（用来获取openid信息）\n\n   ![image-20210203162712582](聚合支付流程/image-20210203162712582.png)\n\n   ![image-20210203163036267](聚合支付流程/image-20210203163036267.png)\n\n4. [获取userid参考链接](https://opendocs.alipay.com/isv/10467/xldcyq)\n\n   [支付宝官方公私钥配置参考链接](https://opensupport.alipay.com/support/helpcenter/207/201602471154?ant_source=manual&recommend=ab2418594aa12994227b51f38a16d735)\n\n5. 参考代码\n\n   ```java\n   \t\t//获取zfb appid\n           String appid=\"2021001156603164\";\n           //进行url转码\n           String returnurl=\"http%3a%2f%2fyangsongxiao.cn%2fWeb%2fWeb\";\n           String url=\"https://openauth.alipay.com/oauth2/appToAppAuth.htm?app_id=\"+appid+\"&redirect_uri=\"+returnurl;\n           //支付宝访问这个地址，点击授权  服务器获取 app_id 和 app_auth_code\n           System.out.println(url);\n           String app_id=\"2021001156603164\";\n           String app_auth_code=\"06ff73b078c24a24bc720b038ec77B74\";\n   \n           //支付宝公钥\n           String alipay_public_key=\"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAshrxiMZappfjphxroVLUWNFErcuC22OlsWZdvgVCgDCJuvBO5ZPqZ4pWNeInWBAoCZiqElYPV+2Tt8vHOyeWpQiHTMOUm+FXOHCvRieyYiFtTCkn61E70ZWI6VAxsyYAbiqYJ48/LmooFAD27Qw5YgWDn2Zi5FEKjWpYtfxVz/QfDbpf85HjUdlmZQsU0fppXwCY38nGzzDZ2jG9sURlcwNgV7bxnYUirFNeEVssMqgQGOLMMvvx2Dm6CoZPpQ4/9ripMYGluHxHk0Open0Khg8M4X0VSfYopwJc4P6SQbKj1B0OdGinIPzyHqFoO3g083DjYYKtD5Cj3LmA+n5gPQIDAQAB\";\n   \n           String app_private_key=\"\";\n   \n           //获取AppAuthToken\n           AlipayClient alipayClient= new DefaultAlipayClient( \"https://openapi.alipay.com/gateway.do\" ,  app_id , app_private_key , \"json\" ,  \"GBK\" ,  alipay_public_key , \"RSA2\" );\n           AlipayOpenAuthTokenAppRequest request = new AlipayOpenAuthTokenAppRequest ();\n           request.setBizContent (\n                   \"{\"   + \"\\\"grant_type\\\":\\\"authorization_code\\\",\"   +\n                           \"\\\"code\\\":\\\"\"+app_auth_code+\"\\\"\" +\n                   \"}\"\n           );\n           AlipayOpenAuthTokenAppResponse response = alipayClient.execute ( request );\n           System.out.println(response.getAppAuthToken());\n   ```\n\n### 2. 支付宝拉起支付\n\n1. [支付宝老方式前端拉起支付链接](https://opendocs.alipay.com/open/common/105591)\n\n   ```html\n   <p id=\"result\">result: </p>\n   <script type=\"application/javascript\">\n       // 调试时可以通过在页面定义一个元素，打印信息，使用alert方法不够优雅\n       function log(obj) {\n           $(\"#result\").append(obj).append(\" \").append(\"<br />\");\n       }\n   \n       $(document).ready(function(){\n           // 页面载入完成后即唤起收银台\n           // 此处${tradeNO}为模板语言语法，实际调用样例类似为tradePpay(\"2016072621001004200000000752\")\n            tradePay(\"${tradeNO}\"); \n   \n            // 点击payButton按钮后唤起收银台\n            $(\"#payButton\").click(function() {\n               tradePay(\"${tradeNO}\");\n            });\n   \n            // 通过jsapi关闭当前窗口，仅供参考，更多jsapi请访问\n            // /aod/54/104510\n            $(\"#closeButton\").click(function() {\n               AlipayJSBridge.call('closeWebview');\n            });\n        });\n   \n       // 由于js的载入是异步的，所以可以通过该方法，当AlipayJSBridgeReady事件发生后，再执行callback方法\n        function ready(callback) {\n            if (window.AlipayJSBridge) {\n                callback && callback();\n            } else {\n                document.addEventListener('AlipayJSBridgeReady', callback, false);\n            }\n        }\n   \n        function tradePay(tradeNO) {\n           ready(function(){\n                // 通过传入交易号唤起快捷调用方式(注意tradeNO大小写严格)\n                AlipayJSBridge.call(\"tradePay\", {\n   tradeNO: tradeNO\n                }, function (data) {\n                    log(JSON.stringify(data));\n                    if (\"9000\" == data.resultCode) {\n                        log(\"支付成功\");\n                    }\n                });\n           });\n       }\n   </script>\n   ```\n\n2. [支付宝新版拉起支付参考链接](https://myjsapi.alipay.com/alipayjsapi/util/pay/tradePay.html)\n\n   ```js\n   <script src=\"https://gw.alipayobjects.com/as/g/h5-lib/alipayjsapi/3.1.1/alipayjsapi.inc.min.js\"></script>\n   <script type=\"text/javascript\">\n       window.onload = function () {\n       /* 支付宝 */\n       var btn = document.querySelector('#J_btn');\n       btn.addEventListener('click', function(){\n           alert(\"支付\")\n           ap.tradePay({\n               tradeNO: '2021020322001430791435578886',\n           }, function(res){\n               ap.alert(res.resultCode);\n           });\n       });\n   </script>\n   ```\n\n### 3. 支付宝秘钥相关\n\n1. 支付宝平台公钥\n\n```java\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAshrxiMZappfjphxroVLUWNFErcuC22OlsWZdvgVCgDCJuvBO5ZPqZ4pWNeInWBAoCZiqElYPV+2Tt8vHOyeWpQiHTMOUm+FXOHCvRieyYiFtTCkn61E70ZWI6VAxsyYAbiqYJ48/LmooFAD27Qw5YgWDn2Zi5FEKjWpYtfxVz/QfDbpf85HjUdlmZQsU0fppXwCY38nGzzDZ2jG9sURlcwNgV7bxnYUirFNeEVssMqgQGOLMMvvx2Dm6CoZPpQ4/9ripMYGluHxHk0Open0Khg8M4X0VSfYopwJc4P6SQbKj1B0OdGinIPzyHqFoO3g083DjYYKtD5Cj3LmA+n5gPQIDAQAB\n```\n\n2. 商户自己公私钥\n\n   2.1 公钥\n\n   ```java\n   MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAstPGBWAJfHmu3WXWnX2TRM8doL1oDmgmIc0mVLvJyjI937KpCXpE8STz5dWgIGnzuuvhx7iWWbRA33ItzwQD61aatGjWlUA9afyU6mqkWk8X2HogbfnLTo+X7DKVLk+v7fLXxc7PKP3albF9rNs3qdNbwe+6WoOLv6JXgBXgWxGeGNNWIMyI34+f1bnPhw5dhFKkVMBsVTmbI8CFlhUaBy1oW+lF2bviDPn4OPfuhizPg2DKaRKPv8ucnBWrYnSN2jQZWoK72lf8qxl8Musi4sOMzhXWN0mVA0DAr4v9MQccbsmjjm6agyHeYmC+dmP7C9dwjxwvQKfhSNNdAnWpTQIDAQAB\n   ```\n\n   2.2 私钥\n\n   ```java\n   MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCy08YFYAl8ea7dZdadfZNEzx2gvWgOaCYhzSZUu8nKMj3fsqkJekTxJPPl1aAgafO66+HHuJZZtEDfci3PBAPrVpq0aNaVQD1p/JTqaqRaTxfYeiBt+ctOj5fsMpUuT6/t8tfFzs8o/dqVsX2s2zep01vB77pag4u/oleAFeBbEZ4Y01YgzIjfj5/Vuc+HDl2EUqRUwGxVOZsjwIWWFRoHLWhb6UXZu+IM+fg49+6GLM+DYMppEo+/y5ycFatidI3aNBlagrvaV/yrGXwy6yLiw4zOFdY3SZUDQMCvi/0xBxxuyaOObpqDId5iYL52Y/sL13CPHC9Ap+FI010CdalNAgMBAAECggEAP+emEC2ttinV75CBDW7evew17kdBdESLu/CQDh+9kOA7dEFoXtau5G4MKsoYmvzB+L5qxPCV6iCcPj2TWTNaIzOjvWzpohR+3e1BWjQZ35v8LYQXKrXljYGLDQFWhmI7wJDTwwCQz1lIT85J1wfP8IRzee6tbcMsoaLmGgO3VVNwp9kkbwODG/d48P33joQ8MT0JUjZUDGQGaRhVLh1GOfJny9rT2CmNIrzNriovwb4Gz4+UFLGNhbPOHZPBS62mnEzm/0Yjhj4V9y9qxt6IygwAs08rjRRY1bwQf1WoHp3bT2k5ueB2QF9b2MXljzC3yloufGkzD/vASp+T6xK4AQKBgQDtZxxLZPzS5YDN18CX1efqkMZGS+ov4y+aXM6W34eRIYeN5PUIkCoRER+G6B47y0b498JYMqgSkDEzy+PfYTIE0evMSnbYpU62chqRQ0k5dOWTScJyuEDdPyQpRv4ECSEyVuV48i1AWTH8AH+PLFj5A55j05rsGNk+OR9PXCt9zQKBgQDA1fxXHdbyGh9hqWyvUE4p9gbwhA2Qq6pkrDM68JcxokNpw9WuGsU4hHeqx4+FvVOqPH9RrfAKHUTB6ADWz47Z5i7+LxPbue///TX81m76V/8soxCMVME1lDmOO6vBOxIvYYP2dVFPT7JGmECbcuY/bghrlWzknN4RewB0MgtZgQKBgFh6SlBLFfLfuA5/b3bnMOT6CftfBavNRwuHtTMDofnT/jpC75O+bv8nW5Gi5smwLAZUCGloj71DYiMExSuWhNbJCdF8myiJC3nxsrca1aqFR56KKd8pjnsmsip0G+2THX0uZ52Y3IaT944M/X11sL81uw1HawC9DhIjpeik2EytAoGAJ/Ir+7/qruxKY+i84vQ3vOmCNoCkbrug6Injcuoz58w9OsOemBpjkHmgcHg2evXlRvaRSVJGz1GQ1LpCsjz80pakVXNbIcE6vkSt0lp5UtK3wX9mBivoejjiU1x5D+Y0tiv1MjDLTyqrO4R+nbUHjUw14lNp41G7jtN0HJ3hTAECgYEAkgtwQMEydeqaJ5VV74B3xeQwa5jLUuoosbRg8qSD8UGHl1+i7k2ttumtv0t4NpMpVjmO/n9WOld3BAvrN3IuO1FVmc9JuNBP9s+vQxeD9wvx0XcB4RKlY7mNAi/J3WQkBJfj1q0hTGtB9ZxWLfqLIv9yDxYPkWoPyJwWxA0ohBA=\n   ```\n\n## QQ \n\n### 1. 获取sid流程\n\n### 2. 前端代码\n\n```js\n<script type=\"application/javascript\" src=\"https://open.mobile.qq.com/sdk/qqapi.js?_bid=152\"></script>\n<script type=\"text/javascript\">\n\tfunction pay(){\n            //验证是否是QQ\n            mqq.device.isMobileQQ(function(result){\n                if(result) {\n                    var isIos = mqq.iOS;\n                    //alert(\"是否是IOS:\" + isIos);\n                    var isAndroid = mqq.android;\n                    //alert(\"是否是Android:\" + isAndroid);\n                    var qqVersion = mqq.QQVersion;\n                    //alert(\"QQVersion:\" + qqVersion);\n                    //唤起QQ钱包\n                    this.callPay()\n                } else {\n                    alert(\"请在手机QQ中打开此页面\");\n                    return false;\n                }\n            });\n        }\n\n        function callPay(){\n            mqq.tenpay.pay({\n                tokenId: \"5Mfd2ffe642c61f498b8c03a4638a04e\",\n            }, function(result, resultCode){\n                if(result == \"Permission denied\") {\n                    alert(\"无权限 \");\n                } else {\n                    alert(result.resultCode);\n                    document.location.href = \"${redirectUrl}\";\n                }\n            });\n        }\n</script>\n```\n\n## 具体实现相关\n\n### 第一种方法（动态码）：\n\n>微信、支付宝 外包聚合支付页面，本质均使用 动态码下单 在浏览器中打开操作\n\n### 第二种方法（jsapi）：\n\n>微信支付宝使用先授权，外包聚合支付页面，再通过jsapi支付接口下单拉起支付。\n\n注：云闪付相关实现方式存疑。\n\n## 钱宝相关\n\n```\n测试商户号：848290972306000  \n测试终端号：29002210\n目前配置支付授权目录：http://yangsongxiao.cn/ysf/\n```\n\n![image-20210203155002102](聚合支付流程/image-20210203155002102.png)\n\n## 参考链接\n\n[jsapi 的微信githup](https://github.com/monk6658/unionpay-solidcode)","slug":"工具安装使用/聚合支付拉起流程/聚合支付流程","published":1,"updated":"2021-04-21T03:31:09.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknqx8kfa001bbotk1rlq6dev","content":"<h2 id=\"微信jsapi支付\"><a href=\"#微信jsapi支付\" class=\"headerlink\" title=\"微信jsapi支付\"></a>微信jsapi支付</h2><h3 id=\"1-微信获取openid所需配置信息\"><a href=\"#1-微信获取openid所需配置信息\" class=\"headerlink\" title=\"1. 微信获取openid所需配置信息\"></a>1. 微信获取openid所需配置信息</h3><ol>\n<li><p>进入地址：<a href=\"https://mp.weixin.qq.com/cgi-bin/home?t=home/index&token=1709035801&lang=zh_CN\">微信公众号平台</a></p>\n</li>\n<li><p>进入<strong>【开发】</strong>—<strong>【基本设置】</strong>，配置 <strong>开发者密码</strong>、<strong>服务器地址</strong>、<strong>令牌</strong>、<strong>消费加解密秘钥</strong> 相关信息，开发者密码需要自己保存。</p>\n<p><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210203152515345.png\" alt=\"image-20210203152515345\"><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210203152440553.png\" alt=\"image-20210203152440553\"></p>\n</li>\n<li><p>进入 <strong>【设置】</strong>—<strong>【公众号设置】</strong>，点击<strong>【功能设置】</strong>，配置<strong>网页授权域名</strong>，用于获取<strong>code</strong>和<strong>openid</strong>选项</p>\n<p> <img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210203153111406.png\" alt=\"image-20210203153111406\"><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210203153129592.png\" alt=\"image-20210203153129592\"></p>\n</li>\n<li><p>参考代码如下</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n\n        //获取微信code\n        String REDIRECT_URI=&quot;http://yangsongxiao.cn/Web/Web&quot;;\n        String APPID=&quot;wxafb534aced348cf5&quot;;\n        String SECRET=&quot;1c9d8089a89893fa077a597ef5d35055&quot;;\n        String ACCESS_TOKEN_URL = &quot;https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE#wechat_redirect&quot;;\n        String url = ACCESS_TOKEN_URL.replace(&quot;APPID&quot;, APPID).replace(&quot;STATE&quot;,&quot;1&quot;).replace(&quot;REDIRECT_URI&quot;, REDIRECT_URI );\n        //微信访问这个页面  服务器可以获取到code \n        System.out.println(url);\n\n        //获取openid\n        String CODE=&quot;051pqs100IRy8L10XF300vWp1u1pqs1m&quot;;\n        String url2 = &quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code&quot;;\n        String Get_Openid = url2.replace(&quot;APPID&quot;, APPID).replace(&quot;SECRET&quot;, SECRET).replace(&quot;CODE&quot;, CODE);\n        System.out.println(Get_Openid);\n        String resp = HttpUtil.doGetStr(Get_Openid);\n        JSONObject re = JSONObject.parseObject(resp);\n        String result = re.containsKey(InitConfig.OPEN_ID) ? re.getString(InitConfig.OPEN_ID) : InitConfig.ERR_START + re.getString(InitConfig.ERR_MSG);\n        System.out.println(result);\n\n    &#125;</code></pre>\n</li>\n<li><p><a href=\"https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html\">微信获取openid方式参考链接</a></p>\n</li>\n<li><p><a href=\"https://pay.weixin.qq.com/index.php\">微信商户平台地址</a></p>\n</li>\n</ol>\n<h3 id=\"2-前后端拉起\"><a href=\"#2-前后端拉起\" class=\"headerlink\" title=\"2. 前后端拉起\"></a>2. 前后端拉起</h3><ol>\n<li><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_4.shtml\">JSAPI 调起支付参考链接</a></li>\n<li><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_3.shtml\">微信JSAPI开发指引</a></li>\n</ol>\n<h3 id=\"3-注意\"><a href=\"#3-注意\" class=\"headerlink\" title=\"3. 注意\"></a>3. 注意</h3><p>​    <strong>需要配置支付授权目录!!!  由于目前使用钱宝appid下单，所用授权目录地址为钱宝配置。</strong></p>\n<h2 id=\"微信小程序支付相关\"><a href=\"#微信小程序支付相关\" class=\"headerlink\" title=\"微信小程序支付相关\"></a>微信小程序支付相关</h2><blockquote>\n<p>目前仅知，需要钱宝下单的appid登录小程序开发工具，或者把我方小程序开发人员，拉入到下单appid的项目组中，借用其资质开发一个小程序可用。</p>\n</blockquote>\n<h3 id=\"APP跳转小程序流程\"><a href=\"#APP跳转小程序流程\" class=\"headerlink\" title=\"APP跳转小程序流程\"></a>APP跳转小程序流程</h3><ol>\n<li><p>登录<a href=\"https://open.weixin.qq.com/\">微信开放平台</a>，并创建相关应用申请相关权限</p>\n<p><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210421105700214.png\" alt=\"image-20210421105700214\"></p>\n<p><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210421112632294.png\" alt=\"image-20210421112632294\"></p>\n</li>\n<li><p>获取相关开发信息，APP包名及签名对应上</p>\n<p><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210421112937615.png\" alt=\"image-20210421112937615\"></p>\n</li>\n<li><p>根据微信官方开发文档，进行开发测试<a href=\"https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Launching_a_Mini_Program/Android_Development_example.html\">APP 跳转小程序支付参考链接</a></p>\n</li>\n</ol>\n<h2 id=\"支付宝相关\"><a href=\"#支付宝相关\" class=\"headerlink\" title=\"支付宝相关\"></a>支付宝相关</h2><h3 id=\"1-支付宝获取userid方法\"><a href=\"#1-支付宝获取userid方法\" class=\"headerlink\" title=\"1. 支付宝获取userid方法\"></a>1. 支付宝获取userid方法</h3><ol>\n<li><p>登录<a href=\"https://openhome.alipay.com/platform/home.htm\">支付宝开放平台</a></p>\n<pre><code>账号:  yhtdpay@163.com\n密码:  chen1992*+\n手机号绑定人：陈华材</code></pre>\n</li>\n<li><p>创建一个<strong>【应用】</strong>，进入<strong>【应用】</strong><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210203162313099.png\" alt=\"image-20210203162313099\"></p>\n</li>\n<li><p>点击<strong>【设置】</strong>按钮，配置<strong>【接口加签方式】</strong>（用于获取openid时加签验签操作）、<strong>【授权回调地址】</strong>（用来获取openid信息）</p>\n<p><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210203162712582.png\" alt=\"image-20210203162712582\"></p>\n<p><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210203163036267.png\" alt=\"image-20210203163036267\"></p>\n</li>\n<li><p><a href=\"https://opendocs.alipay.com/isv/10467/xldcyq\">获取userid参考链接</a></p>\n<p><a href=\"https://opensupport.alipay.com/support/helpcenter/207/201602471154?ant_source=manual&recommend=ab2418594aa12994227b51f38a16d735\">支付宝官方公私钥配置参考链接</a></p>\n</li>\n<li><p>参考代码</p>\n<pre><code class=\"java\">        //获取zfb appid\n        String appid=&quot;2021001156603164&quot;;\n        //进行url转码\n        String returnurl=&quot;http%3a%2f%2fyangsongxiao.cn%2fWeb%2fWeb&quot;;\n        String url=&quot;https://openauth.alipay.com/oauth2/appToAppAuth.htm?app_id=&quot;+appid+&quot;&amp;redirect_uri=&quot;+returnurl;\n        //支付宝访问这个地址，点击授权  服务器获取 app_id 和 app_auth_code\n        System.out.println(url);\n        String app_id=&quot;2021001156603164&quot;;\n        String app_auth_code=&quot;06ff73b078c24a24bc720b038ec77B74&quot;;\n\n        //支付宝公钥\n        String alipay_public_key=&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAshrxiMZappfjphxroVLUWNFErcuC22OlsWZdvgVCgDCJuvBO5ZPqZ4pWNeInWBAoCZiqElYPV+2Tt8vHOyeWpQiHTMOUm+FXOHCvRieyYiFtTCkn61E70ZWI6VAxsyYAbiqYJ48/LmooFAD27Qw5YgWDn2Zi5FEKjWpYtfxVz/QfDbpf85HjUdlmZQsU0fppXwCY38nGzzDZ2jG9sURlcwNgV7bxnYUirFNeEVssMqgQGOLMMvvx2Dm6CoZPpQ4/9ripMYGluHxHk0Open0Khg8M4X0VSfYopwJc4P6SQbKj1B0OdGinIPzyHqFoO3g083DjYYKtD5Cj3LmA+n5gPQIDAQAB&quot;;\n\n        String app_private_key=&quot;&quot;;\n\n        //获取AppAuthToken\n        AlipayClient alipayClient= new DefaultAlipayClient( &quot;https://openapi.alipay.com/gateway.do&quot; ,  app_id , app_private_key , &quot;json&quot; ,  &quot;GBK&quot; ,  alipay_public_key , &quot;RSA2&quot; );\n        AlipayOpenAuthTokenAppRequest request = new AlipayOpenAuthTokenAppRequest ();\n        request.setBizContent (\n                &quot;&#123;&quot;   + &quot;\\&quot;grant_type\\&quot;:\\&quot;authorization_code\\&quot;,&quot;   +\n                        &quot;\\&quot;code\\&quot;:\\&quot;&quot;+app_auth_code+&quot;\\&quot;&quot; +\n                &quot;&#125;&quot;\n        );\n        AlipayOpenAuthTokenAppResponse response = alipayClient.execute ( request );\n        System.out.println(response.getAppAuthToken());</code></pre>\n</li>\n</ol>\n<h3 id=\"2-支付宝拉起支付\"><a href=\"#2-支付宝拉起支付\" class=\"headerlink\" title=\"2. 支付宝拉起支付\"></a>2. 支付宝拉起支付</h3><ol>\n<li><p><a href=\"https://opendocs.alipay.com/open/common/105591\">支付宝老方式前端拉起支付链接</a></p>\n<pre><code class=\"html\">&lt;p id=&quot;result&quot;&gt;result: &lt;/p&gt;\n&lt;script type=&quot;application/javascript&quot;&gt;\n    // 调试时可以通过在页面定义一个元素，打印信息，使用alert方法不够优雅\n    function log(obj) &#123;\n        $(&quot;#result&quot;).append(obj).append(&quot; &quot;).append(&quot;&lt;br /&gt;&quot;);\n    &#125;\n\n    $(document).ready(function()&#123;\n        // 页面载入完成后即唤起收银台\n        // 此处$&#123;tradeNO&#125;为模板语言语法，实际调用样例类似为tradePpay(&quot;2016072621001004200000000752&quot;)\n         tradePay(&quot;$&#123;tradeNO&#125;&quot;); \n\n         // 点击payButton按钮后唤起收银台\n         $(&quot;#payButton&quot;).click(function() &#123;\n            tradePay(&quot;$&#123;tradeNO&#125;&quot;);\n         &#125;);\n\n         // 通过jsapi关闭当前窗口，仅供参考，更多jsapi请访问\n         // /aod/54/104510\n         $(&quot;#closeButton&quot;).click(function() &#123;\n            AlipayJSBridge.call(&#39;closeWebview&#39;);\n         &#125;);\n     &#125;);\n\n    // 由于js的载入是异步的，所以可以通过该方法，当AlipayJSBridgeReady事件发生后，再执行callback方法\n     function ready(callback) &#123;\n         if (window.AlipayJSBridge) &#123;\n             callback &amp;&amp; callback();\n         &#125; else &#123;\n             document.addEventListener(&#39;AlipayJSBridgeReady&#39;, callback, false);\n         &#125;\n     &#125;\n\n     function tradePay(tradeNO) &#123;\n        ready(function()&#123;\n             // 通过传入交易号唤起快捷调用方式(注意tradeNO大小写严格)\n             AlipayJSBridge.call(&quot;tradePay&quot;, &#123;\ntradeNO: tradeNO\n             &#125;, function (data) &#123;\n                 log(JSON.stringify(data));\n                 if (&quot;9000&quot; == data.resultCode) &#123;\n                     log(&quot;支付成功&quot;);\n                 &#125;\n             &#125;);\n        &#125;);\n    &#125;\n&lt;/script&gt;</code></pre>\n</li>\n<li><p><a href=\"https://myjsapi.alipay.com/alipayjsapi/util/pay/tradePay.html\">支付宝新版拉起支付参考链接</a></p>\n<pre><code class=\"js\">&lt;script src=&quot;https://gw.alipayobjects.com/as/g/h5-lib/alipayjsapi/3.1.1/alipayjsapi.inc.min.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    window.onload = function () &#123;\n    /* 支付宝 */\n    var btn = document.querySelector(&#39;#J_btn&#39;);\n    btn.addEventListener(&#39;click&#39;, function()&#123;\n        alert(&quot;支付&quot;)\n        ap.tradePay(&#123;\n            tradeNO: &#39;2021020322001430791435578886&#39;,\n        &#125;, function(res)&#123;\n            ap.alert(res.resultCode);\n        &#125;);\n    &#125;);\n&lt;/script&gt;</code></pre>\n</li>\n</ol>\n<h3 id=\"3-支付宝秘钥相关\"><a href=\"#3-支付宝秘钥相关\" class=\"headerlink\" title=\"3. 支付宝秘钥相关\"></a>3. 支付宝秘钥相关</h3><ol>\n<li>支付宝平台公钥</li>\n</ol>\n<pre><code class=\"java\">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAshrxiMZappfjphxroVLUWNFErcuC22OlsWZdvgVCgDCJuvBO5ZPqZ4pWNeInWBAoCZiqElYPV+2Tt8vHOyeWpQiHTMOUm+FXOHCvRieyYiFtTCkn61E70ZWI6VAxsyYAbiqYJ48/LmooFAD27Qw5YgWDn2Zi5FEKjWpYtfxVz/QfDbpf85HjUdlmZQsU0fppXwCY38nGzzDZ2jG9sURlcwNgV7bxnYUirFNeEVssMqgQGOLMMvvx2Dm6CoZPpQ4/9ripMYGluHxHk0Open0Khg8M4X0VSfYopwJc4P6SQbKj1B0OdGinIPzyHqFoO3g083DjYYKtD5Cj3LmA+n5gPQIDAQAB</code></pre>\n<ol start=\"2\">\n<li><p>商户自己公私钥</p>\n<p>2.1 公钥</p>\n<pre><code class=\"java\">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAstPGBWAJfHmu3WXWnX2TRM8doL1oDmgmIc0mVLvJyjI937KpCXpE8STz5dWgIGnzuuvhx7iWWbRA33ItzwQD61aatGjWlUA9afyU6mqkWk8X2HogbfnLTo+X7DKVLk+v7fLXxc7PKP3albF9rNs3qdNbwe+6WoOLv6JXgBXgWxGeGNNWIMyI34+f1bnPhw5dhFKkVMBsVTmbI8CFlhUaBy1oW+lF2bviDPn4OPfuhizPg2DKaRKPv8ucnBWrYnSN2jQZWoK72lf8qxl8Musi4sOMzhXWN0mVA0DAr4v9MQccbsmjjm6agyHeYmC+dmP7C9dwjxwvQKfhSNNdAnWpTQIDAQAB</code></pre>\n<p>2.2 私钥</p>\n<pre><code class=\"java\">MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCy08YFYAl8ea7dZdadfZNEzx2gvWgOaCYhzSZUu8nKMj3fsqkJekTxJPPl1aAgafO66+HHuJZZtEDfci3PBAPrVpq0aNaVQD1p/JTqaqRaTxfYeiBt+ctOj5fsMpUuT6/t8tfFzs8o/dqVsX2s2zep01vB77pag4u/oleAFeBbEZ4Y01YgzIjfj5/Vuc+HDl2EUqRUwGxVOZsjwIWWFRoHLWhb6UXZu+IM+fg49+6GLM+DYMppEo+/y5ycFatidI3aNBlagrvaV/yrGXwy6yLiw4zOFdY3SZUDQMCvi/0xBxxuyaOObpqDId5iYL52Y/sL13CPHC9Ap+FI010CdalNAgMBAAECggEAP+emEC2ttinV75CBDW7evew17kdBdESLu/CQDh+9kOA7dEFoXtau5G4MKsoYmvzB+L5qxPCV6iCcPj2TWTNaIzOjvWzpohR+3e1BWjQZ35v8LYQXKrXljYGLDQFWhmI7wJDTwwCQz1lIT85J1wfP8IRzee6tbcMsoaLmGgO3VVNwp9kkbwODG/d48P33joQ8MT0JUjZUDGQGaRhVLh1GOfJny9rT2CmNIrzNriovwb4Gz4+UFLGNhbPOHZPBS62mnEzm/0Yjhj4V9y9qxt6IygwAs08rjRRY1bwQf1WoHp3bT2k5ueB2QF9b2MXljzC3yloufGkzD/vASp+T6xK4AQKBgQDtZxxLZPzS5YDN18CX1efqkMZGS+ov4y+aXM6W34eRIYeN5PUIkCoRER+G6B47y0b498JYMqgSkDEzy+PfYTIE0evMSnbYpU62chqRQ0k5dOWTScJyuEDdPyQpRv4ECSEyVuV48i1AWTH8AH+PLFj5A55j05rsGNk+OR9PXCt9zQKBgQDA1fxXHdbyGh9hqWyvUE4p9gbwhA2Qq6pkrDM68JcxokNpw9WuGsU4hHeqx4+FvVOqPH9RrfAKHUTB6ADWz47Z5i7+LxPbue///TX81m76V/8soxCMVME1lDmOO6vBOxIvYYP2dVFPT7JGmECbcuY/bghrlWzknN4RewB0MgtZgQKBgFh6SlBLFfLfuA5/b3bnMOT6CftfBavNRwuHtTMDofnT/jpC75O+bv8nW5Gi5smwLAZUCGloj71DYiMExSuWhNbJCdF8myiJC3nxsrca1aqFR56KKd8pjnsmsip0G+2THX0uZ52Y3IaT944M/X11sL81uw1HawC9DhIjpeik2EytAoGAJ/Ir+7/qruxKY+i84vQ3vOmCNoCkbrug6Injcuoz58w9OsOemBpjkHmgcHg2evXlRvaRSVJGz1GQ1LpCsjz80pakVXNbIcE6vkSt0lp5UtK3wX9mBivoejjiU1x5D+Y0tiv1MjDLTyqrO4R+nbUHjUw14lNp41G7jtN0HJ3hTAECgYEAkgtwQMEydeqaJ5VV74B3xeQwa5jLUuoosbRg8qSD8UGHl1+i7k2ttumtv0t4NpMpVjmO/n9WOld3BAvrN3IuO1FVmc9JuNBP9s+vQxeD9wvx0XcB4RKlY7mNAi/J3WQkBJfj1q0hTGtB9ZxWLfqLIv9yDxYPkWoPyJwWxA0ohBA=</code></pre>\n</li>\n</ol>\n<h2 id=\"QQ\"><a href=\"#QQ\" class=\"headerlink\" title=\"QQ\"></a>QQ</h2><h3 id=\"1-获取sid流程\"><a href=\"#1-获取sid流程\" class=\"headerlink\" title=\"1. 获取sid流程\"></a>1. 获取sid流程</h3><h3 id=\"2-前端代码\"><a href=\"#2-前端代码\" class=\"headerlink\" title=\"2. 前端代码\"></a>2. 前端代码</h3><pre><code class=\"js\">&lt;script type=&quot;application/javascript&quot; src=&quot;https://open.mobile.qq.com/sdk/qqapi.js?_bid=152&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    function pay()&#123;\n            //验证是否是QQ\n            mqq.device.isMobileQQ(function(result)&#123;\n                if(result) &#123;\n                    var isIos = mqq.iOS;\n                    //alert(&quot;是否是IOS:&quot; + isIos);\n                    var isAndroid = mqq.android;\n                    //alert(&quot;是否是Android:&quot; + isAndroid);\n                    var qqVersion = mqq.QQVersion;\n                    //alert(&quot;QQVersion:&quot; + qqVersion);\n                    //唤起QQ钱包\n                    this.callPay()\n                &#125; else &#123;\n                    alert(&quot;请在手机QQ中打开此页面&quot;);\n                    return false;\n                &#125;\n            &#125;);\n        &#125;\n\n        function callPay()&#123;\n            mqq.tenpay.pay(&#123;\n                tokenId: &quot;5Mfd2ffe642c61f498b8c03a4638a04e&quot;,\n            &#125;, function(result, resultCode)&#123;\n                if(result == &quot;Permission denied&quot;) &#123;\n                    alert(&quot;无权限 &quot;);\n                &#125; else &#123;\n                    alert(result.resultCode);\n                    document.location.href = &quot;$&#123;redirectUrl&#125;&quot;;\n                &#125;\n            &#125;);\n        &#125;\n&lt;/script&gt;</code></pre>\n<h2 id=\"具体实现相关\"><a href=\"#具体实现相关\" class=\"headerlink\" title=\"具体实现相关\"></a>具体实现相关</h2><h3 id=\"第一种方法（动态码）：\"><a href=\"#第一种方法（动态码）：\" class=\"headerlink\" title=\"第一种方法（动态码）：\"></a>第一种方法（动态码）：</h3><blockquote>\n<p>微信、支付宝 外包聚合支付页面，本质均使用 动态码下单 在浏览器中打开操作</p>\n</blockquote>\n<h3 id=\"第二种方法（jsapi）：\"><a href=\"#第二种方法（jsapi）：\" class=\"headerlink\" title=\"第二种方法（jsapi）：\"></a>第二种方法（jsapi）：</h3><blockquote>\n<p>微信支付宝使用先授权，外包聚合支付页面，再通过jsapi支付接口下单拉起支付。</p>\n</blockquote>\n<p>注：云闪付相关实现方式存疑。</p>\n<h2 id=\"钱宝相关\"><a href=\"#钱宝相关\" class=\"headerlink\" title=\"钱宝相关\"></a>钱宝相关</h2><pre><code>测试商户号：848290972306000  \n测试终端号：29002210\n目前配置支付授权目录：http://yangsongxiao.cn/ysf/</code></pre>\n<p><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210203155002102.png\" alt=\"image-20210203155002102\"></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://github.com/monk6658/unionpay-solidcode\">jsapi 的微信githup</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"微信jsapi支付\"><a href=\"#微信jsapi支付\" class=\"headerlink\" title=\"微信jsapi支付\"></a>微信jsapi支付</h2><h3 id=\"1-微信获取openid所需配置信息\"><a href=\"#1-微信获取openid所需配置信息\" class=\"headerlink\" title=\"1. 微信获取openid所需配置信息\"></a>1. 微信获取openid所需配置信息</h3><ol>\n<li><p>进入地址：<a href=\"https://mp.weixin.qq.com/cgi-bin/home?t=home/index&token=1709035801&lang=zh_CN\">微信公众号平台</a></p>\n</li>\n<li><p>进入<strong>【开发】</strong>—<strong>【基本设置】</strong>，配置 <strong>开发者密码</strong>、<strong>服务器地址</strong>、<strong>令牌</strong>、<strong>消费加解密秘钥</strong> 相关信息，开发者密码需要自己保存。</p>\n<p><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210203152515345.png\" alt=\"image-20210203152515345\"><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210203152440553.png\" alt=\"image-20210203152440553\"></p>\n</li>\n<li><p>进入 <strong>【设置】</strong>—<strong>【公众号设置】</strong>，点击<strong>【功能设置】</strong>，配置<strong>网页授权域名</strong>，用于获取<strong>code</strong>和<strong>openid</strong>选项</p>\n<p> <img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210203153111406.png\" alt=\"image-20210203153111406\"><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210203153129592.png\" alt=\"image-20210203153129592\"></p>\n</li>\n<li><p>参考代码如下</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n\n        //获取微信code\n        String REDIRECT_URI=&quot;http://yangsongxiao.cn/Web/Web&quot;;\n        String APPID=&quot;wxafb534aced348cf5&quot;;\n        String SECRET=&quot;1c9d8089a89893fa077a597ef5d35055&quot;;\n        String ACCESS_TOKEN_URL = &quot;https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE#wechat_redirect&quot;;\n        String url = ACCESS_TOKEN_URL.replace(&quot;APPID&quot;, APPID).replace(&quot;STATE&quot;,&quot;1&quot;).replace(&quot;REDIRECT_URI&quot;, REDIRECT_URI );\n        //微信访问这个页面  服务器可以获取到code \n        System.out.println(url);\n\n        //获取openid\n        String CODE=&quot;051pqs100IRy8L10XF300vWp1u1pqs1m&quot;;\n        String url2 = &quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code&quot;;\n        String Get_Openid = url2.replace(&quot;APPID&quot;, APPID).replace(&quot;SECRET&quot;, SECRET).replace(&quot;CODE&quot;, CODE);\n        System.out.println(Get_Openid);\n        String resp = HttpUtil.doGetStr(Get_Openid);\n        JSONObject re = JSONObject.parseObject(resp);\n        String result = re.containsKey(InitConfig.OPEN_ID) ? re.getString(InitConfig.OPEN_ID) : InitConfig.ERR_START + re.getString(InitConfig.ERR_MSG);\n        System.out.println(result);\n\n    &#125;</code></pre>\n</li>\n<li><p><a href=\"https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html\">微信获取openid方式参考链接</a></p>\n</li>\n<li><p><a href=\"https://pay.weixin.qq.com/index.php\">微信商户平台地址</a></p>\n</li>\n</ol>\n<h3 id=\"2-前后端拉起\"><a href=\"#2-前后端拉起\" class=\"headerlink\" title=\"2. 前后端拉起\"></a>2. 前后端拉起</h3><ol>\n<li><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_4.shtml\">JSAPI 调起支付参考链接</a></li>\n<li><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_3.shtml\">微信JSAPI开发指引</a></li>\n</ol>\n<h3 id=\"3-注意\"><a href=\"#3-注意\" class=\"headerlink\" title=\"3. 注意\"></a>3. 注意</h3><p>​    <strong>需要配置支付授权目录!!!  由于目前使用钱宝appid下单，所用授权目录地址为钱宝配置。</strong></p>\n<h2 id=\"微信小程序支付相关\"><a href=\"#微信小程序支付相关\" class=\"headerlink\" title=\"微信小程序支付相关\"></a>微信小程序支付相关</h2><blockquote>\n<p>目前仅知，需要钱宝下单的appid登录小程序开发工具，或者把我方小程序开发人员，拉入到下单appid的项目组中，借用其资质开发一个小程序可用。</p>\n</blockquote>\n<h3 id=\"APP跳转小程序流程\"><a href=\"#APP跳转小程序流程\" class=\"headerlink\" title=\"APP跳转小程序流程\"></a>APP跳转小程序流程</h3><ol>\n<li><p>登录<a href=\"https://open.weixin.qq.com/\">微信开放平台</a>，并创建相关应用申请相关权限</p>\n<p><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210421105700214.png\" alt=\"image-20210421105700214\"></p>\n<p><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210421112632294.png\" alt=\"image-20210421112632294\"></p>\n</li>\n<li><p>获取相关开发信息，APP包名及签名对应上</p>\n<p><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210421112937615.png\" alt=\"image-20210421112937615\"></p>\n</li>\n<li><p>根据微信官方开发文档，进行开发测试<a href=\"https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Launching_a_Mini_Program/Android_Development_example.html\">APP 跳转小程序支付参考链接</a></p>\n</li>\n</ol>\n<h2 id=\"支付宝相关\"><a href=\"#支付宝相关\" class=\"headerlink\" title=\"支付宝相关\"></a>支付宝相关</h2><h3 id=\"1-支付宝获取userid方法\"><a href=\"#1-支付宝获取userid方法\" class=\"headerlink\" title=\"1. 支付宝获取userid方法\"></a>1. 支付宝获取userid方法</h3><ol>\n<li><p>登录<a href=\"https://openhome.alipay.com/platform/home.htm\">支付宝开放平台</a></p>\n<pre><code>账号:  yhtdpay@163.com\n密码:  chen1992*+\n手机号绑定人：陈华材</code></pre>\n</li>\n<li><p>创建一个<strong>【应用】</strong>，进入<strong>【应用】</strong><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210203162313099.png\" alt=\"image-20210203162313099\"></p>\n</li>\n<li><p>点击<strong>【设置】</strong>按钮，配置<strong>【接口加签方式】</strong>（用于获取openid时加签验签操作）、<strong>【授权回调地址】</strong>（用来获取openid信息）</p>\n<p><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210203162712582.png\" alt=\"image-20210203162712582\"></p>\n<p><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210203163036267.png\" alt=\"image-20210203163036267\"></p>\n</li>\n<li><p><a href=\"https://opendocs.alipay.com/isv/10467/xldcyq\">获取userid参考链接</a></p>\n<p><a href=\"https://opensupport.alipay.com/support/helpcenter/207/201602471154?ant_source=manual&recommend=ab2418594aa12994227b51f38a16d735\">支付宝官方公私钥配置参考链接</a></p>\n</li>\n<li><p>参考代码</p>\n<pre><code class=\"java\">        //获取zfb appid\n        String appid=&quot;2021001156603164&quot;;\n        //进行url转码\n        String returnurl=&quot;http%3a%2f%2fyangsongxiao.cn%2fWeb%2fWeb&quot;;\n        String url=&quot;https://openauth.alipay.com/oauth2/appToAppAuth.htm?app_id=&quot;+appid+&quot;&amp;redirect_uri=&quot;+returnurl;\n        //支付宝访问这个地址，点击授权  服务器获取 app_id 和 app_auth_code\n        System.out.println(url);\n        String app_id=&quot;2021001156603164&quot;;\n        String app_auth_code=&quot;06ff73b078c24a24bc720b038ec77B74&quot;;\n\n        //支付宝公钥\n        String alipay_public_key=&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAshrxiMZappfjphxroVLUWNFErcuC22OlsWZdvgVCgDCJuvBO5ZPqZ4pWNeInWBAoCZiqElYPV+2Tt8vHOyeWpQiHTMOUm+FXOHCvRieyYiFtTCkn61E70ZWI6VAxsyYAbiqYJ48/LmooFAD27Qw5YgWDn2Zi5FEKjWpYtfxVz/QfDbpf85HjUdlmZQsU0fppXwCY38nGzzDZ2jG9sURlcwNgV7bxnYUirFNeEVssMqgQGOLMMvvx2Dm6CoZPpQ4/9ripMYGluHxHk0Open0Khg8M4X0VSfYopwJc4P6SQbKj1B0OdGinIPzyHqFoO3g083DjYYKtD5Cj3LmA+n5gPQIDAQAB&quot;;\n\n        String app_private_key=&quot;&quot;;\n\n        //获取AppAuthToken\n        AlipayClient alipayClient= new DefaultAlipayClient( &quot;https://openapi.alipay.com/gateway.do&quot; ,  app_id , app_private_key , &quot;json&quot; ,  &quot;GBK&quot; ,  alipay_public_key , &quot;RSA2&quot; );\n        AlipayOpenAuthTokenAppRequest request = new AlipayOpenAuthTokenAppRequest ();\n        request.setBizContent (\n                &quot;&#123;&quot;   + &quot;\\&quot;grant_type\\&quot;:\\&quot;authorization_code\\&quot;,&quot;   +\n                        &quot;\\&quot;code\\&quot;:\\&quot;&quot;+app_auth_code+&quot;\\&quot;&quot; +\n                &quot;&#125;&quot;\n        );\n        AlipayOpenAuthTokenAppResponse response = alipayClient.execute ( request );\n        System.out.println(response.getAppAuthToken());</code></pre>\n</li>\n</ol>\n<h3 id=\"2-支付宝拉起支付\"><a href=\"#2-支付宝拉起支付\" class=\"headerlink\" title=\"2. 支付宝拉起支付\"></a>2. 支付宝拉起支付</h3><ol>\n<li><p><a href=\"https://opendocs.alipay.com/open/common/105591\">支付宝老方式前端拉起支付链接</a></p>\n<pre><code class=\"html\">&lt;p id=&quot;result&quot;&gt;result: &lt;/p&gt;\n&lt;script type=&quot;application/javascript&quot;&gt;\n    // 调试时可以通过在页面定义一个元素，打印信息，使用alert方法不够优雅\n    function log(obj) &#123;\n        $(&quot;#result&quot;).append(obj).append(&quot; &quot;).append(&quot;&lt;br /&gt;&quot;);\n    &#125;\n\n    $(document).ready(function()&#123;\n        // 页面载入完成后即唤起收银台\n        // 此处$&#123;tradeNO&#125;为模板语言语法，实际调用样例类似为tradePpay(&quot;2016072621001004200000000752&quot;)\n         tradePay(&quot;$&#123;tradeNO&#125;&quot;); \n\n         // 点击payButton按钮后唤起收银台\n         $(&quot;#payButton&quot;).click(function() &#123;\n            tradePay(&quot;$&#123;tradeNO&#125;&quot;);\n         &#125;);\n\n         // 通过jsapi关闭当前窗口，仅供参考，更多jsapi请访问\n         // /aod/54/104510\n         $(&quot;#closeButton&quot;).click(function() &#123;\n            AlipayJSBridge.call(&#39;closeWebview&#39;);\n         &#125;);\n     &#125;);\n\n    // 由于js的载入是异步的，所以可以通过该方法，当AlipayJSBridgeReady事件发生后，再执行callback方法\n     function ready(callback) &#123;\n         if (window.AlipayJSBridge) &#123;\n             callback &amp;&amp; callback();\n         &#125; else &#123;\n             document.addEventListener(&#39;AlipayJSBridgeReady&#39;, callback, false);\n         &#125;\n     &#125;\n\n     function tradePay(tradeNO) &#123;\n        ready(function()&#123;\n             // 通过传入交易号唤起快捷调用方式(注意tradeNO大小写严格)\n             AlipayJSBridge.call(&quot;tradePay&quot;, &#123;\ntradeNO: tradeNO\n             &#125;, function (data) &#123;\n                 log(JSON.stringify(data));\n                 if (&quot;9000&quot; == data.resultCode) &#123;\n                     log(&quot;支付成功&quot;);\n                 &#125;\n             &#125;);\n        &#125;);\n    &#125;\n&lt;/script&gt;</code></pre>\n</li>\n<li><p><a href=\"https://myjsapi.alipay.com/alipayjsapi/util/pay/tradePay.html\">支付宝新版拉起支付参考链接</a></p>\n<pre><code class=\"js\">&lt;script src=&quot;https://gw.alipayobjects.com/as/g/h5-lib/alipayjsapi/3.1.1/alipayjsapi.inc.min.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    window.onload = function () &#123;\n    /* 支付宝 */\n    var btn = document.querySelector(&#39;#J_btn&#39;);\n    btn.addEventListener(&#39;click&#39;, function()&#123;\n        alert(&quot;支付&quot;)\n        ap.tradePay(&#123;\n            tradeNO: &#39;2021020322001430791435578886&#39;,\n        &#125;, function(res)&#123;\n            ap.alert(res.resultCode);\n        &#125;);\n    &#125;);\n&lt;/script&gt;</code></pre>\n</li>\n</ol>\n<h3 id=\"3-支付宝秘钥相关\"><a href=\"#3-支付宝秘钥相关\" class=\"headerlink\" title=\"3. 支付宝秘钥相关\"></a>3. 支付宝秘钥相关</h3><ol>\n<li>支付宝平台公钥</li>\n</ol>\n<pre><code class=\"java\">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAshrxiMZappfjphxroVLUWNFErcuC22OlsWZdvgVCgDCJuvBO5ZPqZ4pWNeInWBAoCZiqElYPV+2Tt8vHOyeWpQiHTMOUm+FXOHCvRieyYiFtTCkn61E70ZWI6VAxsyYAbiqYJ48/LmooFAD27Qw5YgWDn2Zi5FEKjWpYtfxVz/QfDbpf85HjUdlmZQsU0fppXwCY38nGzzDZ2jG9sURlcwNgV7bxnYUirFNeEVssMqgQGOLMMvvx2Dm6CoZPpQ4/9ripMYGluHxHk0Open0Khg8M4X0VSfYopwJc4P6SQbKj1B0OdGinIPzyHqFoO3g083DjYYKtD5Cj3LmA+n5gPQIDAQAB</code></pre>\n<ol start=\"2\">\n<li><p>商户自己公私钥</p>\n<p>2.1 公钥</p>\n<pre><code class=\"java\">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAstPGBWAJfHmu3WXWnX2TRM8doL1oDmgmIc0mVLvJyjI937KpCXpE8STz5dWgIGnzuuvhx7iWWbRA33ItzwQD61aatGjWlUA9afyU6mqkWk8X2HogbfnLTo+X7DKVLk+v7fLXxc7PKP3albF9rNs3qdNbwe+6WoOLv6JXgBXgWxGeGNNWIMyI34+f1bnPhw5dhFKkVMBsVTmbI8CFlhUaBy1oW+lF2bviDPn4OPfuhizPg2DKaRKPv8ucnBWrYnSN2jQZWoK72lf8qxl8Musi4sOMzhXWN0mVA0DAr4v9MQccbsmjjm6agyHeYmC+dmP7C9dwjxwvQKfhSNNdAnWpTQIDAQAB</code></pre>\n<p>2.2 私钥</p>\n<pre><code class=\"java\">MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCy08YFYAl8ea7dZdadfZNEzx2gvWgOaCYhzSZUu8nKMj3fsqkJekTxJPPl1aAgafO66+HHuJZZtEDfci3PBAPrVpq0aNaVQD1p/JTqaqRaTxfYeiBt+ctOj5fsMpUuT6/t8tfFzs8o/dqVsX2s2zep01vB77pag4u/oleAFeBbEZ4Y01YgzIjfj5/Vuc+HDl2EUqRUwGxVOZsjwIWWFRoHLWhb6UXZu+IM+fg49+6GLM+DYMppEo+/y5ycFatidI3aNBlagrvaV/yrGXwy6yLiw4zOFdY3SZUDQMCvi/0xBxxuyaOObpqDId5iYL52Y/sL13CPHC9Ap+FI010CdalNAgMBAAECggEAP+emEC2ttinV75CBDW7evew17kdBdESLu/CQDh+9kOA7dEFoXtau5G4MKsoYmvzB+L5qxPCV6iCcPj2TWTNaIzOjvWzpohR+3e1BWjQZ35v8LYQXKrXljYGLDQFWhmI7wJDTwwCQz1lIT85J1wfP8IRzee6tbcMsoaLmGgO3VVNwp9kkbwODG/d48P33joQ8MT0JUjZUDGQGaRhVLh1GOfJny9rT2CmNIrzNriovwb4Gz4+UFLGNhbPOHZPBS62mnEzm/0Yjhj4V9y9qxt6IygwAs08rjRRY1bwQf1WoHp3bT2k5ueB2QF9b2MXljzC3yloufGkzD/vASp+T6xK4AQKBgQDtZxxLZPzS5YDN18CX1efqkMZGS+ov4y+aXM6W34eRIYeN5PUIkCoRER+G6B47y0b498JYMqgSkDEzy+PfYTIE0evMSnbYpU62chqRQ0k5dOWTScJyuEDdPyQpRv4ECSEyVuV48i1AWTH8AH+PLFj5A55j05rsGNk+OR9PXCt9zQKBgQDA1fxXHdbyGh9hqWyvUE4p9gbwhA2Qq6pkrDM68JcxokNpw9WuGsU4hHeqx4+FvVOqPH9RrfAKHUTB6ADWz47Z5i7+LxPbue///TX81m76V/8soxCMVME1lDmOO6vBOxIvYYP2dVFPT7JGmECbcuY/bghrlWzknN4RewB0MgtZgQKBgFh6SlBLFfLfuA5/b3bnMOT6CftfBavNRwuHtTMDofnT/jpC75O+bv8nW5Gi5smwLAZUCGloj71DYiMExSuWhNbJCdF8myiJC3nxsrca1aqFR56KKd8pjnsmsip0G+2THX0uZ52Y3IaT944M/X11sL81uw1HawC9DhIjpeik2EytAoGAJ/Ir+7/qruxKY+i84vQ3vOmCNoCkbrug6Injcuoz58w9OsOemBpjkHmgcHg2evXlRvaRSVJGz1GQ1LpCsjz80pakVXNbIcE6vkSt0lp5UtK3wX9mBivoejjiU1x5D+Y0tiv1MjDLTyqrO4R+nbUHjUw14lNp41G7jtN0HJ3hTAECgYEAkgtwQMEydeqaJ5VV74B3xeQwa5jLUuoosbRg8qSD8UGHl1+i7k2ttumtv0t4NpMpVjmO/n9WOld3BAvrN3IuO1FVmc9JuNBP9s+vQxeD9wvx0XcB4RKlY7mNAi/J3WQkBJfj1q0hTGtB9ZxWLfqLIv9yDxYPkWoPyJwWxA0ohBA=</code></pre>\n</li>\n</ol>\n<h2 id=\"QQ\"><a href=\"#QQ\" class=\"headerlink\" title=\"QQ\"></a>QQ</h2><h3 id=\"1-获取sid流程\"><a href=\"#1-获取sid流程\" class=\"headerlink\" title=\"1. 获取sid流程\"></a>1. 获取sid流程</h3><h3 id=\"2-前端代码\"><a href=\"#2-前端代码\" class=\"headerlink\" title=\"2. 前端代码\"></a>2. 前端代码</h3><pre><code class=\"js\">&lt;script type=&quot;application/javascript&quot; src=&quot;https://open.mobile.qq.com/sdk/qqapi.js?_bid=152&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    function pay()&#123;\n            //验证是否是QQ\n            mqq.device.isMobileQQ(function(result)&#123;\n                if(result) &#123;\n                    var isIos = mqq.iOS;\n                    //alert(&quot;是否是IOS:&quot; + isIos);\n                    var isAndroid = mqq.android;\n                    //alert(&quot;是否是Android:&quot; + isAndroid);\n                    var qqVersion = mqq.QQVersion;\n                    //alert(&quot;QQVersion:&quot; + qqVersion);\n                    //唤起QQ钱包\n                    this.callPay()\n                &#125; else &#123;\n                    alert(&quot;请在手机QQ中打开此页面&quot;);\n                    return false;\n                &#125;\n            &#125;);\n        &#125;\n\n        function callPay()&#123;\n            mqq.tenpay.pay(&#123;\n                tokenId: &quot;5Mfd2ffe642c61f498b8c03a4638a04e&quot;,\n            &#125;, function(result, resultCode)&#123;\n                if(result == &quot;Permission denied&quot;) &#123;\n                    alert(&quot;无权限 &quot;);\n                &#125; else &#123;\n                    alert(result.resultCode);\n                    document.location.href = &quot;$&#123;redirectUrl&#125;&quot;;\n                &#125;\n            &#125;);\n        &#125;\n&lt;/script&gt;</code></pre>\n<h2 id=\"具体实现相关\"><a href=\"#具体实现相关\" class=\"headerlink\" title=\"具体实现相关\"></a>具体实现相关</h2><h3 id=\"第一种方法（动态码）：\"><a href=\"#第一种方法（动态码）：\" class=\"headerlink\" title=\"第一种方法（动态码）：\"></a>第一种方法（动态码）：</h3><blockquote>\n<p>微信、支付宝 外包聚合支付页面，本质均使用 动态码下单 在浏览器中打开操作</p>\n</blockquote>\n<h3 id=\"第二种方法（jsapi）：\"><a href=\"#第二种方法（jsapi）：\" class=\"headerlink\" title=\"第二种方法（jsapi）：\"></a>第二种方法（jsapi）：</h3><blockquote>\n<p>微信支付宝使用先授权，外包聚合支付页面，再通过jsapi支付接口下单拉起支付。</p>\n</blockquote>\n<p>注：云闪付相关实现方式存疑。</p>\n<h2 id=\"钱宝相关\"><a href=\"#钱宝相关\" class=\"headerlink\" title=\"钱宝相关\"></a>钱宝相关</h2><pre><code>测试商户号：848290972306000  \n测试终端号：29002210\n目前配置支付授权目录：http://yangsongxiao.cn/ysf/</code></pre>\n<p><img src=\"/2020/03/25/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%8B%89%E8%B5%B7%E6%B5%81%E7%A8%8B/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/image-20210203155002102.png\" alt=\"image-20210203155002102\"></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://github.com/monk6658/unionpay-solidcode\">jsapi 的微信githup</a></p>\n"},{"title":"oracle 误删数据、表的恢复","date":"2020-10-21T06:16:33.000Z","description":"附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面","_content":"\n<font size=\"4\" color=\"#dd0000\">注意：鉴于oracle的特殊性，表名基本为大写（注意大小写问题）。</font>\n\n## 一、delete 误删数据问题\n\n### 1、根据v$sqlarea进行恢复，把表恢复到删除时间点\n1. 查询sql执行时间\n\n```\nselect SQL_TEXT,LAST_ACTIVE_TIME from v$sqlarea \nwhere LAST_ACTIVE_TIME > to_date('2020-07-09 9:30:27','yyyy-mm-dd hh24:mi:ss')\nand SQL_TEXT like '%表名%';\n```\n\n2. 根据时间进行恢复\n\n```oracle\nINSERT INTO 表名\nselect * from 表名 AS OF TIMESTAMP to_timestamp('2020-07-09 9:32:27','yyyy-mm-dd hh24:mi:ss');\n```\n### 2、根据闪回把表恢复到某个时间点\n\n```oracle\n-- 直接闪回某张表到某个时间点\nflashback table 表名 to timestamp to_date('2020-07-09 09:49:20','yyyy-mm-dd hh24:mi:ss');\n-- 出现异常则先授权，开启行移动功能 \nalter table 表名 enable row movement;\n```\n### 3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）\n```oracle\n-- 查询某个时间点的scn\nselect timestamp_to_scn(to_timestamp('2020-07-09 09:49:20','yyyy-mm-dd hh24:mi:ss')) from dual;\n\n-- 通过闪回把某张表恢复到某个时间点的scn\nflashback table 表名 to scn 161664467;\n```\n## 二、drop 误删表的恢复方法\n### 1、通过回收站恢复\n```oracle\n-- 查询被删除的表\nselect * from recyclebin where original_name like '%表名%'  order by droptime desc;\n-- 恢复被删除的表(如果该表重新被创建，需要恢复到新的表)（如果该表存在多次删除历史，只会恢复最后版本）\nflashback table '需要恢复的表名' to before drop [rename to 新表名]；\n\n-- 通过唯一标识(如果该表重新被创建，需要恢复到新的表)（根据recyclebin 的object_name 作为唯一标识恢复指定时间版本）\nflashback table \"BIN$BuhrIJqTR7qMITOgqKK8qg==$0\" to before drop rename to 新表名;\n```","source":"_posts/数据库操作/oracle/oracle 误删数据、表的恢复.md","raw":"---\ntitle: oracle 误删数据、表的恢复 #文章页面上的显示名称，一般是中文\ndate: 2020-10-21 14:16:33 #文章生成时间，一般不改，当然也可以任意修改\ncategories: oracle #分类\ntags: [运维,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面\n---\n\n<font size=\"4\" color=\"#dd0000\">注意：鉴于oracle的特殊性，表名基本为大写（注意大小写问题）。</font>\n\n## 一、delete 误删数据问题\n\n### 1、根据v$sqlarea进行恢复，把表恢复到删除时间点\n1. 查询sql执行时间\n\n```\nselect SQL_TEXT,LAST_ACTIVE_TIME from v$sqlarea \nwhere LAST_ACTIVE_TIME > to_date('2020-07-09 9:30:27','yyyy-mm-dd hh24:mi:ss')\nand SQL_TEXT like '%表名%';\n```\n\n2. 根据时间进行恢复\n\n```oracle\nINSERT INTO 表名\nselect * from 表名 AS OF TIMESTAMP to_timestamp('2020-07-09 9:32:27','yyyy-mm-dd hh24:mi:ss');\n```\n### 2、根据闪回把表恢复到某个时间点\n\n```oracle\n-- 直接闪回某张表到某个时间点\nflashback table 表名 to timestamp to_date('2020-07-09 09:49:20','yyyy-mm-dd hh24:mi:ss');\n-- 出现异常则先授权，开启行移动功能 \nalter table 表名 enable row movement;\n```\n### 3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）\n```oracle\n-- 查询某个时间点的scn\nselect timestamp_to_scn(to_timestamp('2020-07-09 09:49:20','yyyy-mm-dd hh24:mi:ss')) from dual;\n\n-- 通过闪回把某张表恢复到某个时间点的scn\nflashback table 表名 to scn 161664467;\n```\n## 二、drop 误删表的恢复方法\n### 1、通过回收站恢复\n```oracle\n-- 查询被删除的表\nselect * from recyclebin where original_name like '%表名%'  order by droptime desc;\n-- 恢复被删除的表(如果该表重新被创建，需要恢复到新的表)（如果该表存在多次删除历史，只会恢复最后版本）\nflashback table '需要恢复的表名' to before drop [rename to 新表名]；\n\n-- 通过唯一标识(如果该表重新被创建，需要恢复到新的表)（根据recyclebin 的object_name 作为唯一标识恢复指定时间版本）\nflashback table \"BIN$BuhrIJqTR7qMITOgqKK8qg==$0\" to before drop rename to 新表名;\n```","slug":"数据库操作/oracle/oracle 误删数据、表的恢复","published":1,"updated":"2020-12-17T02:48:58.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknqx8kfa001dbotk0hwla8sp","content":"<p><font size=\"4\" color=\"#dd0000\">注意：鉴于oracle的特殊性，表名基本为大写（注意大小写问题）。</font></p>\n<h2 id=\"一、delete-误删数据问题\"><a href=\"#一、delete-误删数据问题\" class=\"headerlink\" title=\"一、delete 误删数据问题\"></a>一、delete 误删数据问题</h2><h3 id=\"1、根据v-sqlarea进行恢复，把表恢复到删除时间点\"><a href=\"#1、根据v-sqlarea进行恢复，把表恢复到删除时间点\" class=\"headerlink\" title=\"1、根据v$sqlarea进行恢复，把表恢复到删除时间点\"></a>1、根据v$sqlarea进行恢复，把表恢复到删除时间点</h3><ol>\n<li>查询sql执行时间</li>\n</ol>\n<pre><code>select SQL_TEXT,LAST_ACTIVE_TIME from v$sqlarea \nwhere LAST_ACTIVE_TIME &gt; to_date(&#39;2020-07-09 9:30:27&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;)\nand SQL_TEXT like &#39;%表名%&#39;;</code></pre>\n<ol start=\"2\">\n<li>根据时间进行恢复</li>\n</ol>\n<pre><code class=\"oracle\">INSERT INTO 表名\nselect * from 表名 AS OF TIMESTAMP to_timestamp(&#39;2020-07-09 9:32:27&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;);</code></pre>\n<h3 id=\"2、根据闪回把表恢复到某个时间点\"><a href=\"#2、根据闪回把表恢复到某个时间点\" class=\"headerlink\" title=\"2、根据闪回把表恢复到某个时间点\"></a>2、根据闪回把表恢复到某个时间点</h3><pre><code class=\"oracle\">-- 直接闪回某张表到某个时间点\nflashback table 表名 to timestamp to_date(&#39;2020-07-09 09:49:20&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;);\n-- 出现异常则先授权，开启行移动功能 \nalter table 表名 enable row movement;</code></pre>\n<h3 id=\"3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）\"><a href=\"#3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）\" class=\"headerlink\" title=\"3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）\"></a>3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）</h3><pre><code class=\"oracle\">-- 查询某个时间点的scn\nselect timestamp_to_scn(to_timestamp(&#39;2020-07-09 09:49:20&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;)) from dual;\n\n-- 通过闪回把某张表恢复到某个时间点的scn\nflashback table 表名 to scn 161664467;</code></pre>\n<h2 id=\"二、drop-误删表的恢复方法\"><a href=\"#二、drop-误删表的恢复方法\" class=\"headerlink\" title=\"二、drop 误删表的恢复方法\"></a>二、drop 误删表的恢复方法</h2><h3 id=\"1、通过回收站恢复\"><a href=\"#1、通过回收站恢复\" class=\"headerlink\" title=\"1、通过回收站恢复\"></a>1、通过回收站恢复</h3><pre><code class=\"oracle\">-- 查询被删除的表\nselect * from recyclebin where original_name like &#39;%表名%&#39;  order by droptime desc;\n-- 恢复被删除的表(如果该表重新被创建，需要恢复到新的表)（如果该表存在多次删除历史，只会恢复最后版本）\nflashback table &#39;需要恢复的表名&#39; to before drop [rename to 新表名]；\n\n-- 通过唯一标识(如果该表重新被创建，需要恢复到新的表)（根据recyclebin 的object_name 作为唯一标识恢复指定时间版本）\nflashback table &quot;BIN$BuhrIJqTR7qMITOgqKK8qg==$0&quot; to before drop rename to 新表名;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><font size=\"4\" color=\"#dd0000\">注意：鉴于oracle的特殊性，表名基本为大写（注意大小写问题）。</font></p>\n<h2 id=\"一、delete-误删数据问题\"><a href=\"#一、delete-误删数据问题\" class=\"headerlink\" title=\"一、delete 误删数据问题\"></a>一、delete 误删数据问题</h2><h3 id=\"1、根据v-sqlarea进行恢复，把表恢复到删除时间点\"><a href=\"#1、根据v-sqlarea进行恢复，把表恢复到删除时间点\" class=\"headerlink\" title=\"1、根据v$sqlarea进行恢复，把表恢复到删除时间点\"></a>1、根据v$sqlarea进行恢复，把表恢复到删除时间点</h3><ol>\n<li>查询sql执行时间</li>\n</ol>\n<pre><code>select SQL_TEXT,LAST_ACTIVE_TIME from v$sqlarea \nwhere LAST_ACTIVE_TIME &gt; to_date(&#39;2020-07-09 9:30:27&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;)\nand SQL_TEXT like &#39;%表名%&#39;;</code></pre>\n<ol start=\"2\">\n<li>根据时间进行恢复</li>\n</ol>\n<pre><code class=\"oracle\">INSERT INTO 表名\nselect * from 表名 AS OF TIMESTAMP to_timestamp(&#39;2020-07-09 9:32:27&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;);</code></pre>\n<h3 id=\"2、根据闪回把表恢复到某个时间点\"><a href=\"#2、根据闪回把表恢复到某个时间点\" class=\"headerlink\" title=\"2、根据闪回把表恢复到某个时间点\"></a>2、根据闪回把表恢复到某个时间点</h3><pre><code class=\"oracle\">-- 直接闪回某张表到某个时间点\nflashback table 表名 to timestamp to_date(&#39;2020-07-09 09:49:20&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;);\n-- 出现异常则先授权，开启行移动功能 \nalter table 表名 enable row movement;</code></pre>\n<h3 id=\"3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）\"><a href=\"#3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）\" class=\"headerlink\" title=\"3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）\"></a>3、通过scn进行恢复（根据scn可把整个库恢复到某个时间点）</h3><pre><code class=\"oracle\">-- 查询某个时间点的scn\nselect timestamp_to_scn(to_timestamp(&#39;2020-07-09 09:49:20&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;)) from dual;\n\n-- 通过闪回把某张表恢复到某个时间点的scn\nflashback table 表名 to scn 161664467;</code></pre>\n<h2 id=\"二、drop-误删表的恢复方法\"><a href=\"#二、drop-误删表的恢复方法\" class=\"headerlink\" title=\"二、drop 误删表的恢复方法\"></a>二、drop 误删表的恢复方法</h2><h3 id=\"1、通过回收站恢复\"><a href=\"#1、通过回收站恢复\" class=\"headerlink\" title=\"1、通过回收站恢复\"></a>1、通过回收站恢复</h3><pre><code class=\"oracle\">-- 查询被删除的表\nselect * from recyclebin where original_name like &#39;%表名%&#39;  order by droptime desc;\n-- 恢复被删除的表(如果该表重新被创建，需要恢复到新的表)（如果该表存在多次删除历史，只会恢复最后版本）\nflashback table &#39;需要恢复的表名&#39; to before drop [rename to 新表名]；\n\n-- 通过唯一标识(如果该表重新被创建，需要恢复到新的表)（根据recyclebin 的object_name 作为唯一标识恢复指定时间版本）\nflashback table &quot;BIN$BuhrIJqTR7qMITOgqKK8qg==$0&quot; to before drop rename to 新表名;</code></pre>\n"},{"title":"netty分包粘包问题","date":"2021-03-30T06:16:33.000Z","description":"netty自定义协议，实现分包粘包问题。","typora-copy-images-to":"netty","_content":"\n## 基于长度协议的分包\n\n注：本文 length 均为 16进制表示，eg:  1232 ==> 04D0\n\n[TOC]\n\n### 1. 业务场景介绍\n\n基于长度协议分包（length + value）\n\n在和c语言对接过程中，因数据包长度大于一定长度后分包发送，致使handler接收数据不全出现问题。\n\n### 2. 具体现象描述\n\n1. c语言方 每1011字节就会自动分多小包发送\n2. 使用netty自带的长度协议 LengthFieldBasedFrameDecoder 只能接收到半包\n\n### 3. 解决思路\n\n自定义长度协议包，根据length 进行判断包是否完整，进而决定是否进逻辑层处理\n\n### 4. 具体实现\n\n#### 4.1 服务端实现\n\n1. 基础服务端server，三个处理器分别为：日志、自定义长度协议、逻辑处理\n\n```java\n@Slf4j\npublic class NettyServer {\n\n    public static void main(String[] args) {\n\n        // 1. 创建两个工作线程组，两个无线循环(默认线程组为   cpu核数 * 2 )\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1); // 处理客户端的链接\n        EventLoopGroup workerGroup = new NioEventLoopGroup(8);  // 网络的读写\n        try {\n            // 2. 服务启动配置\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup,workerGroup)\n                    .channel(NioServerSocketChannel.class)  // 使用NioServerSocketChannel 作为服务端的通道实现\n                    .option(ChannelOption.SO_BACKLOG, 128)  // 设置线程队列连接个数\n                    .childOption(ChannelOption.SO_KEEPALIVE, true)  // 设置保持活动连接状态\n                    .childHandler(new ChannelInitializer<SocketChannel>() {  //创建一个通道初始化对象\n                        @Override\n                        protected void initChannel(SocketChannel ch) { // 给pipeline设置处理器\n                            ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));\n                            // 自定义长度协议\n                            ch.pipeline().addLast(new MyLengthFieldBasedFrameDecoder(1024,0,2));\n                            // netty官方长度协议\n//                            ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024*2,0,2));\n                            ch.pipeline().addLast(new NettyServerHandler());\n                        }\n                    });\n            ChannelFuture channelFuture = bootstrap.bind(9999).sync();\n            channelFuture.channel().closeFuture().sync();\n        }catch (Exception e){\n            log.error(\"启动异常，优雅关闭\",e);\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n}\n```\n\n#### 4.2 自定义长度协议处理器\n\n1. 基础构造函数，获取基础数据信息：包最大长度、长度位起始位置、长度位结束位置、逻辑数据截取起始位置、逻辑数据截取长度\n2. 使用netty自带当前线程变量记录当前线程基础数据\n3. 根据 **_length_** 判断包是否完整\n4. 若包完整，则使用 **_super.channelRead(XX,XX);_** 进入下一个handler\n\n```java\n/**\n * netty 服务端逻辑处理类（长度为16进制编码）\n * 这种分包，不支持奇数16进制分包，必须是整个字节，eg：000430245678  分包：3024567   、8 错误。\n * 必须两个十六进制组成一个byte分包才对\n * @author zxl\n * @date 2021/3/23 10:29\n */\n@Slf4j\npublic class MyLengthFieldBasedFrameDecoder extends ChannelInboundHandlerAdapter {\n\n    /*** 实际长度 */\n    private FastThreadLocal<Integer> actualLength = new FastThreadLocal<>();\n    /*** 实际内容 */\n    private FastThreadLocal<byte[]> actualContent = new FastThreadLocal<>();\n    /*** 最大长度 */\n    private FastThreadLocal<Integer> maxFrameLength = new FastThreadLocal<>();\n    /*** 长度位数起始下标 */\n    private FastThreadLocal<Integer> lengthFieldOffset = new FastThreadLocal<>();\n    /*** 长度位数结束下标 */\n    private FastThreadLocal<Integer> lengthFieldLength = new FastThreadLocal<>();\n    /*** 长度调整起始下标 */\n    private FastThreadLocal<Integer> lengthAdjustment = new FastThreadLocal<>();\n    /*** 长度调整结束下标 */\n    private FastThreadLocal<Integer> initialBytesToStrip = new FastThreadLocal<>();\n\n    /**\n     * 基础构造方法\n     * @param maxFrameLength 最大长度\n     * @param lengthFieldOffset 长度下标起始位置\n     * @param lengthFieldLength 长度所占字节位数\n     */\n    public MyLengthFieldBasedFrameDecoder(int maxFrameLength, int lengthFieldOffset, int lengthFieldLength) {\n        this(maxFrameLength, lengthFieldOffset, lengthFieldLength, 0, 0);\n    }\n\n    /**\n     * 基础构造方法\n     * @param maxFrameLength 最大长度\n     * @param lengthFieldOffset 长度下标起始位置\n     * @param lengthFieldLength 长度所占字节位数\n     * @param lengthAdjustment 真实数据下标起始位置\n     * @param initialBytesToStrip 初始化略过字节数\n     */\n    public MyLengthFieldBasedFrameDecoder(int maxFrameLength, int lengthFieldOffset, int lengthFieldLength, int lengthAdjustment, int initialBytesToStrip) {\n        if (maxFrameLength <= 0) {\n            throw new IllegalArgumentException(\"maxFrameLength must be a positive integer: \" + maxFrameLength);\n        } else if (lengthFieldOffset < 0) {\n            throw new IllegalArgumentException(\"lengthFieldOffset must be a non-negative integer: \" + lengthFieldOffset);\n        } else if (initialBytesToStrip < 0) {\n            throw new IllegalArgumentException(\"initialBytesToStrip must be a non-negative integer: \" + initialBytesToStrip);\n        } else if (lengthFieldOffset > maxFrameLength - lengthFieldLength) {\n            throw new IllegalArgumentException(\"maxFrameLength (\" + maxFrameLength + \") must be equal to or greater than lengthFieldOffset (\" + lengthFieldOffset + \") + lengthFieldLength (\" + lengthFieldLength + \").\");\n        }else{\n            this.maxFrameLength.set(maxFrameLength);\n            this.lengthFieldOffset.set(lengthFieldOffset);\n            this.lengthFieldLength.set(lengthFieldLength);\n            this.lengthAdjustment.set(lengthAdjustment);\n            this.initialBytesToStrip.set(initialBytesToStrip);\n        }\n    }\n\n    /**\n     * 实际数据读取处理\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        // 1. 数据读取\n        ByteBuf byteBuf = (ByteBuf) msg;\n        byte[] requestMsg = new byte[byteBuf.readableBytes()];\n        byteBuf.readBytes(requestMsg);\n\n        // 2. 首次消息判断,并对数据处理\n        if(actualContent.get() == null){\n            String receiveMsg = bytesToHex(requestMsg);\n            // 因为是字节数据长度，2个字节，故需要截取4位长度。下移开始下标*2，假设不是 length + value 格式\n            String length = receiveMsg.substring(this.lengthFieldOffset.get(), this.lengthFieldLength.get()*2);\n            // 默认长度为 16进制表示\n            int i = Integer.parseInt(length, 16);\n            log.info(\"第一次数据接收:{},数据长度:{}\",receiveMsg,i);\n            if(i + this.lengthFieldLength.get() == requestMsg.length){\n                super.channelRead(ctx,requestMsg);\n            }\n            // 数据长度，带长度位\n            actualLength.set(i + this.lengthFieldLength.get());\n            actualContent.set(requestMsg);\n        }else{\n            // 3. 二次分包处理\n            byte[] content = actualContent.get();\n            int newLength = content.length + requestMsg.length;\n            if(newLength > maxFrameLength.get()){\n                throw new TooLongFrameException(\"Adjusted frame length exceeds \" + this.maxFrameLength.get() + \" - discarding\");\n            }\n\n            byte[] next = appendByteArray(content,requestMsg);\n            log.info(\"next:{}\",bytesToHex(next));\n            if(actualLength.get() == newLength){\n                byte[] actByte = null;\n                if(lengthAdjustment.get() == 0){\n                    actByte = Arrays.copyOfRange(next, initialBytesToStrip.get(), next.length);\n                }else{\n                    byte[] startByte = Arrays.copyOfRange(next, 0, lengthAdjustment.get());\n                    byte[] endByte = Arrays.copyOfRange(next, initialBytesToStrip.get(), next.length);\n                    actByte = appendByteArray(startByte,endByte);\n                }\n                super.channelRead(ctx,actByte);\n            }else{\n                actualContent.set(next);\n            }\n        }\n    }\n\n    /**\n     * 执行中异常\n     * @param ctx 上下文\n     * @param cause 执行异常\n     * @throws Exception 方法体异常\n     */\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        log.error(\"执行中异常\",cause);\n        releaseThreadLocalResource();\n        ctx.close();\n    }\n\n    /**\n     * 连接断开时，释放当前线程变量资源\n     * @param ctx 上下文\n     * @throws Exception 执行中异常\n     */\n    @Override\n    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n        releaseThreadLocalResource();\n        log.info(\"客户端连接断开了+++++++{}\",ctx.channel().remoteAddress().toString());\n        super.channelUnregistered(ctx);\n    }\n\n    /**\n     * 释放当前线程变量\n     */\n    private void releaseThreadLocalResource(){\n        maxFrameLength.remove();\n        lengthFieldOffset.remove();\n        lengthFieldLength.remove();\n        lengthAdjustment.remove();\n        initialBytesToStrip.remove();\n        actualLength.remove();\n        actualContent.remove();\n    }\n\n    /**\n     * byte[] 数组转16进制字符串\n     * @param bytes 字节数据\n     * @return 16进制字符串\n     */\n    private static String bytesToHex(byte[] bytes) {\n        StringBuilder sb = new StringBuilder();\n        for (byte aByte : bytes) {\n            String hex = Integer.toHexString(aByte & 0xFF);\n            if (hex.length() < 2) {\n                sb.append(0);\n            }\n            sb.append(hex);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * 字节数组拼接\n     * @param array1 拼接第一个数组\n     * @param array2 第二个数组\n     * @return 拼接结果\n     */\n    private byte[] appendByteArray(byte[] array1,byte[] array2){\n        byte[] newArray = new byte[array1.length + array2.length];\n        System.arraycopy(array1,0,newArray,0,array1.length);\n        System.arraycopy(array2,0,newArray,array1.length,array2.length);\n        return newArray;\n    }\n}\n```\n\n#### 4.3 逻辑处理器\n\n1. 获取上一个 **_handler_** 处理之后的数据\n2. **_channelRead_** 方法中 **_Object msg_** 对象类型是依据上一个 **_handler_**  中 **_channelRead()_** 传入的类型而定。即 **_super.channelRead(XX,XX);_**  第二个XX 所代表的类型\n3. 因上一个 **_handler_** 传入为byte[] ，故下方以byte[] 接收。\n4. 原生netty 长度协议 则为ByteBuf 接收。\n\n```java\n/**\n * netty 服务端逻辑处理类\n * @author zxl\n * @date 2021/3/23 10:29\n */\n@Slf4j\npublic class NettyServerHandler extends ChannelInboundHandlerAdapter {\n\n    /**\n     * 连接注册时执行\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n        log.info(\"客户端连接{}\",ctx.channel().remoteAddress().toString());\n        super.channelRegistered(ctx);\n    }\n\n    /**\n     * 连接关闭时执行\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n        log.info(\"客户端连接断开了{}\",ctx.channel().remoteAddress().toString());\n        super.channelUnregistered(ctx);\n    }\n\n    /**\n     * 连接活跃\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        log.info(\"连接活跃，有信息进入\");\n    }\n\n    /**\n     * 连接不活跃\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        log.info(\"连接不活跃，信息写完发送完毕\");\n    }\n    /**\n     * 实际数据读取处理\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\n        if(msg instanceof byte[]){\n            byte[] requestMsg = (byte[]) msg;\n            log.info(\"最终接收数据----:{}\",bytesToHex(requestMsg));\n        }else{\n            ByteBuf byteBuf = (ByteBuf) msg;\n            byte[] requestMsg = new byte[byteBuf.readableBytes()];\n            byteBuf.readBytes(requestMsg);\n            log.info(\"ByteBuf 最终接收数据----:{}\",bytesToHex(requestMsg));\n        }\n    }\n\n    /**\n     * 实际数据读取完成处理\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n        log.info(\"数据读取完毕之后 channelReadComplete \");\n    }\n\n\n    /**\n     * 连接事件判断\n     * @param ctx 上下文\n     * @param evt 事件对象\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        log.info(\"channel 用户事件触发\");\n    }\n\n    /**\n     * 实际数据读取完成处理 ,关闭通道\n     * @param ctx 上下文\n     * @param cause 执行异常\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        log.error(\"执行中异常\",cause);\n        ctx.close();\n    }\n\n\n    /**\n     * byte[] 数组转16进制字符串\n     * @param bytes 字节数据\n     * @return 16进制字符串\n     */\n    private static String bytesToHex(byte[] bytes) {\n        StringBuilder sb = new StringBuilder();\n        for (byte aByte : bytes) {\n            String hex = Integer.toHexString(aByte & 0xFF);\n            if (hex.length() < 2) {\n                sb.append(0);\n            }\n            sb.append(hex);\n        }\n        return sb.toString();\n    }\n}\n```\n\n### 5. 测试方式\n\n> 上述代码为 长度均为2个字节，故以下也遵循代码走。\n>\n> 测试数据包：`000C321453215435413415206753`\n>\n> 000C ==>  12 (十进制)\n>\n> 注：传输方式是以byte[] 进行传输，转16进制后，每两个16进制数为一个byte，故整体数据包长度一定为偶数。故测分包问题时，切不可把16进制表示的数据包分奇数拆分，奇数拆分后涉及到byte自动补零问题，最终导致分包测试失败，逻辑数据不准确。\n\n1. 使用socket发送工具，组长度协议包( lenth[0x] + value)     \n\n![image-20210331151558717](\\netty\\image-20210331151558717.png)\n\n2. 先整体发送 `000C321453215435413415206753`，查看是否会进入逻辑handler。查看没问题\n\n   ![image-20210331152602573](\\netty\\image-20210331152602573.png)\n\n3. 关闭工具重新打开（目前都是短连接测试），先发 `000C32145321543541341520`  ，再发`6753` 查看结果\n\n   ![image-20210331153715016](\\netty\\image-20210331153715016.png)\n\n4. 上述测试没有问题，使用厂商机器测试\n\n### 6. 注意问题\n\n1. 传输方式是以byte[] 进行传输，转16进制后，每两个16进制数为一个byte，故整体数据包长度一定为偶数。故测分包问题时，切不可把16进制表示的数据包分奇数拆分，奇数拆分后涉及到byte自动补零问题，最终导致分包测试失败，逻辑数据不准确。\n2. 使用socket工具发送，使用netty原生的`LengthFieldBasedFrameDecoder`即可满足需求\n3. `LengthFieldBasedFrameDecoder`长度协议，长度也必须为16进制表示，不然取前几位转16进制之后，容易抛出异常`Adjusted frame length exceeds`\n4. 如若没有长度协议，服务端会每1024字节分包读取（待解决处理）\n\n## 其他分包解决方案\n\n1. 定长协议 \n\n   ```java\n   new FixedLengthFrameDecoder(1024)\n   ```\n\n2. 分隔符协议\n\n   ```java\n   //设置特殊分隔符\n   ByteBuf buf = Unpooled.copiedBuffer(\"_\".getBytes());\n   new DelimiterBasedFrameDecoder(1024, buf);\n   ```\n\n3. 待补充。。\n\n\n","source":"_posts/netty/netty分包粘包问题.md","raw":"---\ntitle: netty分包粘包问题 \ndate: 2021-03-30 14:16:33 \ncategories: 并发、netty #分类\ntags: [锁netty,并发,分包粘包] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: netty自定义协议，实现分包粘包问题。\ntypora-copy-images-to: netty\n---\n\n## 基于长度协议的分包\n\n注：本文 length 均为 16进制表示，eg:  1232 ==> 04D0\n\n[TOC]\n\n### 1. 业务场景介绍\n\n基于长度协议分包（length + value）\n\n在和c语言对接过程中，因数据包长度大于一定长度后分包发送，致使handler接收数据不全出现问题。\n\n### 2. 具体现象描述\n\n1. c语言方 每1011字节就会自动分多小包发送\n2. 使用netty自带的长度协议 LengthFieldBasedFrameDecoder 只能接收到半包\n\n### 3. 解决思路\n\n自定义长度协议包，根据length 进行判断包是否完整，进而决定是否进逻辑层处理\n\n### 4. 具体实现\n\n#### 4.1 服务端实现\n\n1. 基础服务端server，三个处理器分别为：日志、自定义长度协议、逻辑处理\n\n```java\n@Slf4j\npublic class NettyServer {\n\n    public static void main(String[] args) {\n\n        // 1. 创建两个工作线程组，两个无线循环(默认线程组为   cpu核数 * 2 )\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1); // 处理客户端的链接\n        EventLoopGroup workerGroup = new NioEventLoopGroup(8);  // 网络的读写\n        try {\n            // 2. 服务启动配置\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup,workerGroup)\n                    .channel(NioServerSocketChannel.class)  // 使用NioServerSocketChannel 作为服务端的通道实现\n                    .option(ChannelOption.SO_BACKLOG, 128)  // 设置线程队列连接个数\n                    .childOption(ChannelOption.SO_KEEPALIVE, true)  // 设置保持活动连接状态\n                    .childHandler(new ChannelInitializer<SocketChannel>() {  //创建一个通道初始化对象\n                        @Override\n                        protected void initChannel(SocketChannel ch) { // 给pipeline设置处理器\n                            ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));\n                            // 自定义长度协议\n                            ch.pipeline().addLast(new MyLengthFieldBasedFrameDecoder(1024,0,2));\n                            // netty官方长度协议\n//                            ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024*2,0,2));\n                            ch.pipeline().addLast(new NettyServerHandler());\n                        }\n                    });\n            ChannelFuture channelFuture = bootstrap.bind(9999).sync();\n            channelFuture.channel().closeFuture().sync();\n        }catch (Exception e){\n            log.error(\"启动异常，优雅关闭\",e);\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n}\n```\n\n#### 4.2 自定义长度协议处理器\n\n1. 基础构造函数，获取基础数据信息：包最大长度、长度位起始位置、长度位结束位置、逻辑数据截取起始位置、逻辑数据截取长度\n2. 使用netty自带当前线程变量记录当前线程基础数据\n3. 根据 **_length_** 判断包是否完整\n4. 若包完整，则使用 **_super.channelRead(XX,XX);_** 进入下一个handler\n\n```java\n/**\n * netty 服务端逻辑处理类（长度为16进制编码）\n * 这种分包，不支持奇数16进制分包，必须是整个字节，eg：000430245678  分包：3024567   、8 错误。\n * 必须两个十六进制组成一个byte分包才对\n * @author zxl\n * @date 2021/3/23 10:29\n */\n@Slf4j\npublic class MyLengthFieldBasedFrameDecoder extends ChannelInboundHandlerAdapter {\n\n    /*** 实际长度 */\n    private FastThreadLocal<Integer> actualLength = new FastThreadLocal<>();\n    /*** 实际内容 */\n    private FastThreadLocal<byte[]> actualContent = new FastThreadLocal<>();\n    /*** 最大长度 */\n    private FastThreadLocal<Integer> maxFrameLength = new FastThreadLocal<>();\n    /*** 长度位数起始下标 */\n    private FastThreadLocal<Integer> lengthFieldOffset = new FastThreadLocal<>();\n    /*** 长度位数结束下标 */\n    private FastThreadLocal<Integer> lengthFieldLength = new FastThreadLocal<>();\n    /*** 长度调整起始下标 */\n    private FastThreadLocal<Integer> lengthAdjustment = new FastThreadLocal<>();\n    /*** 长度调整结束下标 */\n    private FastThreadLocal<Integer> initialBytesToStrip = new FastThreadLocal<>();\n\n    /**\n     * 基础构造方法\n     * @param maxFrameLength 最大长度\n     * @param lengthFieldOffset 长度下标起始位置\n     * @param lengthFieldLength 长度所占字节位数\n     */\n    public MyLengthFieldBasedFrameDecoder(int maxFrameLength, int lengthFieldOffset, int lengthFieldLength) {\n        this(maxFrameLength, lengthFieldOffset, lengthFieldLength, 0, 0);\n    }\n\n    /**\n     * 基础构造方法\n     * @param maxFrameLength 最大长度\n     * @param lengthFieldOffset 长度下标起始位置\n     * @param lengthFieldLength 长度所占字节位数\n     * @param lengthAdjustment 真实数据下标起始位置\n     * @param initialBytesToStrip 初始化略过字节数\n     */\n    public MyLengthFieldBasedFrameDecoder(int maxFrameLength, int lengthFieldOffset, int lengthFieldLength, int lengthAdjustment, int initialBytesToStrip) {\n        if (maxFrameLength <= 0) {\n            throw new IllegalArgumentException(\"maxFrameLength must be a positive integer: \" + maxFrameLength);\n        } else if (lengthFieldOffset < 0) {\n            throw new IllegalArgumentException(\"lengthFieldOffset must be a non-negative integer: \" + lengthFieldOffset);\n        } else if (initialBytesToStrip < 0) {\n            throw new IllegalArgumentException(\"initialBytesToStrip must be a non-negative integer: \" + initialBytesToStrip);\n        } else if (lengthFieldOffset > maxFrameLength - lengthFieldLength) {\n            throw new IllegalArgumentException(\"maxFrameLength (\" + maxFrameLength + \") must be equal to or greater than lengthFieldOffset (\" + lengthFieldOffset + \") + lengthFieldLength (\" + lengthFieldLength + \").\");\n        }else{\n            this.maxFrameLength.set(maxFrameLength);\n            this.lengthFieldOffset.set(lengthFieldOffset);\n            this.lengthFieldLength.set(lengthFieldLength);\n            this.lengthAdjustment.set(lengthAdjustment);\n            this.initialBytesToStrip.set(initialBytesToStrip);\n        }\n    }\n\n    /**\n     * 实际数据读取处理\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        // 1. 数据读取\n        ByteBuf byteBuf = (ByteBuf) msg;\n        byte[] requestMsg = new byte[byteBuf.readableBytes()];\n        byteBuf.readBytes(requestMsg);\n\n        // 2. 首次消息判断,并对数据处理\n        if(actualContent.get() == null){\n            String receiveMsg = bytesToHex(requestMsg);\n            // 因为是字节数据长度，2个字节，故需要截取4位长度。下移开始下标*2，假设不是 length + value 格式\n            String length = receiveMsg.substring(this.lengthFieldOffset.get(), this.lengthFieldLength.get()*2);\n            // 默认长度为 16进制表示\n            int i = Integer.parseInt(length, 16);\n            log.info(\"第一次数据接收:{},数据长度:{}\",receiveMsg,i);\n            if(i + this.lengthFieldLength.get() == requestMsg.length){\n                super.channelRead(ctx,requestMsg);\n            }\n            // 数据长度，带长度位\n            actualLength.set(i + this.lengthFieldLength.get());\n            actualContent.set(requestMsg);\n        }else{\n            // 3. 二次分包处理\n            byte[] content = actualContent.get();\n            int newLength = content.length + requestMsg.length;\n            if(newLength > maxFrameLength.get()){\n                throw new TooLongFrameException(\"Adjusted frame length exceeds \" + this.maxFrameLength.get() + \" - discarding\");\n            }\n\n            byte[] next = appendByteArray(content,requestMsg);\n            log.info(\"next:{}\",bytesToHex(next));\n            if(actualLength.get() == newLength){\n                byte[] actByte = null;\n                if(lengthAdjustment.get() == 0){\n                    actByte = Arrays.copyOfRange(next, initialBytesToStrip.get(), next.length);\n                }else{\n                    byte[] startByte = Arrays.copyOfRange(next, 0, lengthAdjustment.get());\n                    byte[] endByte = Arrays.copyOfRange(next, initialBytesToStrip.get(), next.length);\n                    actByte = appendByteArray(startByte,endByte);\n                }\n                super.channelRead(ctx,actByte);\n            }else{\n                actualContent.set(next);\n            }\n        }\n    }\n\n    /**\n     * 执行中异常\n     * @param ctx 上下文\n     * @param cause 执行异常\n     * @throws Exception 方法体异常\n     */\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        log.error(\"执行中异常\",cause);\n        releaseThreadLocalResource();\n        ctx.close();\n    }\n\n    /**\n     * 连接断开时，释放当前线程变量资源\n     * @param ctx 上下文\n     * @throws Exception 执行中异常\n     */\n    @Override\n    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n        releaseThreadLocalResource();\n        log.info(\"客户端连接断开了+++++++{}\",ctx.channel().remoteAddress().toString());\n        super.channelUnregistered(ctx);\n    }\n\n    /**\n     * 释放当前线程变量\n     */\n    private void releaseThreadLocalResource(){\n        maxFrameLength.remove();\n        lengthFieldOffset.remove();\n        lengthFieldLength.remove();\n        lengthAdjustment.remove();\n        initialBytesToStrip.remove();\n        actualLength.remove();\n        actualContent.remove();\n    }\n\n    /**\n     * byte[] 数组转16进制字符串\n     * @param bytes 字节数据\n     * @return 16进制字符串\n     */\n    private static String bytesToHex(byte[] bytes) {\n        StringBuilder sb = new StringBuilder();\n        for (byte aByte : bytes) {\n            String hex = Integer.toHexString(aByte & 0xFF);\n            if (hex.length() < 2) {\n                sb.append(0);\n            }\n            sb.append(hex);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * 字节数组拼接\n     * @param array1 拼接第一个数组\n     * @param array2 第二个数组\n     * @return 拼接结果\n     */\n    private byte[] appendByteArray(byte[] array1,byte[] array2){\n        byte[] newArray = new byte[array1.length + array2.length];\n        System.arraycopy(array1,0,newArray,0,array1.length);\n        System.arraycopy(array2,0,newArray,array1.length,array2.length);\n        return newArray;\n    }\n}\n```\n\n#### 4.3 逻辑处理器\n\n1. 获取上一个 **_handler_** 处理之后的数据\n2. **_channelRead_** 方法中 **_Object msg_** 对象类型是依据上一个 **_handler_**  中 **_channelRead()_** 传入的类型而定。即 **_super.channelRead(XX,XX);_**  第二个XX 所代表的类型\n3. 因上一个 **_handler_** 传入为byte[] ，故下方以byte[] 接收。\n4. 原生netty 长度协议 则为ByteBuf 接收。\n\n```java\n/**\n * netty 服务端逻辑处理类\n * @author zxl\n * @date 2021/3/23 10:29\n */\n@Slf4j\npublic class NettyServerHandler extends ChannelInboundHandlerAdapter {\n\n    /**\n     * 连接注册时执行\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n        log.info(\"客户端连接{}\",ctx.channel().remoteAddress().toString());\n        super.channelRegistered(ctx);\n    }\n\n    /**\n     * 连接关闭时执行\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n        log.info(\"客户端连接断开了{}\",ctx.channel().remoteAddress().toString());\n        super.channelUnregistered(ctx);\n    }\n\n    /**\n     * 连接活跃\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        log.info(\"连接活跃，有信息进入\");\n    }\n\n    /**\n     * 连接不活跃\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        log.info(\"连接不活跃，信息写完发送完毕\");\n    }\n    /**\n     * 实际数据读取处理\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\n        if(msg instanceof byte[]){\n            byte[] requestMsg = (byte[]) msg;\n            log.info(\"最终接收数据----:{}\",bytesToHex(requestMsg));\n        }else{\n            ByteBuf byteBuf = (ByteBuf) msg;\n            byte[] requestMsg = new byte[byteBuf.readableBytes()];\n            byteBuf.readBytes(requestMsg);\n            log.info(\"ByteBuf 最终接收数据----:{}\",bytesToHex(requestMsg));\n        }\n    }\n\n    /**\n     * 实际数据读取完成处理\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n        log.info(\"数据读取完毕之后 channelReadComplete \");\n    }\n\n\n    /**\n     * 连接事件判断\n     * @param ctx 上下文\n     * @param evt 事件对象\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        log.info(\"channel 用户事件触发\");\n    }\n\n    /**\n     * 实际数据读取完成处理 ,关闭通道\n     * @param ctx 上下文\n     * @param cause 执行异常\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        log.error(\"执行中异常\",cause);\n        ctx.close();\n    }\n\n\n    /**\n     * byte[] 数组转16进制字符串\n     * @param bytes 字节数据\n     * @return 16进制字符串\n     */\n    private static String bytesToHex(byte[] bytes) {\n        StringBuilder sb = new StringBuilder();\n        for (byte aByte : bytes) {\n            String hex = Integer.toHexString(aByte & 0xFF);\n            if (hex.length() < 2) {\n                sb.append(0);\n            }\n            sb.append(hex);\n        }\n        return sb.toString();\n    }\n}\n```\n\n### 5. 测试方式\n\n> 上述代码为 长度均为2个字节，故以下也遵循代码走。\n>\n> 测试数据包：`000C321453215435413415206753`\n>\n> 000C ==>  12 (十进制)\n>\n> 注：传输方式是以byte[] 进行传输，转16进制后，每两个16进制数为一个byte，故整体数据包长度一定为偶数。故测分包问题时，切不可把16进制表示的数据包分奇数拆分，奇数拆分后涉及到byte自动补零问题，最终导致分包测试失败，逻辑数据不准确。\n\n1. 使用socket发送工具，组长度协议包( lenth[0x] + value)     \n\n![image-20210331151558717](\\netty\\image-20210331151558717.png)\n\n2. 先整体发送 `000C321453215435413415206753`，查看是否会进入逻辑handler。查看没问题\n\n   ![image-20210331152602573](\\netty\\image-20210331152602573.png)\n\n3. 关闭工具重新打开（目前都是短连接测试），先发 `000C32145321543541341520`  ，再发`6753` 查看结果\n\n   ![image-20210331153715016](\\netty\\image-20210331153715016.png)\n\n4. 上述测试没有问题，使用厂商机器测试\n\n### 6. 注意问题\n\n1. 传输方式是以byte[] 进行传输，转16进制后，每两个16进制数为一个byte，故整体数据包长度一定为偶数。故测分包问题时，切不可把16进制表示的数据包分奇数拆分，奇数拆分后涉及到byte自动补零问题，最终导致分包测试失败，逻辑数据不准确。\n2. 使用socket工具发送，使用netty原生的`LengthFieldBasedFrameDecoder`即可满足需求\n3. `LengthFieldBasedFrameDecoder`长度协议，长度也必须为16进制表示，不然取前几位转16进制之后，容易抛出异常`Adjusted frame length exceeds`\n4. 如若没有长度协议，服务端会每1024字节分包读取（待解决处理）\n\n## 其他分包解决方案\n\n1. 定长协议 \n\n   ```java\n   new FixedLengthFrameDecoder(1024)\n   ```\n\n2. 分隔符协议\n\n   ```java\n   //设置特殊分隔符\n   ByteBuf buf = Unpooled.copiedBuffer(\"_\".getBytes());\n   new DelimiterBasedFrameDecoder(1024, buf);\n   ```\n\n3. 待补充。。\n\n\n","slug":"netty/netty分包粘包问题","published":1,"updated":"2021-03-31T07:58:11.297Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknqx8kfb001fbotk5fdfghoa","content":"<h2 id=\"基于长度协议的分包\"><a href=\"#基于长度协议的分包\" class=\"headerlink\" title=\"基于长度协议的分包\"></a>基于长度协议的分包</h2><p>注：本文 length 均为 16进制表示，eg:  1232 ==&gt; 04D0</p>\n<p>[TOC]</p>\n<h3 id=\"1-业务场景介绍\"><a href=\"#1-业务场景介绍\" class=\"headerlink\" title=\"1. 业务场景介绍\"></a>1. 业务场景介绍</h3><p>基于长度协议分包（length + value）</p>\n<p>在和c语言对接过程中，因数据包长度大于一定长度后分包发送，致使handler接收数据不全出现问题。</p>\n<h3 id=\"2-具体现象描述\"><a href=\"#2-具体现象描述\" class=\"headerlink\" title=\"2. 具体现象描述\"></a>2. 具体现象描述</h3><ol>\n<li>c语言方 每1011字节就会自动分多小包发送</li>\n<li>使用netty自带的长度协议 LengthFieldBasedFrameDecoder 只能接收到半包</li>\n</ol>\n<h3 id=\"3-解决思路\"><a href=\"#3-解决思路\" class=\"headerlink\" title=\"3. 解决思路\"></a>3. 解决思路</h3><p>自定义长度协议包，根据length 进行判断包是否完整，进而决定是否进逻辑层处理</p>\n<h3 id=\"4-具体实现\"><a href=\"#4-具体实现\" class=\"headerlink\" title=\"4. 具体实现\"></a>4. 具体实现</h3><h4 id=\"4-1-服务端实现\"><a href=\"#4-1-服务端实现\" class=\"headerlink\" title=\"4.1 服务端实现\"></a>4.1 服务端实现</h4><ol>\n<li>基础服务端server，三个处理器分别为：日志、自定义长度协议、逻辑处理</li>\n</ol>\n<pre><code class=\"java\">@Slf4j\npublic class NettyServer &#123;\n\n    public static void main(String[] args) &#123;\n\n        // 1. 创建两个工作线程组，两个无线循环(默认线程组为   cpu核数 * 2 )\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1); // 处理客户端的链接\n        EventLoopGroup workerGroup = new NioEventLoopGroup(8);  // 网络的读写\n        try &#123;\n            // 2. 服务启动配置\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup,workerGroup)\n                    .channel(NioServerSocketChannel.class)  // 使用NioServerSocketChannel 作为服务端的通道实现\n                    .option(ChannelOption.SO_BACKLOG, 128)  // 设置线程队列连接个数\n                    .childOption(ChannelOption.SO_KEEPALIVE, true)  // 设置保持活动连接状态\n                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;  //创建一个通道初始化对象\n                        @Override\n                        protected void initChannel(SocketChannel ch) &#123; // 给pipeline设置处理器\n                            ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));\n                            // 自定义长度协议\n                            ch.pipeline().addLast(new MyLengthFieldBasedFrameDecoder(1024,0,2));\n                            // netty官方长度协议\n//                            ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024*2,0,2));\n                            ch.pipeline().addLast(new NettyServerHandler());\n                        &#125;\n                    &#125;);\n            ChannelFuture channelFuture = bootstrap.bind(9999).sync();\n            channelFuture.channel().closeFuture().sync();\n        &#125;catch (Exception e)&#123;\n            log.error(&quot;启动异常，优雅关闭&quot;,e);\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n<h4 id=\"4-2-自定义长度协议处理器\"><a href=\"#4-2-自定义长度协议处理器\" class=\"headerlink\" title=\"4.2 自定义长度协议处理器\"></a>4.2 自定义长度协议处理器</h4><ol>\n<li>基础构造函数，获取基础数据信息：包最大长度、长度位起始位置、长度位结束位置、逻辑数据截取起始位置、逻辑数据截取长度</li>\n<li>使用netty自带当前线程变量记录当前线程基础数据</li>\n<li>根据 <strong><em>length</em></strong> 判断包是否完整</li>\n<li>若包完整，则使用 <strong><em>super.channelRead(XX,XX);</em></strong> 进入下一个handler</li>\n</ol>\n<pre><code class=\"java\">/**\n * netty 服务端逻辑处理类（长度为16进制编码）\n * 这种分包，不支持奇数16进制分包，必须是整个字节，eg：000430245678  分包：3024567   、8 错误。\n * 必须两个十六进制组成一个byte分包才对\n * @author zxl\n * @date 2021/3/23 10:29\n */\n@Slf4j\npublic class MyLengthFieldBasedFrameDecoder extends ChannelInboundHandlerAdapter &#123;\n\n    /*** 实际长度 */\n    private FastThreadLocal&lt;Integer&gt; actualLength = new FastThreadLocal&lt;&gt;();\n    /*** 实际内容 */\n    private FastThreadLocal&lt;byte[]&gt; actualContent = new FastThreadLocal&lt;&gt;();\n    /*** 最大长度 */\n    private FastThreadLocal&lt;Integer&gt; maxFrameLength = new FastThreadLocal&lt;&gt;();\n    /*** 长度位数起始下标 */\n    private FastThreadLocal&lt;Integer&gt; lengthFieldOffset = new FastThreadLocal&lt;&gt;();\n    /*** 长度位数结束下标 */\n    private FastThreadLocal&lt;Integer&gt; lengthFieldLength = new FastThreadLocal&lt;&gt;();\n    /*** 长度调整起始下标 */\n    private FastThreadLocal&lt;Integer&gt; lengthAdjustment = new FastThreadLocal&lt;&gt;();\n    /*** 长度调整结束下标 */\n    private FastThreadLocal&lt;Integer&gt; initialBytesToStrip = new FastThreadLocal&lt;&gt;();\n\n    /**\n     * 基础构造方法\n     * @param maxFrameLength 最大长度\n     * @param lengthFieldOffset 长度下标起始位置\n     * @param lengthFieldLength 长度所占字节位数\n     */\n    public MyLengthFieldBasedFrameDecoder(int maxFrameLength, int lengthFieldOffset, int lengthFieldLength) &#123;\n        this(maxFrameLength, lengthFieldOffset, lengthFieldLength, 0, 0);\n    &#125;\n\n    /**\n     * 基础构造方法\n     * @param maxFrameLength 最大长度\n     * @param lengthFieldOffset 长度下标起始位置\n     * @param lengthFieldLength 长度所占字节位数\n     * @param lengthAdjustment 真实数据下标起始位置\n     * @param initialBytesToStrip 初始化略过字节数\n     */\n    public MyLengthFieldBasedFrameDecoder(int maxFrameLength, int lengthFieldOffset, int lengthFieldLength, int lengthAdjustment, int initialBytesToStrip) &#123;\n        if (maxFrameLength &lt;= 0) &#123;\n            throw new IllegalArgumentException(&quot;maxFrameLength must be a positive integer: &quot; + maxFrameLength);\n        &#125; else if (lengthFieldOffset &lt; 0) &#123;\n            throw new IllegalArgumentException(&quot;lengthFieldOffset must be a non-negative integer: &quot; + lengthFieldOffset);\n        &#125; else if (initialBytesToStrip &lt; 0) &#123;\n            throw new IllegalArgumentException(&quot;initialBytesToStrip must be a non-negative integer: &quot; + initialBytesToStrip);\n        &#125; else if (lengthFieldOffset &gt; maxFrameLength - lengthFieldLength) &#123;\n            throw new IllegalArgumentException(&quot;maxFrameLength (&quot; + maxFrameLength + &quot;) must be equal to or greater than lengthFieldOffset (&quot; + lengthFieldOffset + &quot;) + lengthFieldLength (&quot; + lengthFieldLength + &quot;).&quot;);\n        &#125;else&#123;\n            this.maxFrameLength.set(maxFrameLength);\n            this.lengthFieldOffset.set(lengthFieldOffset);\n            this.lengthFieldLength.set(lengthFieldLength);\n            this.lengthAdjustment.set(lengthAdjustment);\n            this.initialBytesToStrip.set(initialBytesToStrip);\n        &#125;\n    &#125;\n\n    /**\n     * 实际数据读取处理\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n        // 1. 数据读取\n        ByteBuf byteBuf = (ByteBuf) msg;\n        byte[] requestMsg = new byte[byteBuf.readableBytes()];\n        byteBuf.readBytes(requestMsg);\n\n        // 2. 首次消息判断,并对数据处理\n        if(actualContent.get() == null)&#123;\n            String receiveMsg = bytesToHex(requestMsg);\n            // 因为是字节数据长度，2个字节，故需要截取4位长度。下移开始下标*2，假设不是 length + value 格式\n            String length = receiveMsg.substring(this.lengthFieldOffset.get(), this.lengthFieldLength.get()*2);\n            // 默认长度为 16进制表示\n            int i = Integer.parseInt(length, 16);\n            log.info(&quot;第一次数据接收:&#123;&#125;,数据长度:&#123;&#125;&quot;,receiveMsg,i);\n            if(i + this.lengthFieldLength.get() == requestMsg.length)&#123;\n                super.channelRead(ctx,requestMsg);\n            &#125;\n            // 数据长度，带长度位\n            actualLength.set(i + this.lengthFieldLength.get());\n            actualContent.set(requestMsg);\n        &#125;else&#123;\n            // 3. 二次分包处理\n            byte[] content = actualContent.get();\n            int newLength = content.length + requestMsg.length;\n            if(newLength &gt; maxFrameLength.get())&#123;\n                throw new TooLongFrameException(&quot;Adjusted frame length exceeds &quot; + this.maxFrameLength.get() + &quot; - discarding&quot;);\n            &#125;\n\n            byte[] next = appendByteArray(content,requestMsg);\n            log.info(&quot;next:&#123;&#125;&quot;,bytesToHex(next));\n            if(actualLength.get() == newLength)&#123;\n                byte[] actByte = null;\n                if(lengthAdjustment.get() == 0)&#123;\n                    actByte = Arrays.copyOfRange(next, initialBytesToStrip.get(), next.length);\n                &#125;else&#123;\n                    byte[] startByte = Arrays.copyOfRange(next, 0, lengthAdjustment.get());\n                    byte[] endByte = Arrays.copyOfRange(next, initialBytesToStrip.get(), next.length);\n                    actByte = appendByteArray(startByte,endByte);\n                &#125;\n                super.channelRead(ctx,actByte);\n            &#125;else&#123;\n                actualContent.set(next);\n            &#125;\n        &#125;\n    &#125;\n\n    /**\n     * 执行中异常\n     * @param ctx 上下文\n     * @param cause 执行异常\n     * @throws Exception 方法体异常\n     */\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;\n        log.error(&quot;执行中异常&quot;,cause);\n        releaseThreadLocalResource();\n        ctx.close();\n    &#125;\n\n    /**\n     * 连接断开时，释放当前线程变量资源\n     * @param ctx 上下文\n     * @throws Exception 执行中异常\n     */\n    @Override\n    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception &#123;\n        releaseThreadLocalResource();\n        log.info(&quot;客户端连接断开了+++++++&#123;&#125;&quot;,ctx.channel().remoteAddress().toString());\n        super.channelUnregistered(ctx);\n    &#125;\n\n    /**\n     * 释放当前线程变量\n     */\n    private void releaseThreadLocalResource()&#123;\n        maxFrameLength.remove();\n        lengthFieldOffset.remove();\n        lengthFieldLength.remove();\n        lengthAdjustment.remove();\n        initialBytesToStrip.remove();\n        actualLength.remove();\n        actualContent.remove();\n    &#125;\n\n    /**\n     * byte[] 数组转16进制字符串\n     * @param bytes 字节数据\n     * @return 16进制字符串\n     */\n    private static String bytesToHex(byte[] bytes) &#123;\n        StringBuilder sb = new StringBuilder();\n        for (byte aByte : bytes) &#123;\n            String hex = Integer.toHexString(aByte &amp; 0xFF);\n            if (hex.length() &lt; 2) &#123;\n                sb.append(0);\n            &#125;\n            sb.append(hex);\n        &#125;\n        return sb.toString();\n    &#125;\n\n    /**\n     * 字节数组拼接\n     * @param array1 拼接第一个数组\n     * @param array2 第二个数组\n     * @return 拼接结果\n     */\n    private byte[] appendByteArray(byte[] array1,byte[] array2)&#123;\n        byte[] newArray = new byte[array1.length + array2.length];\n        System.arraycopy(array1,0,newArray,0,array1.length);\n        System.arraycopy(array2,0,newArray,array1.length,array2.length);\n        return newArray;\n    &#125;\n&#125;</code></pre>\n<h4 id=\"4-3-逻辑处理器\"><a href=\"#4-3-逻辑处理器\" class=\"headerlink\" title=\"4.3 逻辑处理器\"></a>4.3 逻辑处理器</h4><ol>\n<li>获取上一个 <strong><em>handler</em></strong> 处理之后的数据</li>\n<li><strong><em>channelRead</em></strong> 方法中 <strong><em>Object msg</em></strong> 对象类型是依据上一个 <strong><em>handler</em></strong>  中 <strong><em>channelRead()</em></strong> 传入的类型而定。即 <strong><em>super.channelRead(XX,XX);</em></strong>  第二个XX 所代表的类型</li>\n<li>因上一个 <strong><em>handler</em></strong> 传入为byte[] ，故下方以byte[] 接收。</li>\n<li>原生netty 长度协议 则为ByteBuf 接收。</li>\n</ol>\n<pre><code class=\"java\">/**\n * netty 服务端逻辑处理类\n * @author zxl\n * @date 2021/3/23 10:29\n */\n@Slf4j\npublic class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;\n\n    /**\n     * 连接注册时执行\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123;\n        log.info(&quot;客户端连接&#123;&#125;&quot;,ctx.channel().remoteAddress().toString());\n        super.channelRegistered(ctx);\n    &#125;\n\n    /**\n     * 连接关闭时执行\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception &#123;\n        log.info(&quot;客户端连接断开了&#123;&#125;&quot;,ctx.channel().remoteAddress().toString());\n        super.channelUnregistered(ctx);\n    &#125;\n\n    /**\n     * 连接活跃\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n        log.info(&quot;连接活跃，有信息进入&quot;);\n    &#125;\n\n    /**\n     * 连接不活跃\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;\n        log.info(&quot;连接不活跃，信息写完发送完毕&quot;);\n    &#125;\n    /**\n     * 实际数据读取处理\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n\n        if(msg instanceof byte[])&#123;\n            byte[] requestMsg = (byte[]) msg;\n            log.info(&quot;最终接收数据----:&#123;&#125;&quot;,bytesToHex(requestMsg));\n        &#125;else&#123;\n            ByteBuf byteBuf = (ByteBuf) msg;\n            byte[] requestMsg = new byte[byteBuf.readableBytes()];\n            byteBuf.readBytes(requestMsg);\n            log.info(&quot;ByteBuf 最终接收数据----:&#123;&#125;&quot;,bytesToHex(requestMsg));\n        &#125;\n    &#125;\n\n    /**\n     * 实际数据读取完成处理\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;\n        log.info(&quot;数据读取完毕之后 channelReadComplete &quot;);\n    &#125;\n\n\n    /**\n     * 连接事件判断\n     * @param ctx 上下文\n     * @param evt 事件对象\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;\n        log.info(&quot;channel 用户事件触发&quot;);\n    &#125;\n\n    /**\n     * 实际数据读取完成处理 ,关闭通道\n     * @param ctx 上下文\n     * @param cause 执行异常\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;\n        log.error(&quot;执行中异常&quot;,cause);\n        ctx.close();\n    &#125;\n\n\n    /**\n     * byte[] 数组转16进制字符串\n     * @param bytes 字节数据\n     * @return 16进制字符串\n     */\n    private static String bytesToHex(byte[] bytes) &#123;\n        StringBuilder sb = new StringBuilder();\n        for (byte aByte : bytes) &#123;\n            String hex = Integer.toHexString(aByte &amp; 0xFF);\n            if (hex.length() &lt; 2) &#123;\n                sb.append(0);\n            &#125;\n            sb.append(hex);\n        &#125;\n        return sb.toString();\n    &#125;\n&#125;</code></pre>\n<h3 id=\"5-测试方式\"><a href=\"#5-测试方式\" class=\"headerlink\" title=\"5. 测试方式\"></a>5. 测试方式</h3><blockquote>\n<p>上述代码为 长度均为2个字节，故以下也遵循代码走。</p>\n<p>测试数据包：<code>000C321453215435413415206753</code></p>\n<p>000C ==&gt;  12 (十进制)</p>\n<p>注：传输方式是以byte[] 进行传输，转16进制后，每两个16进制数为一个byte，故整体数据包长度一定为偶数。故测分包问题时，切不可把16进制表示的数据包分奇数拆分，奇数拆分后涉及到byte自动补零问题，最终导致分包测试失败，逻辑数据不准确。</p>\n</blockquote>\n<ol>\n<li>使用socket发送工具，组长度协议包( lenth[0x] + value)     </li>\n</ol>\n<p><img src=\"/2021/03/30/netty/netty%E5%88%86%E5%8C%85%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/%5Cnetty%5Cimage-20210331151558717.png\" alt=\"image-20210331151558717\"></p>\n<ol start=\"2\">\n<li><p>先整体发送 <code>000C321453215435413415206753</code>，查看是否会进入逻辑handler。查看没问题</p>\n<p><img src=\"/2021/03/30/netty/netty%E5%88%86%E5%8C%85%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/%5Cnetty%5Cimage-20210331152602573.png\" alt=\"image-20210331152602573\"></p>\n</li>\n<li><p>关闭工具重新打开（目前都是短连接测试），先发 <code>000C32145321543541341520</code>  ，再发<code>6753</code> 查看结果</p>\n<p><img src=\"/2021/03/30/netty/netty%E5%88%86%E5%8C%85%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/%5Cnetty%5Cimage-20210331153715016.png\" alt=\"image-20210331153715016\"></p>\n</li>\n<li><p>上述测试没有问题，使用厂商机器测试</p>\n</li>\n</ol>\n<h3 id=\"6-注意问题\"><a href=\"#6-注意问题\" class=\"headerlink\" title=\"6. 注意问题\"></a>6. 注意问题</h3><ol>\n<li>传输方式是以byte[] 进行传输，转16进制后，每两个16进制数为一个byte，故整体数据包长度一定为偶数。故测分包问题时，切不可把16进制表示的数据包分奇数拆分，奇数拆分后涉及到byte自动补零问题，最终导致分包测试失败，逻辑数据不准确。</li>\n<li>使用socket工具发送，使用netty原生的<code>LengthFieldBasedFrameDecoder</code>即可满足需求</li>\n<li><code>LengthFieldBasedFrameDecoder</code>长度协议，长度也必须为16进制表示，不然取前几位转16进制之后，容易抛出异常<code>Adjusted frame length exceeds</code></li>\n<li>如若没有长度协议，服务端会每1024字节分包读取（待解决处理）</li>\n</ol>\n<h2 id=\"其他分包解决方案\"><a href=\"#其他分包解决方案\" class=\"headerlink\" title=\"其他分包解决方案\"></a>其他分包解决方案</h2><ol>\n<li><p>定长协议 </p>\n<pre><code class=\"java\">new FixedLengthFrameDecoder(1024)</code></pre>\n</li>\n<li><p>分隔符协议</p>\n<pre><code class=\"java\">//设置特殊分隔符\nByteBuf buf = Unpooled.copiedBuffer(&quot;_&quot;.getBytes());\nnew DelimiterBasedFrameDecoder(1024, buf);</code></pre>\n</li>\n<li><p>待补充。。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基于长度协议的分包\"><a href=\"#基于长度协议的分包\" class=\"headerlink\" title=\"基于长度协议的分包\"></a>基于长度协议的分包</h2><p>注：本文 length 均为 16进制表示，eg:  1232 ==&gt; 04D0</p>\n<p>[TOC]</p>\n<h3 id=\"1-业务场景介绍\"><a href=\"#1-业务场景介绍\" class=\"headerlink\" title=\"1. 业务场景介绍\"></a>1. 业务场景介绍</h3><p>基于长度协议分包（length + value）</p>\n<p>在和c语言对接过程中，因数据包长度大于一定长度后分包发送，致使handler接收数据不全出现问题。</p>\n<h3 id=\"2-具体现象描述\"><a href=\"#2-具体现象描述\" class=\"headerlink\" title=\"2. 具体现象描述\"></a>2. 具体现象描述</h3><ol>\n<li>c语言方 每1011字节就会自动分多小包发送</li>\n<li>使用netty自带的长度协议 LengthFieldBasedFrameDecoder 只能接收到半包</li>\n</ol>\n<h3 id=\"3-解决思路\"><a href=\"#3-解决思路\" class=\"headerlink\" title=\"3. 解决思路\"></a>3. 解决思路</h3><p>自定义长度协议包，根据length 进行判断包是否完整，进而决定是否进逻辑层处理</p>\n<h3 id=\"4-具体实现\"><a href=\"#4-具体实现\" class=\"headerlink\" title=\"4. 具体实现\"></a>4. 具体实现</h3><h4 id=\"4-1-服务端实现\"><a href=\"#4-1-服务端实现\" class=\"headerlink\" title=\"4.1 服务端实现\"></a>4.1 服务端实现</h4><ol>\n<li>基础服务端server，三个处理器分别为：日志、自定义长度协议、逻辑处理</li>\n</ol>\n<pre><code class=\"java\">@Slf4j\npublic class NettyServer &#123;\n\n    public static void main(String[] args) &#123;\n\n        // 1. 创建两个工作线程组，两个无线循环(默认线程组为   cpu核数 * 2 )\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1); // 处理客户端的链接\n        EventLoopGroup workerGroup = new NioEventLoopGroup(8);  // 网络的读写\n        try &#123;\n            // 2. 服务启动配置\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup,workerGroup)\n                    .channel(NioServerSocketChannel.class)  // 使用NioServerSocketChannel 作为服务端的通道实现\n                    .option(ChannelOption.SO_BACKLOG, 128)  // 设置线程队列连接个数\n                    .childOption(ChannelOption.SO_KEEPALIVE, true)  // 设置保持活动连接状态\n                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;  //创建一个通道初始化对象\n                        @Override\n                        protected void initChannel(SocketChannel ch) &#123; // 给pipeline设置处理器\n                            ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));\n                            // 自定义长度协议\n                            ch.pipeline().addLast(new MyLengthFieldBasedFrameDecoder(1024,0,2));\n                            // netty官方长度协议\n//                            ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024*2,0,2));\n                            ch.pipeline().addLast(new NettyServerHandler());\n                        &#125;\n                    &#125;);\n            ChannelFuture channelFuture = bootstrap.bind(9999).sync();\n            channelFuture.channel().closeFuture().sync();\n        &#125;catch (Exception e)&#123;\n            log.error(&quot;启动异常，优雅关闭&quot;,e);\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n<h4 id=\"4-2-自定义长度协议处理器\"><a href=\"#4-2-自定义长度协议处理器\" class=\"headerlink\" title=\"4.2 自定义长度协议处理器\"></a>4.2 自定义长度协议处理器</h4><ol>\n<li>基础构造函数，获取基础数据信息：包最大长度、长度位起始位置、长度位结束位置、逻辑数据截取起始位置、逻辑数据截取长度</li>\n<li>使用netty自带当前线程变量记录当前线程基础数据</li>\n<li>根据 <strong><em>length</em></strong> 判断包是否完整</li>\n<li>若包完整，则使用 <strong><em>super.channelRead(XX,XX);</em></strong> 进入下一个handler</li>\n</ol>\n<pre><code class=\"java\">/**\n * netty 服务端逻辑处理类（长度为16进制编码）\n * 这种分包，不支持奇数16进制分包，必须是整个字节，eg：000430245678  分包：3024567   、8 错误。\n * 必须两个十六进制组成一个byte分包才对\n * @author zxl\n * @date 2021/3/23 10:29\n */\n@Slf4j\npublic class MyLengthFieldBasedFrameDecoder extends ChannelInboundHandlerAdapter &#123;\n\n    /*** 实际长度 */\n    private FastThreadLocal&lt;Integer&gt; actualLength = new FastThreadLocal&lt;&gt;();\n    /*** 实际内容 */\n    private FastThreadLocal&lt;byte[]&gt; actualContent = new FastThreadLocal&lt;&gt;();\n    /*** 最大长度 */\n    private FastThreadLocal&lt;Integer&gt; maxFrameLength = new FastThreadLocal&lt;&gt;();\n    /*** 长度位数起始下标 */\n    private FastThreadLocal&lt;Integer&gt; lengthFieldOffset = new FastThreadLocal&lt;&gt;();\n    /*** 长度位数结束下标 */\n    private FastThreadLocal&lt;Integer&gt; lengthFieldLength = new FastThreadLocal&lt;&gt;();\n    /*** 长度调整起始下标 */\n    private FastThreadLocal&lt;Integer&gt; lengthAdjustment = new FastThreadLocal&lt;&gt;();\n    /*** 长度调整结束下标 */\n    private FastThreadLocal&lt;Integer&gt; initialBytesToStrip = new FastThreadLocal&lt;&gt;();\n\n    /**\n     * 基础构造方法\n     * @param maxFrameLength 最大长度\n     * @param lengthFieldOffset 长度下标起始位置\n     * @param lengthFieldLength 长度所占字节位数\n     */\n    public MyLengthFieldBasedFrameDecoder(int maxFrameLength, int lengthFieldOffset, int lengthFieldLength) &#123;\n        this(maxFrameLength, lengthFieldOffset, lengthFieldLength, 0, 0);\n    &#125;\n\n    /**\n     * 基础构造方法\n     * @param maxFrameLength 最大长度\n     * @param lengthFieldOffset 长度下标起始位置\n     * @param lengthFieldLength 长度所占字节位数\n     * @param lengthAdjustment 真实数据下标起始位置\n     * @param initialBytesToStrip 初始化略过字节数\n     */\n    public MyLengthFieldBasedFrameDecoder(int maxFrameLength, int lengthFieldOffset, int lengthFieldLength, int lengthAdjustment, int initialBytesToStrip) &#123;\n        if (maxFrameLength &lt;= 0) &#123;\n            throw new IllegalArgumentException(&quot;maxFrameLength must be a positive integer: &quot; + maxFrameLength);\n        &#125; else if (lengthFieldOffset &lt; 0) &#123;\n            throw new IllegalArgumentException(&quot;lengthFieldOffset must be a non-negative integer: &quot; + lengthFieldOffset);\n        &#125; else if (initialBytesToStrip &lt; 0) &#123;\n            throw new IllegalArgumentException(&quot;initialBytesToStrip must be a non-negative integer: &quot; + initialBytesToStrip);\n        &#125; else if (lengthFieldOffset &gt; maxFrameLength - lengthFieldLength) &#123;\n            throw new IllegalArgumentException(&quot;maxFrameLength (&quot; + maxFrameLength + &quot;) must be equal to or greater than lengthFieldOffset (&quot; + lengthFieldOffset + &quot;) + lengthFieldLength (&quot; + lengthFieldLength + &quot;).&quot;);\n        &#125;else&#123;\n            this.maxFrameLength.set(maxFrameLength);\n            this.lengthFieldOffset.set(lengthFieldOffset);\n            this.lengthFieldLength.set(lengthFieldLength);\n            this.lengthAdjustment.set(lengthAdjustment);\n            this.initialBytesToStrip.set(initialBytesToStrip);\n        &#125;\n    &#125;\n\n    /**\n     * 实际数据读取处理\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n        // 1. 数据读取\n        ByteBuf byteBuf = (ByteBuf) msg;\n        byte[] requestMsg = new byte[byteBuf.readableBytes()];\n        byteBuf.readBytes(requestMsg);\n\n        // 2. 首次消息判断,并对数据处理\n        if(actualContent.get() == null)&#123;\n            String receiveMsg = bytesToHex(requestMsg);\n            // 因为是字节数据长度，2个字节，故需要截取4位长度。下移开始下标*2，假设不是 length + value 格式\n            String length = receiveMsg.substring(this.lengthFieldOffset.get(), this.lengthFieldLength.get()*2);\n            // 默认长度为 16进制表示\n            int i = Integer.parseInt(length, 16);\n            log.info(&quot;第一次数据接收:&#123;&#125;,数据长度:&#123;&#125;&quot;,receiveMsg,i);\n            if(i + this.lengthFieldLength.get() == requestMsg.length)&#123;\n                super.channelRead(ctx,requestMsg);\n            &#125;\n            // 数据长度，带长度位\n            actualLength.set(i + this.lengthFieldLength.get());\n            actualContent.set(requestMsg);\n        &#125;else&#123;\n            // 3. 二次分包处理\n            byte[] content = actualContent.get();\n            int newLength = content.length + requestMsg.length;\n            if(newLength &gt; maxFrameLength.get())&#123;\n                throw new TooLongFrameException(&quot;Adjusted frame length exceeds &quot; + this.maxFrameLength.get() + &quot; - discarding&quot;);\n            &#125;\n\n            byte[] next = appendByteArray(content,requestMsg);\n            log.info(&quot;next:&#123;&#125;&quot;,bytesToHex(next));\n            if(actualLength.get() == newLength)&#123;\n                byte[] actByte = null;\n                if(lengthAdjustment.get() == 0)&#123;\n                    actByte = Arrays.copyOfRange(next, initialBytesToStrip.get(), next.length);\n                &#125;else&#123;\n                    byte[] startByte = Arrays.copyOfRange(next, 0, lengthAdjustment.get());\n                    byte[] endByte = Arrays.copyOfRange(next, initialBytesToStrip.get(), next.length);\n                    actByte = appendByteArray(startByte,endByte);\n                &#125;\n                super.channelRead(ctx,actByte);\n            &#125;else&#123;\n                actualContent.set(next);\n            &#125;\n        &#125;\n    &#125;\n\n    /**\n     * 执行中异常\n     * @param ctx 上下文\n     * @param cause 执行异常\n     * @throws Exception 方法体异常\n     */\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;\n        log.error(&quot;执行中异常&quot;,cause);\n        releaseThreadLocalResource();\n        ctx.close();\n    &#125;\n\n    /**\n     * 连接断开时，释放当前线程变量资源\n     * @param ctx 上下文\n     * @throws Exception 执行中异常\n     */\n    @Override\n    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception &#123;\n        releaseThreadLocalResource();\n        log.info(&quot;客户端连接断开了+++++++&#123;&#125;&quot;,ctx.channel().remoteAddress().toString());\n        super.channelUnregistered(ctx);\n    &#125;\n\n    /**\n     * 释放当前线程变量\n     */\n    private void releaseThreadLocalResource()&#123;\n        maxFrameLength.remove();\n        lengthFieldOffset.remove();\n        lengthFieldLength.remove();\n        lengthAdjustment.remove();\n        initialBytesToStrip.remove();\n        actualLength.remove();\n        actualContent.remove();\n    &#125;\n\n    /**\n     * byte[] 数组转16进制字符串\n     * @param bytes 字节数据\n     * @return 16进制字符串\n     */\n    private static String bytesToHex(byte[] bytes) &#123;\n        StringBuilder sb = new StringBuilder();\n        for (byte aByte : bytes) &#123;\n            String hex = Integer.toHexString(aByte &amp; 0xFF);\n            if (hex.length() &lt; 2) &#123;\n                sb.append(0);\n            &#125;\n            sb.append(hex);\n        &#125;\n        return sb.toString();\n    &#125;\n\n    /**\n     * 字节数组拼接\n     * @param array1 拼接第一个数组\n     * @param array2 第二个数组\n     * @return 拼接结果\n     */\n    private byte[] appendByteArray(byte[] array1,byte[] array2)&#123;\n        byte[] newArray = new byte[array1.length + array2.length];\n        System.arraycopy(array1,0,newArray,0,array1.length);\n        System.arraycopy(array2,0,newArray,array1.length,array2.length);\n        return newArray;\n    &#125;\n&#125;</code></pre>\n<h4 id=\"4-3-逻辑处理器\"><a href=\"#4-3-逻辑处理器\" class=\"headerlink\" title=\"4.3 逻辑处理器\"></a>4.3 逻辑处理器</h4><ol>\n<li>获取上一个 <strong><em>handler</em></strong> 处理之后的数据</li>\n<li><strong><em>channelRead</em></strong> 方法中 <strong><em>Object msg</em></strong> 对象类型是依据上一个 <strong><em>handler</em></strong>  中 <strong><em>channelRead()</em></strong> 传入的类型而定。即 <strong><em>super.channelRead(XX,XX);</em></strong>  第二个XX 所代表的类型</li>\n<li>因上一个 <strong><em>handler</em></strong> 传入为byte[] ，故下方以byte[] 接收。</li>\n<li>原生netty 长度协议 则为ByteBuf 接收。</li>\n</ol>\n<pre><code class=\"java\">/**\n * netty 服务端逻辑处理类\n * @author zxl\n * @date 2021/3/23 10:29\n */\n@Slf4j\npublic class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;\n\n    /**\n     * 连接注册时执行\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123;\n        log.info(&quot;客户端连接&#123;&#125;&quot;,ctx.channel().remoteAddress().toString());\n        super.channelRegistered(ctx);\n    &#125;\n\n    /**\n     * 连接关闭时执行\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception &#123;\n        log.info(&quot;客户端连接断开了&#123;&#125;&quot;,ctx.channel().remoteAddress().toString());\n        super.channelUnregistered(ctx);\n    &#125;\n\n    /**\n     * 连接活跃\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n        log.info(&quot;连接活跃，有信息进入&quot;);\n    &#125;\n\n    /**\n     * 连接不活跃\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;\n        log.info(&quot;连接不活跃，信息写完发送完毕&quot;);\n    &#125;\n    /**\n     * 实际数据读取处理\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n\n        if(msg instanceof byte[])&#123;\n            byte[] requestMsg = (byte[]) msg;\n            log.info(&quot;最终接收数据----:&#123;&#125;&quot;,bytesToHex(requestMsg));\n        &#125;else&#123;\n            ByteBuf byteBuf = (ByteBuf) msg;\n            byte[] requestMsg = new byte[byteBuf.readableBytes()];\n            byteBuf.readBytes(requestMsg);\n            log.info(&quot;ByteBuf 最终接收数据----:&#123;&#125;&quot;,bytesToHex(requestMsg));\n        &#125;\n    &#125;\n\n    /**\n     * 实际数据读取完成处理\n     * @param ctx 上下文\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;\n        log.info(&quot;数据读取完毕之后 channelReadComplete &quot;);\n    &#125;\n\n\n    /**\n     * 连接事件判断\n     * @param ctx 上下文\n     * @param evt 事件对象\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;\n        log.info(&quot;channel 用户事件触发&quot;);\n    &#125;\n\n    /**\n     * 实际数据读取完成处理 ,关闭通道\n     * @param ctx 上下文\n     * @param cause 执行异常\n     * @throws Exception 执行异常\n     */\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;\n        log.error(&quot;执行中异常&quot;,cause);\n        ctx.close();\n    &#125;\n\n\n    /**\n     * byte[] 数组转16进制字符串\n     * @param bytes 字节数据\n     * @return 16进制字符串\n     */\n    private static String bytesToHex(byte[] bytes) &#123;\n        StringBuilder sb = new StringBuilder();\n        for (byte aByte : bytes) &#123;\n            String hex = Integer.toHexString(aByte &amp; 0xFF);\n            if (hex.length() &lt; 2) &#123;\n                sb.append(0);\n            &#125;\n            sb.append(hex);\n        &#125;\n        return sb.toString();\n    &#125;\n&#125;</code></pre>\n<h3 id=\"5-测试方式\"><a href=\"#5-测试方式\" class=\"headerlink\" title=\"5. 测试方式\"></a>5. 测试方式</h3><blockquote>\n<p>上述代码为 长度均为2个字节，故以下也遵循代码走。</p>\n<p>测试数据包：<code>000C321453215435413415206753</code></p>\n<p>000C ==&gt;  12 (十进制)</p>\n<p>注：传输方式是以byte[] 进行传输，转16进制后，每两个16进制数为一个byte，故整体数据包长度一定为偶数。故测分包问题时，切不可把16进制表示的数据包分奇数拆分，奇数拆分后涉及到byte自动补零问题，最终导致分包测试失败，逻辑数据不准确。</p>\n</blockquote>\n<ol>\n<li>使用socket发送工具，组长度协议包( lenth[0x] + value)     </li>\n</ol>\n<p><img src=\"/2021/03/30/netty/netty%E5%88%86%E5%8C%85%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/%5Cnetty%5Cimage-20210331151558717.png\" alt=\"image-20210331151558717\"></p>\n<ol start=\"2\">\n<li><p>先整体发送 <code>000C321453215435413415206753</code>，查看是否会进入逻辑handler。查看没问题</p>\n<p><img src=\"/2021/03/30/netty/netty%E5%88%86%E5%8C%85%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/%5Cnetty%5Cimage-20210331152602573.png\" alt=\"image-20210331152602573\"></p>\n</li>\n<li><p>关闭工具重新打开（目前都是短连接测试），先发 <code>000C32145321543541341520</code>  ，再发<code>6753</code> 查看结果</p>\n<p><img src=\"/2021/03/30/netty/netty%E5%88%86%E5%8C%85%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/%5Cnetty%5Cimage-20210331153715016.png\" alt=\"image-20210331153715016\"></p>\n</li>\n<li><p>上述测试没有问题，使用厂商机器测试</p>\n</li>\n</ol>\n<h3 id=\"6-注意问题\"><a href=\"#6-注意问题\" class=\"headerlink\" title=\"6. 注意问题\"></a>6. 注意问题</h3><ol>\n<li>传输方式是以byte[] 进行传输，转16进制后，每两个16进制数为一个byte，故整体数据包长度一定为偶数。故测分包问题时，切不可把16进制表示的数据包分奇数拆分，奇数拆分后涉及到byte自动补零问题，最终导致分包测试失败，逻辑数据不准确。</li>\n<li>使用socket工具发送，使用netty原生的<code>LengthFieldBasedFrameDecoder</code>即可满足需求</li>\n<li><code>LengthFieldBasedFrameDecoder</code>长度协议，长度也必须为16进制表示，不然取前几位转16进制之后，容易抛出异常<code>Adjusted frame length exceeds</code></li>\n<li>如若没有长度协议，服务端会每1024字节分包读取（待解决处理）</li>\n</ol>\n<h2 id=\"其他分包解决方案\"><a href=\"#其他分包解决方案\" class=\"headerlink\" title=\"其他分包解决方案\"></a>其他分包解决方案</h2><ol>\n<li><p>定长协议 </p>\n<pre><code class=\"java\">new FixedLengthFrameDecoder(1024)</code></pre>\n</li>\n<li><p>分隔符协议</p>\n<pre><code class=\"java\">//设置特殊分隔符\nByteBuf buf = Unpooled.copiedBuffer(&quot;_&quot;.getBytes());\nnew DelimiterBasedFrameDecoder(1024, buf);</code></pre>\n</li>\n<li><p>待补充。。</p>\n</li>\n</ol>\n"},{"title":"oracle基础语法","date":"2020-12-16T16:00:00.000Z","description":"oracle基础的语法及函数使用","_content":"\n## 1. oracle基础语法\n\n### 1.decode\n\ndecode (条件，值1，返回值1，值2，返回值2...，缺省值)\n\n### 2.trunc\n\n#### （1）截断数字\n\nTRUNC（n1,n2），n1表示被截断的数字，n2表示要截断到那一位。n2可以是负数，表示截断小数点前。注意，TRUNC截断不是四舍五入。\n\n```sql\nselect trunc(123.458,0) from dual; --123\nselect trunc(123.458,1) from dual; --123.4\nselect trunc(123.458,-1) from dual; --120\n```\n\n#### （2）截断日期\n\n```sql\nselect trunc(sysdate, 'mm') from dual; --2013-01-01 返回当月第一天.\n```\n\n| 值       | 含义                     |\n| -------- | ------------------------ |\n| mm       | 当月第一天               |\n| yy、yyyy | 返回当年第一天           |\n| dd       | 当前年月日               |\n| d        | 当前星期的第一天(星期天) |\n| hh       | 当前时间，精确到小时     |\n| mi       | 当前时间，精确到分       |\n\n### 3.add_months\n\nadd_months(times,num)：times是时间格式的日期，num为之后几个月，可为负数\n\n### 4. extract\n\n用法：从一个date或者interval类型中截取到特定的部分\n\n语法：\n\nextract ({ year | month | day | hour | minute | second | 某一时区 }\nfrom { date类型值 | interval类型值} )\n\n```sql\nselect extract (year from sysdate) year from dual\n```\n\n### 5. listagg\n\n用法：多行合并成一行\n\n语法：listagg('字段','分隔符') within group(order by 3)\n\n### 6. pivot\n\n用法：多行转多列\n\n语法：\n\n```sql\npivot (聚合函数(列名) [as 别名1] for 列名 in (列值 as 别名2,...));\n```\n\n注意：如果使用[as 别名1]，字段名为 **别名1_别名2**。","source":"_posts/数据库操作/oracle/oracle基础语法.md","raw":"---\ntitle: oracle基础语法\ndate: 2020-12-17 #文章生成时间，一般不改，当然也可以任意修改\ncategories: oracle #分类\ntags: [sql,oracle,函数] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: oracle基础的语法及函数使用\n---\n\n## 1. oracle基础语法\n\n### 1.decode\n\ndecode (条件，值1，返回值1，值2，返回值2...，缺省值)\n\n### 2.trunc\n\n#### （1）截断数字\n\nTRUNC（n1,n2），n1表示被截断的数字，n2表示要截断到那一位。n2可以是负数，表示截断小数点前。注意，TRUNC截断不是四舍五入。\n\n```sql\nselect trunc(123.458,0) from dual; --123\nselect trunc(123.458,1) from dual; --123.4\nselect trunc(123.458,-1) from dual; --120\n```\n\n#### （2）截断日期\n\n```sql\nselect trunc(sysdate, 'mm') from dual; --2013-01-01 返回当月第一天.\n```\n\n| 值       | 含义                     |\n| -------- | ------------------------ |\n| mm       | 当月第一天               |\n| yy、yyyy | 返回当年第一天           |\n| dd       | 当前年月日               |\n| d        | 当前星期的第一天(星期天) |\n| hh       | 当前时间，精确到小时     |\n| mi       | 当前时间，精确到分       |\n\n### 3.add_months\n\nadd_months(times,num)：times是时间格式的日期，num为之后几个月，可为负数\n\n### 4. extract\n\n用法：从一个date或者interval类型中截取到特定的部分\n\n语法：\n\nextract ({ year | month | day | hour | minute | second | 某一时区 }\nfrom { date类型值 | interval类型值} )\n\n```sql\nselect extract (year from sysdate) year from dual\n```\n\n### 5. listagg\n\n用法：多行合并成一行\n\n语法：listagg('字段','分隔符') within group(order by 3)\n\n### 6. pivot\n\n用法：多行转多列\n\n语法：\n\n```sql\npivot (聚合函数(列名) [as 别名1] for 列名 in (列值 as 别名2,...));\n```\n\n注意：如果使用[as 别名1]，字段名为 **别名1_别名2**。","slug":"数据库操作/oracle/oracle基础语法","published":1,"updated":"2020-12-18T01:46:39.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknqx8kfc001ibotkhfhqd2qo","content":"<h2 id=\"1-oracle基础语法\"><a href=\"#1-oracle基础语法\" class=\"headerlink\" title=\"1. oracle基础语法\"></a>1. oracle基础语法</h2><h3 id=\"1-decode\"><a href=\"#1-decode\" class=\"headerlink\" title=\"1.decode\"></a>1.decode</h3><p>decode (条件，值1，返回值1，值2，返回值2…，缺省值)</p>\n<h3 id=\"2-trunc\"><a href=\"#2-trunc\" class=\"headerlink\" title=\"2.trunc\"></a>2.trunc</h3><h4 id=\"（1）截断数字\"><a href=\"#（1）截断数字\" class=\"headerlink\" title=\"（1）截断数字\"></a>（1）截断数字</h4><p>TRUNC（n1,n2），n1表示被截断的数字，n2表示要截断到那一位。n2可以是负数，表示截断小数点前。注意，TRUNC截断不是四舍五入。</p>\n<pre><code class=\"sql\">select trunc(123.458,0) from dual; --123\nselect trunc(123.458,1) from dual; --123.4\nselect trunc(123.458,-1) from dual; --120</code></pre>\n<h4 id=\"（2）截断日期\"><a href=\"#（2）截断日期\" class=\"headerlink\" title=\"（2）截断日期\"></a>（2）截断日期</h4><pre><code class=\"sql\">select trunc(sysdate, &#39;mm&#39;) from dual; --2013-01-01 返回当月第一天.</code></pre>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mm</td>\n<td>当月第一天</td>\n</tr>\n<tr>\n<td>yy、yyyy</td>\n<td>返回当年第一天</td>\n</tr>\n<tr>\n<td>dd</td>\n<td>当前年月日</td>\n</tr>\n<tr>\n<td>d</td>\n<td>当前星期的第一天(星期天)</td>\n</tr>\n<tr>\n<td>hh</td>\n<td>当前时间，精确到小时</td>\n</tr>\n<tr>\n<td>mi</td>\n<td>当前时间，精确到分</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-add-months\"><a href=\"#3-add-months\" class=\"headerlink\" title=\"3.add_months\"></a>3.add_months</h3><p>add_months(times,num)：times是时间格式的日期，num为之后几个月，可为负数</p>\n<h3 id=\"4-extract\"><a href=\"#4-extract\" class=\"headerlink\" title=\"4. extract\"></a>4. extract</h3><p>用法：从一个date或者interval类型中截取到特定的部分</p>\n<p>语法：</p>\n<p>extract ({ year | month | day | hour | minute | second | 某一时区 }<br>from { date类型值 | interval类型值} )</p>\n<pre><code class=\"sql\">select extract (year from sysdate) year from dual</code></pre>\n<h3 id=\"5-listagg\"><a href=\"#5-listagg\" class=\"headerlink\" title=\"5. listagg\"></a>5. listagg</h3><p>用法：多行合并成一行</p>\n<p>语法：listagg(‘字段’,’分隔符’) within group(order by 3)</p>\n<h3 id=\"6-pivot\"><a href=\"#6-pivot\" class=\"headerlink\" title=\"6. pivot\"></a>6. pivot</h3><p>用法：多行转多列</p>\n<p>语法：</p>\n<pre><code class=\"sql\">pivot (聚合函数(列名) [as 别名1] for 列名 in (列值 as 别名2,...));</code></pre>\n<p>注意：如果使用[as 别名1]，字段名为 <strong>别名1_别名2</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-oracle基础语法\"><a href=\"#1-oracle基础语法\" class=\"headerlink\" title=\"1. oracle基础语法\"></a>1. oracle基础语法</h2><h3 id=\"1-decode\"><a href=\"#1-decode\" class=\"headerlink\" title=\"1.decode\"></a>1.decode</h3><p>decode (条件，值1，返回值1，值2，返回值2…，缺省值)</p>\n<h3 id=\"2-trunc\"><a href=\"#2-trunc\" class=\"headerlink\" title=\"2.trunc\"></a>2.trunc</h3><h4 id=\"（1）截断数字\"><a href=\"#（1）截断数字\" class=\"headerlink\" title=\"（1）截断数字\"></a>（1）截断数字</h4><p>TRUNC（n1,n2），n1表示被截断的数字，n2表示要截断到那一位。n2可以是负数，表示截断小数点前。注意，TRUNC截断不是四舍五入。</p>\n<pre><code class=\"sql\">select trunc(123.458,0) from dual; --123\nselect trunc(123.458,1) from dual; --123.4\nselect trunc(123.458,-1) from dual; --120</code></pre>\n<h4 id=\"（2）截断日期\"><a href=\"#（2）截断日期\" class=\"headerlink\" title=\"（2）截断日期\"></a>（2）截断日期</h4><pre><code class=\"sql\">select trunc(sysdate, &#39;mm&#39;) from dual; --2013-01-01 返回当月第一天.</code></pre>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mm</td>\n<td>当月第一天</td>\n</tr>\n<tr>\n<td>yy、yyyy</td>\n<td>返回当年第一天</td>\n</tr>\n<tr>\n<td>dd</td>\n<td>当前年月日</td>\n</tr>\n<tr>\n<td>d</td>\n<td>当前星期的第一天(星期天)</td>\n</tr>\n<tr>\n<td>hh</td>\n<td>当前时间，精确到小时</td>\n</tr>\n<tr>\n<td>mi</td>\n<td>当前时间，精确到分</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-add-months\"><a href=\"#3-add-months\" class=\"headerlink\" title=\"3.add_months\"></a>3.add_months</h3><p>add_months(times,num)：times是时间格式的日期，num为之后几个月，可为负数</p>\n<h3 id=\"4-extract\"><a href=\"#4-extract\" class=\"headerlink\" title=\"4. extract\"></a>4. extract</h3><p>用法：从一个date或者interval类型中截取到特定的部分</p>\n<p>语法：</p>\n<p>extract ({ year | month | day | hour | minute | second | 某一时区 }<br>from { date类型值 | interval类型值} )</p>\n<pre><code class=\"sql\">select extract (year from sysdate) year from dual</code></pre>\n<h3 id=\"5-listagg\"><a href=\"#5-listagg\" class=\"headerlink\" title=\"5. listagg\"></a>5. listagg</h3><p>用法：多行合并成一行</p>\n<p>语法：listagg(‘字段’,’分隔符’) within group(order by 3)</p>\n<h3 id=\"6-pivot\"><a href=\"#6-pivot\" class=\"headerlink\" title=\"6. pivot\"></a>6. pivot</h3><p>用法：多行转多列</p>\n<p>语法：</p>\n<pre><code class=\"sql\">pivot (聚合函数(列名) [as 别名1] for 列名 in (列值 as 别名2,...));</code></pre>\n<p>注意：如果使用[as 别名1]，字段名为 <strong>别名1_别名2</strong>。</p>\n"},{"title":"rsa分段加密（小程序+java后台）","date":"2020-10-21T06:16:33.000Z","description":"小程序 + rsa分段加密。","_content":"\n[TOC]\n\n# 小程序RSA加密\n\n​\t小程序借用了一个大哥blog，如有侵权，请联系作者，立即整改。\n\n## 问题概述\n\n​\t小程序进行rsa加密时，出现加密失败、中文加密乱码，java加密小程序解不开，小程序加密java解密失败等相关问题。\n\n## 解决思路\n\n\t1. 使用分段加密解决大数据加密\n \t2. 中文加密之前转码（转16进制或其他）\n\n## 解决方案\n\n [rsa分段加密.rar](rsa分段加密(小程序+java后台)/rsa分段加密.rar) \n\n注：时间过长，等下次使用再次整理规范好了。主要使用方法如下：\n\n1. java main方法生成对应的加密结果（<font color=\"red\">中文需要进行先转码操作，不然个别中文因为编码规范，会出现乱码问题</font>）\n2. 小程序直接用java加密结果进行解密即可（反之也可）\n\n\n\n\n\n","source":"_posts/小程序相关/rsa分段加密(小程序+java后台).md","raw":"---\ntitle: rsa分段加密（小程序+java后台） #文章页面上的显示名称，一般是中文\ndate: 2020-10-21 14:16:33 #文章生成时间，一般不改，当然也可以任意修改\ncategories: 小程序 #分类\ntags: [小程序,RSA分段] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: 小程序 + rsa分段加密。\n\n---\n\n[TOC]\n\n# 小程序RSA加密\n\n​\t小程序借用了一个大哥blog，如有侵权，请联系作者，立即整改。\n\n## 问题概述\n\n​\t小程序进行rsa加密时，出现加密失败、中文加密乱码，java加密小程序解不开，小程序加密java解密失败等相关问题。\n\n## 解决思路\n\n\t1. 使用分段加密解决大数据加密\n \t2. 中文加密之前转码（转16进制或其他）\n\n## 解决方案\n\n [rsa分段加密.rar](rsa分段加密(小程序+java后台)/rsa分段加密.rar) \n\n注：时间过长，等下次使用再次整理规范好了。主要使用方法如下：\n\n1. java main方法生成对应的加密结果（<font color=\"red\">中文需要进行先转码操作，不然个别中文因为编码规范，会出现乱码问题</font>）\n2. 小程序直接用java加密结果进行解密即可（反之也可）\n\n\n\n\n\n","slug":"小程序相关/rsa分段加密(小程序+java后台)","published":1,"updated":"2021-04-22T02:13:06.236Z","_id":"ckns91cf2000gtstk6aj2g770","comments":1,"layout":"post","photos":[],"link":"","content":"<p>[TOC]</p>\n<h1 id=\"小程序RSA加密\"><a href=\"#小程序RSA加密\" class=\"headerlink\" title=\"小程序RSA加密\"></a>小程序RSA加密</h1><p>​    小程序借用了一个大哥blog，如有侵权，请联系作者，立即整改。</p>\n<h2 id=\"问题概述\"><a href=\"#问题概述\" class=\"headerlink\" title=\"问题概述\"></a>问题概述</h2><p>​    小程序进行rsa加密时，出现加密失败、中文加密乱码，java加密小程序解不开，小程序加密java解密失败等相关问题。</p>\n<h2 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h2><pre><code>1. 使用分段加密解决大数据加密\n 2. 中文加密之前转码（转16进制或其他）</code></pre>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p> <a href=\"rsa%E5%88%86%E6%AE%B5%E5%8A%A0%E5%AF%86(%E5%B0%8F%E7%A8%8B%E5%BA%8F+java%E5%90%8E%E5%8F%B0)/rsa%E5%88%86%E6%AE%B5%E5%8A%A0%E5%AF%86.rar\">rsa分段加密.rar</a> </p>\n<p>注：时间过长，等下次使用再次整理规范好了。主要使用方法如下：</p>\n<ol>\n<li>java main方法生成对应的加密结果（<font color=\"red\">中文需要进行先转码操作，不然个别中文因为编码规范，会出现乱码问题</font>）</li>\n<li>小程序直接用java加密结果进行解密即可（反之也可）</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"小程序RSA加密\"><a href=\"#小程序RSA加密\" class=\"headerlink\" title=\"小程序RSA加密\"></a>小程序RSA加密</h1><p>​    小程序借用了一个大哥blog，如有侵权，请联系作者，立即整改。</p>\n<h2 id=\"问题概述\"><a href=\"#问题概述\" class=\"headerlink\" title=\"问题概述\"></a>问题概述</h2><p>​    小程序进行rsa加密时，出现加密失败、中文加密乱码，java加密小程序解不开，小程序加密java解密失败等相关问题。</p>\n<h2 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h2><pre><code>1. 使用分段加密解决大数据加密\n 2. 中文加密之前转码（转16进制或其他）</code></pre>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p> <a href=\"rsa%E5%88%86%E6%AE%B5%E5%8A%A0%E5%AF%86(%E5%B0%8F%E7%A8%8B%E5%BA%8F+java%E5%90%8E%E5%8F%B0)/rsa%E5%88%86%E6%AE%B5%E5%8A%A0%E5%AF%86.rar\">rsa分段加密.rar</a> </p>\n<p>注：时间过长，等下次使用再次整理规范好了。主要使用方法如下：</p>\n<ol>\n<li>java main方法生成对应的加密结果（<font color=\"red\">中文需要进行先转码操作，不然个别中文因为编码规范，会出现乱码问题</font>）</li>\n<li>小程序直接用java加密结果进行解密即可（反之也可）</li>\n</ol>\n"}],"PostAsset":[{"_id":"source/_posts/并发/Java并发基础常见面试题总结/1266638-20180711104523327-1846448145.png","slug":"1266638-20180711104523327-1846448145.png","post":"cknqx8keo0000botk8top9vin","modified":0,"renderable":0},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/2019-4死锁1.png","slug":"2019-4死锁1.png","post":"cknqx8keo0000botk8top9vin","modified":0,"renderable":0},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/aa18972bd40735fa901e88768e0966b60d2408f4.jpeg","slug":"aa18972bd40735fa901e88768e0966b60d2408f4.jpeg","post":"cknqx8keo0000botk8top9vin","modified":0,"renderable":0},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/image-20201104094518290.png","slug":"image-20201104094518290.png","post":"cknqx8keo0000botk8top9vin","modified":0,"renderable":0},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/JVM运行时数据区域.png","slug":"JVM运行时数据区域.png","post":"cknqx8keo0000botk8top9vin","modified":0,"renderable":0},{"_id":"source/_posts/并发/Java并发基础常见面试题总结/进程.png","slug":"进程.png","post":"cknqx8keo0000botk8top9vin","modified":0,"renderable":0},{"_id":"source/_posts/并发/悲观锁与乐观锁/1.jpg","slug":"1.jpg","post":"cknqx8kes0001botk4j9mhgzo","modified":0,"renderable":0},{"_id":"source/_posts/并发/悲观锁与乐观锁/2.jpg","slug":"2.jpg","post":"cknqx8kes0001botk4j9mhgzo","modified":0,"renderable":0},{"_id":"source/_posts/并发/悲观锁与乐观锁/3.png","slug":"3.png","post":"cknqx8kes0001botk4j9mhgzo","modified":0,"renderable":0},{"_id":"source/_posts/java学习/JNA/使用c、c++方法/image-20210409171943084.png","slug":"image-20210409171943084.png","post":"cknqx8kew0006botkecw174w7","modified":0,"renderable":0},{"_id":"source/_posts/java学习/JNA/使用c、c++方法/image-20210409173144363.png","slug":"image-20210409173144363.png","post":"cknqx8kew0006botkecw174w7","modified":0,"renderable":0},{"_id":"source/_posts/java学习/JNA/使用c、c++方法/ZT_DEV.dll","slug":"ZT_DEV.dll","post":"cknqx8kew0006botkecw174w7","modified":0,"renderable":0},{"_id":"source/_posts/java学习/工具包学习/Comparable与Comparator/image-20210331103835480.png","slug":"image-20210331103835480.png","post":"cknqx8kf60010botkgp56c6v5","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203152440553.png","slug":"image-20210203152440553.png","post":"cknqx8kfa001bbotk1rlq6dev","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203152515345.png","slug":"image-20210203152515345.png","post":"cknqx8kfa001bbotk1rlq6dev","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203153111406.png","slug":"image-20210203153111406.png","post":"cknqx8kfa001bbotk1rlq6dev","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203153129592.png","slug":"image-20210203153129592.png","post":"cknqx8kfa001bbotk1rlq6dev","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203155002102.png","slug":"image-20210203155002102.png","post":"cknqx8kfa001bbotk1rlq6dev","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162313099.png","slug":"image-20210203162313099.png","post":"cknqx8kfa001bbotk1rlq6dev","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162451622.png","slug":"image-20210203162451622.png","post":"cknqx8kfa001bbotk1rlq6dev","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162535500.png","slug":"image-20210203162535500.png","post":"cknqx8kfa001bbotk1rlq6dev","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162538492.png","slug":"image-20210203162538492.png","post":"cknqx8kfa001bbotk1rlq6dev","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162645487.png","slug":"image-20210203162645487.png","post":"cknqx8kfa001bbotk1rlq6dev","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203162712582.png","slug":"image-20210203162712582.png","post":"cknqx8kfa001bbotk1rlq6dev","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210203163036267.png","slug":"image-20210203163036267.png","post":"cknqx8kfa001bbotk1rlq6dev","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210421105700214.png","slug":"image-20210421105700214.png","post":"cknqx8kfa001bbotk1rlq6dev","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210421112632294.png","slug":"image-20210421112632294.png","post":"cknqx8kfa001bbotk1rlq6dev","modified":0,"renderable":0},{"_id":"source/_posts/工具安装使用/聚合支付拉起流程/聚合支付流程/image-20210421112937615.png","slug":"image-20210421112937615.png","post":"cknqx8kfa001bbotk1rlq6dev","modified":0,"renderable":0},{"_id":"source/_posts/小程序相关/rsa分段加密(小程序+java后台)/rsa分段加密.rar","slug":"rsa分段加密.rar","post":"ckns91cf2000gtstk6aj2g770","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cknqx8keo0000botk8top9vin","category_id":"cknqx8ket0002botkb4wabpg3","_id":"cknqx8key000abotk4th9e549"},{"post_id":"cknqx8kes0001botk4j9mhgzo","category_id":"cknqx8ket0002botkb4wabpg3","_id":"cknqx8kez000cbotkevnx2pw8"},{"post_id":"cknqx8keu0004botkewv2ertp","category_id":"cknqx8key0009botkg6dc5vrg","_id":"cknqx8kf0000gbotk2yrlb46f"},{"post_id":"cknqx8kev0005botkfu4bdu3x","category_id":"cknqx8kez000dbotkgrj86bso","_id":"cknqx8kf1000lbotk90vl4rfb"},{"post_id":"cknqx8kew0006botkecw174w7","category_id":"cknqx8kez000dbotkgrj86bso","_id":"cknqx8kf1000pbotkgr405qjy"},{"post_id":"cknqx8kf5000zbotk0oxy9ubm","category_id":"cknqx8kez000dbotkgrj86bso","_id":"cknqx8kf80014botkaix31uzf"},{"post_id":"cknqx8kf60010botkgp56c6v5","category_id":"cknqx8kez000dbotkgrj86bso","_id":"cknqx8kf90017botk4xfjdkpq"},{"post_id":"cknqx8kf70012botkgzfw9t22","category_id":"cknqx8kez000dbotkgrj86bso","_id":"cknqx8kfa001cbotk4nb80z19"},{"post_id":"cknqx8kf70013botkhhp38s99","category_id":"cknqx8kf90019botkh7n44jkh","_id":"cknqx8kfd001mbotk1rzc7k3d"},{"post_id":"cknqx8kf90016botk9vqa549l","category_id":"cknqx8kf90019botkh7n44jkh","_id":"cknqx8kfe001pbotk1i2ebtmo"},{"post_id":"cknqx8kfa001bbotk1rlq6dev","category_id":"cknqx8kf90019botkh7n44jkh","_id":"cknqx8kfe001qbotkhldh80ei"},{"post_id":"cknqx8kfa001dbotk0hwla8sp","category_id":"cknqx8kfe001obotke8u3esra","_id":"cknqx8kff001vbotk6d1n4lbd"},{"post_id":"cknqx8kfb001fbotk5fdfghoa","category_id":"cknqx8kfe001sbotk91d0aya3","_id":"cknqx8kfg001zbotk6i5s2mzn"},{"post_id":"cknqx8kfc001ibotkhfhqd2qo","category_id":"cknqx8kfe001obotke8u3esra","_id":"cknqx8kfg0023botk0n6nekee"},{"post_id":"ckns91cf2000gtstk6aj2g770","category_id":"ckns930w0000otstkgqlb3kuz","_id":"ckns930w1000ptstkdkb9f4ox"}],"PostTag":[{"post_id":"cknqx8keo0000botk8top9vin","tag_id":"cknqx8keu0003botk9im12q4u","_id":"cknqx8kf0000fbotkb46t05ar"},{"post_id":"cknqx8keo0000botk8top9vin","tag_id":"cknqx8kex0008botk7lfya9zz","_id":"cknqx8kf0000hbotk2a0t89s7"},{"post_id":"cknqx8keo0000botk8top9vin","tag_id":"cknqx8kez000bbotkaq6f21pu","_id":"cknqx8kf0000kbotk52k2ffd7"},{"post_id":"cknqx8kes0001botk4j9mhgzo","tag_id":"cknqx8keu0003botk9im12q4u","_id":"cknqx8kf1000nbotkdet15flc"},{"post_id":"cknqx8kes0001botk4j9mhgzo","tag_id":"cknqx8kex0008botk7lfya9zz","_id":"cknqx8kf1000obotk71x0d34x"},{"post_id":"cknqx8keu0004botkewv2ertp","tag_id":"cknqx8kf1000mbotkfj017fqi","_id":"cknqx8kf2000sbotk8us1hf6d"},{"post_id":"cknqx8keu0004botkewv2ertp","tag_id":"cknqx8kf1000qbotk0y7i71w0","_id":"cknqx8kf2000tbotkf1ofhk0i"},{"post_id":"cknqx8kev0005botkfu4bdu3x","tag_id":"cknqx8kf2000rbotk3z3ggcay","_id":"cknqx8kf2000vbotk6pb34thh"},{"post_id":"cknqx8kew0006botkecw174w7","tag_id":"cknqx8kf2000ubotkddgshrx2","_id":"cknqx8kf3000xbotkf9v3fxn7"},{"post_id":"cknqx8kew0006botkecw174w7","tag_id":"cknqx8kf2000wbotk758w8shm","_id":"cknqx8kf3000ybotk26qvc113"},{"post_id":"cknqx8kf70012botkgzfw9t22","tag_id":"cknqx8kex0008botk7lfya9zz","_id":"cknqx8kf80015botkh6d39o6i"},{"post_id":"cknqx8kf70012botkgzfw9t22","tag_id":"cknqx8kf1000qbotk0y7i71w0","_id":"cknqx8kfa001abotk69d0fsow"},{"post_id":"cknqx8kf5000zbotk0oxy9ubm","tag_id":"cknqx8kf70011botkave39tr4","_id":"cknqx8kfc001hbotk05b713b3"},{"post_id":"cknqx8kf5000zbotk0oxy9ubm","tag_id":"cknqx8kf90018botkbq3ievye","_id":"cknqx8kfd001jbotk8jn1f8hl"},{"post_id":"cknqx8kf60010botkgp56c6v5","tag_id":"cknqx8kfb001ebotk604icn70","_id":"cknqx8kff001tbotkevqm0ek1"},{"post_id":"cknqx8kf60010botkgp56c6v5","tag_id":"cknqx8kfd001kbotkhmjt01nd","_id":"cknqx8kff001ubotk624cf84a"},{"post_id":"cknqx8kf60010botkgp56c6v5","tag_id":"cknqx8kfe001nbotk4c58hq6p","_id":"cknqx8kff001ybotkgxjo5asa"},{"post_id":"cknqx8kf70013botkhhp38s99","tag_id":"cknqx8kfe001rbotk3exl56xf","_id":"cknqx8kfg0021botk5xcn1ael"},{"post_id":"cknqx8kf70013botkhhp38s99","tag_id":"cknqx8kff001wbotk40anhvpe","_id":"cknqx8kfg0022botkaxyffmev"},{"post_id":"cknqx8kf90016botk9vqa549l","tag_id":"cknqx8kfg0020botk1aq599e2","_id":"cknqx8kfh0026botkc5g86xaz"},{"post_id":"cknqx8kf90016botk9vqa549l","tag_id":"cknqx8kfg0024botkczse4w7f","_id":"cknqx8kfh0027botk0s3mcsnz"},{"post_id":"cknqx8kfa001bbotk1rlq6dev","tag_id":"cknqx8kfg0025botk4y8ddbv6","_id":"cknqx8kfh002abotk8l6n476b"},{"post_id":"cknqx8kfa001bbotk1rlq6dev","tag_id":"cknqx8kfh0028botkekmy3k8h","_id":"cknqx8kfh002bbotk7esa0htu"},{"post_id":"cknqx8kfa001dbotk0hwla8sp","tag_id":"cknqx8kfh0029botk1q7vb08a","_id":"cknqx8kfi002fbotk2r0sh8w0"},{"post_id":"cknqx8kfa001dbotk0hwla8sp","tag_id":"cknqx8kfh002cbotkho99fkpy","_id":"cknqx8kfi002gbotk5htq6y5b"},{"post_id":"cknqx8kfa001dbotk0hwla8sp","tag_id":"cknqx8kfh002dbotkbu8yh9oc","_id":"cknqx8kfi002ibotk6mw4eqlr"},{"post_id":"cknqx8kfb001fbotk5fdfghoa","tag_id":"cknqx8kfi002ebotk3en29wai","_id":"cknqx8kfj002kbotkcokt4tyv"},{"post_id":"cknqx8kfb001fbotk5fdfghoa","tag_id":"cknqx8kex0008botk7lfya9zz","_id":"cknqx8kfj002lbotk6me96a3q"},{"post_id":"cknqx8kfb001fbotk5fdfghoa","tag_id":"cknqx8kfi002hbotkf1o4h3f5","_id":"cknqx8kfj002nbotkbkd3cyo7"},{"post_id":"cknqx8kfc001ibotkhfhqd2qo","tag_id":"cknqx8kfi002jbotk9q5x51qa","_id":"cknqx8kfj002pbotk10woceje"},{"post_id":"cknqx8kfc001ibotkhfhqd2qo","tag_id":"cknqx8kfj002mbotkg846aiic","_id":"cknqx8kfj002qbotkd85ght08"},{"post_id":"cknqx8kfc001ibotkhfhqd2qo","tag_id":"cknqx8kfj002obotk8bljhzik","_id":"cknqx8kfj002rbotkcnzibn5x"},{"post_id":"ckns91cf2000gtstk6aj2g770","tag_id":"ckns8yai90002tstkf2i6gok9","_id":"ckns91cf3000htstk7nk18ao9"},{"post_id":"ckns91cf2000gtstk6aj2g770","tag_id":"ckns8yaid0005tstk8dscducc","_id":"ckns91cf3000itstk3g6q1vzt"}],"Tag":[{"name":"锁机制","_id":"cknqx8keu0003botk9im12q4u"},{"name":"并发","_id":"cknqx8kex0008botk7lfya9zz"},{"name":"死锁","_id":"cknqx8kez000bbotkaq6f21pu"},{"name":"动态规划","_id":"cknqx8kf1000mbotkfj017fqi"},{"name":"java","_id":"cknqx8kf1000qbotk0y7i71w0"},{"name":"面试","_id":"cknqx8kf2000rbotk3z3ggcay"},{"name":"java调用c++方法","_id":"cknqx8kf2000ubotkddgshrx2"},{"name":"JNA","_id":"cknqx8kf2000wbotk758w8shm"},{"name":"按位与","_id":"cknqx8kf70011botkave39tr4"},{"name":"位运算","_id":"cknqx8kf90018botkbq3ievye"},{"name":"Comparable","_id":"cknqx8kfb001ebotk604icn70"},{"name":"Comparator","_id":"cknqx8kfd001kbotkhmjt01nd"},{"name":"排序","_id":"cknqx8kfe001nbotk4c58hq6p"},{"name":"pfx","_id":"cknqx8kfe001rbotk3exl56xf"},{"name":"cer","_id":"cknqx8kff001wbotk40anhvpe"},{"name":"hexo","_id":"cknqx8kfg0020botk1aq599e2"},{"name":"博客","_id":"cknqx8kfg0024botkczse4w7f"},{"name":"微信支付","_id":"cknqx8kfg0025botk4y8ddbv6"},{"name":"支付宝","_id":"cknqx8kfh0028botkekmy3k8h"},{"name":"运维","_id":"cknqx8kfh0029botk1q7vb08a"},{"name":"tag2","_id":"cknqx8kfh002cbotkho99fkpy"},{"name":"tag3","_id":"cknqx8kfh002dbotkbu8yh9oc"},{"name":"锁netty","_id":"cknqx8kfi002ebotk3en29wai"},{"name":"分包粘包","_id":"cknqx8kfi002hbotkf1o4h3f5"},{"name":"sql","_id":"cknqx8kfi002jbotk9q5x51qa"},{"name":"oracle","_id":"cknqx8kfj002mbotkg846aiic"},{"name":"函数","_id":"cknqx8kfj002obotk8bljhzik"},{"name":"小程序","_id":"ckns8yai90002tstkf2i6gok9"},{"name":"RSA分段","_id":"ckns8yaid0005tstk8dscducc"}]}}